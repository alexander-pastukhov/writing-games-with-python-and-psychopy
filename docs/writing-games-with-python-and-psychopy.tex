% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Writing games with Python and PsychoPy},
  pdfauthor={Alexander (Sasha) Pastukhov},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Writing games with Python and PsychoPy}
\author{Alexander (Sasha) Pastukhov}
\date{2023-06-19}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{intro}{%
\chapter{Introduction}\label{intro}}

This book will teach you programming. Hopefully, it will do so in a fun way because if there is something more satisfying than playing a video game then it is creating one. Although it is written for the course called \emph{``Python for social and experimental psychology''}, my main aim is not to teach you Python per se. Python is a fantastic tool (more on this later) but it is just one of many programming languages that exist. My ultimate goal is to help you to develop general programming skills, which do not depend on a specific programming language, and make sure that you form good habits that will make your code clear, easy to read, and easy to maintain. That last part is crucial. Programming is not about writing code that works. That, obviously, must be true but it is only the minimal requirement. Programming is about writing a clear and easy-to-read code that others and, even more importantly, you-two-weeks later can understand.

\hypertarget{prerequisites}{%
\section{Prerequisites}\label{prerequisites}}

The material assumes no foreknowledge of Python or programming from the reader. Its purpose is to gradually build up your knowledge and allow you to create more and more complex games.

\hypertarget{why-games}{%
\section{Why games?}\label{why-games}}

The actual purpose of this course is to teach psychology and social studies students how to program \emph{experiments}. That is what the real research is about. However, there is little practical difference between the two. The basic ingredients are the same and, arguably, experiments are just boring games. And, be assured, if you can program a game, you can certainly program an experiment.

\hypertarget{why-should-a-psychologist-learn-programming}{%
\section{Why should a psychologist learn programming?}\label{why-should-a-psychologist-learn-programming}}

Why should a psychologist, who is interested in people, learn how to program computers? The most obvious answer is that this is a useful skill. Being able to program gives you freedom to create an experiment that answers your research question, not an experiment that can be implemented given constraints of your software.

More importantly, at least from my point of view, learning how to program changes the way you think in general. People are smart but computers are dumb. When you explain your experiment or travel plans to somebody, you can be fairly vague, make a minor mistake, even skip certain parts. People are smart so they will fill in the missing information with their knowledge, spot and correct a mistake, ask you for more information, and can improvise on their own once they encounter something that you have not covered. Computers are dumb, so you must be precise, you cannot have gray areas, you cannot leave anything to ``it will figure it out once it happens'' (it won't). My personal experience, corroborated by psychologists who learned programming, is that it makes you realize just how vague and imprecise people can be without realizing it (and without you realizing this as well). Programming forces you to be precise and thorough, to plan ahead for any eventuality there might be. And this is a very useful skill by itself as it can be applied to any activity that requires planning be that an experimental design or travel arrangements.

\hypertarget{why-python}{%
\section{Why Python?}\label{why-python}}

There are many ways to create an experiment for psychological research. You can use drag-and-drop systems either commercial like \href{https://www.neurobs.com/}{Presentation}, \href{https://www.sr-research.com/experiment-builder/}{Experiment Builder} or free like \href{https://psychopy.org/builder}{PsychoPy Bulder interface}. They have a much shallower learning curve, so you can start creating and running your experiments faster. However, the simplicity of their use has a price: They are fairly limited in which stimuli you can use and how you can control the presentation schedule, conditions, feedback, etc. Typically, they allow you to extend them by programming the desired behavior but you do need to know how to program to do this (knowing Python supercharges your PsychoPy experiments). Thus, I think that while these systems, in particular \href{https://psychopy.org/}{PsychoPy}, are great tools to quickly bang a simple experiment together, they are most useful if you understand \emph{how} they create the underlying code and how you would program it yourself. Then, you will not be limited by the software, as you know you can program something the default drag-and-drop won't allow. At the same time, you can always opt in, if drag-and-drop is sufficient but faster or use a mix of the two approaches. At the end, it is about having options and creative freedom to program an experiment that will answer your research question, not an experiment that your software allows you to program.

We will learn programming in Python, which is a great language that combines simple and clear syntax with power and ability to tackle almost any problem. In this seminar, we will concentrate on desktop experiments but you can use it for online experiments (\href{https://otree.readthedocs.io/en/latest/}{oTree} and \href{https://psychopy.org/}{PsychoPy}), scientific programming (\href{https://numpy.org/}{NumPy} and \href{https://www.scipy.org/}{SciPy}), data analysis (\href{https://pandas.pydata.org/}{pandas}), machine learning (\href{https://scikit-learn.org/}{scikit-learn}), deep learning (\href{https://keras.io/}{keras}), website programming (\href{https://www.djangoproject.com/}{django}), computer vision (\href{https://opencv.org/}{OpenCV}), etc. Thus, Python is one of the most versatile programming tools that you can use for all stages of your research or work. And, Python is free, so you do not need to worry whether you or your future employer will be able to afford license fees (a very real problem, if you use Matlab).

\hypertarget{seminar-specific-information}{%
\section{Seminar-specific information}\label{seminar-specific-information}}

This is a material for \emph{Python for social and experimental psychology} seminar as taught by me at the University of Bamberg. Each chapter covers a single game, introducing necessary ideas and is accompanied by exercises that you need to complete and submit. To pass the seminar, you will need to complete all assignments, i.e., write all the games. You do not need to complete or provide correct solutions for \emph{all} the exercises to pass the course and information on how the points for exercises will be converted to an actual grade (if you need one) or ``pass'' will be available during the seminar.

The material is structured, so that each chapter or chapter section correspond to a single meeting. However, we are all different, so work at your own pace, read the material and submit assignments independently. I will provide detailed feedback for each assignment and you will have an opportunity to address issues and resubmit again with no loss of points. Note that my feedback will cover not only the actual problems with the code but the way you implemented the solution and how clean and well-documented your code is. Remember, our task is not just to learn how to program a working game but how to write a nice clear easy-to-read-and-maintain code\footnote{Good habits! Form good habits! Thank you for reading this subliminal message.}.

Very important: Do not hesitate to ask questions. If I feel that you missed the information in the material, I will point you to the exact location. If you are confused, I'll gently prod you with questions so that you will solve your own problem. If you need more information, I'll supply it. If you simply want to know more, ask and I'll explain why things are the way they are or suggest what to read. If I feel that you should be able to solve the issue without my help, I'll tell you so (although, I would still probably ask a few hinting questions).

\hypertarget{about-the-material}{%
\section{About the material}\label{about-the-material}}

This material is \textbf{free to use} and is licensed under the \href{https://creativecommons.org/licenses/by-nc-nd/4.0/}{Creative Commons Attribution-NonCommercial-NoDerivatives V4.0 International License}.

\hypertarget{software}{%
\chapter{Software}\label{software}}

For this book and seminar, we will need to install

\begin{itemize}
\tightlist
\item
  PsychoPy that comes bundled with Python.
\item
  IDE of your choice. My instructions will be for Visual Studio Code, which has a very good Python support.
\item
  Jupyter Notebook for trying out small snippets of code.
\end{itemize}

I will not give detailed instructions on how to install the necessary software but rather point you to official manuals. This makes this text more future-proof as specific details might easily change\footnote{If you are part of the seminar, ask me whenever you have problems or are unsure about how to proceeed}.

\hypertarget{install-psychopy}{%
\section{PsychoPy}\label{install-psychopy}}

Download and install \href{https://www.psychopy.org/download.html}{Standalone PsychoPy} version. Use whatever the latest (and greatest) PsychoPy version is suggested to you (PsychoPy 2022.2.4 using Python 3.8 as of time of writing) and follow instructions.

Note that you can also install PsychoPy as a anaconda package or install an official Python distribution and add PsychoPy via pip. However, I find the standalone easier to use as it has all necessary additional libraries. Plus, it has additional tools for GUI-based experiment programming and integration with \href{https://pavlovia.org/}{Pavlovia.org}.

\hypertarget{install-vs-code}{%
\section{VS Code}\label{install-vs-code}}

\href{https://code.visualstudio.com/}{Visual Studio Code} is a free lightweight open-source editor with strong support for Python. Download the installer for your platform and follow the instructions.

Next, follow \href{https://code.visualstudio.com/docs/python/python-tutorial}{Getting Started with Python in VS Code} tutorial. \textbf{Skip} the \emph{Install a Python interpreter} section, as you already have Python installation bundled with PsychoPy. This is the interpreter that you should use in the \emph{Select a Python interpreter} section. In my case the path is \texttt{C:\textbackslash{}Program\ Files\textbackslash{}PsychoPy3\textbackslash{}python.exe}.

Install and enable a linter, software that highlights syntactical and stylistic problems in your Python source code. Follow the \href{https://code.visualstudio.com/docs/python/linting}{manual} at VS Code website.

\hypertarget{jupyter-notebooks}{%
\section{Jupyter Notebooks}\label{jupyter-notebooks}}

\href{https://jupyter.org/}{Jupyter Notebooks} offer a very convenient way to mix text, figure and code in a single document. They also make it easy to play with various small snippets in parallel without running scripts. We will rely on them for our first chapter and for an occasional exercises or code testing later on. There are two way you can use them: 1) in VS Code using Jupyter extension, 2) in your browser using classical interface.

\hypertarget{jupyter-notebooks-in-vs-code}{%
\subsection{Jupyter Notebooks in VS Code}\label{jupyter-notebooks-in-vs-code}}

Follow \href{https://code.visualstudio.com/docs/datascience/jupyter-notebooks}{the manual} on how to install Jupyter package and use notebooks in VS Code.

\hypertarget{jupyter-notebooks-in-anaconda}{%
\subsection{Jupyter Notebooks in Anaconda}\label{jupyter-notebooks-in-anaconda}}

The simplest way to use Jupyter Notebooks along with a lot of other useful data science tools is via \href{https://www.anaconda.com/products/individual}{Anaconda} toolkit. However, note that this will introduce a \emph{second} Python distribution to your system. This, in turn, could lead to some confusion when working with scripts in VS Code if you accidentally have Anaconda interpreter active instead of the PsychoPy one. Do not panic, follow \href{https://code.visualstudio.com/docs/python/python-tutorial\#_select-a-python-interpreter}{Select a Python interpreter} instructions and make sure that you have PsychoPy interpreter as the active one.

Otherwise, download and install Anaconda. The website has an excellent \href{https://docs.anaconda.com/anaconda/user-guide/getting-started/}{Getting started} section.

\hypertarget{files-folder}{%
\section{Keeping things tidy}\label{files-folder}}

Before we start, I suggest that you create a folder called \emph{games-with-python} (or something along these lines). If you opted to use Jupyter Notebooks via Anaconda, you should create it in your user folder because this is where Anaconda would expects to find them. Then, create a new subfolder for each chapter / game. For the seminar, you would need to zip and upload a folder with all the files.

\hypertarget{programming-tips}{%
\chapter{Programming tips and tricks}\label{programming-tips}}

Below are some tips about writing and reading the code. Some may sound cryptic when you read them for the first time (they will become clear once we cover the necessary material). Some will feel like an overkill for simple projects that we will be implementing. I suggest that you read this section casually the very first time but return to it frequently once we start to program in earnest. Unfortunately, these tricks won't work it you do not use them! So you should \emph{always} use them and they should become your \emph{good habits}, like using a seat belt. The seat belt does nothing useful on most (hopefully, all) days but you wear it because it might suddenly and very urgently become extremely useful and you can never be sure when this will happen. Same with coding. Quite often you will be tempted to write ``quick-n-dirty'' code because this is just a ``simple test'', temporary solution, a prototype, a pilot experiment, etc. But, as they say ``There is nothing more permanent than a temporary solution''. More often than not, you will find that your toy code grew into a full blown experiment and it is a mess. Or you want to come back to that pilot experiment you did a few months ago but realize that it is easier to start from scratch than to understand how that monster works\footnote{Happened to me more often than I dare to admit.}. Thus, resist the temptation! Form the good habits and you future-you will be very grateful!

\hypertarget{writing-tips}{%
\section{Writing the code}\label{writing-tips}}

\hypertarget{use-a-linter}{%
\subsection{Use a linter}\label{use-a-linter}}

Linter is a program that analyses your code \emph{style} and highlights any issues it finds: spaces where should be none, no spaces where should be some, wrong names, overly long lines, etc. These do not affect how the code runs but following linter's advice results in a consistent standard if boring-looking\footnote{``Boring is Good!'', see ``The Hitman's Bodyguard'' movie.} Python code. Try to address all the problems that the linter raised. However, use your better judgment because sometimes lines that are longer than linter would prefer are more readable than two shorter ones. Similarly, a ``bad'' variable name by linter standards can be a meaningful name for a psychologist. Remember, your code is for people, not for the linter.

\hypertarget{document-your-code}{%
\subsection{Document your code}\label{document-your-code}}

Every time you create a new file: document it and update the documentation whenever you add/change/delete new functions or classes. Every time your create a new function: document it. New class: document it. New constant: unless it is super clear from the name alone, document it. You will learn a \href{https://numpydoc.readthedocs.io/en/latest/format.html}{NumPy} way of doing this in the book.

I cannot stress how important documenting your code is. VS Code (an editor that we will use) is smart enough to parse NumPy docstring, so it will show this help to you whenever you use your own functions (helps you to help you!). More importantly, writing documentation forces you to think and formulate (in human language!) what the function or class is doing, what type the arguments / attributes / methods are, what is the range of valid values, what are the defaults, what should a function return, etc. More often than not, you will realize that you have overlooked some important detail that may not be apparent from the code itself.

\hypertarget{add-some-air}{%
\subsection{Add some air}\label{add-some-air}}

Separate chunks of code with some empty lines. Think paragraphs in the normal text. You wouldn't want your book to be a single paragraph nightmare? Put a comment before each chunk that explains \emph{what} it does but not \emph{how} it does it. E.g., in our typical PsychoPy-based game there will be a point when we draw all stimuli and redraw the window. That is a nice self-contained chunk that can be described as \texttt{\#\ drawing\ all\ stimuli}. The code provides details on what exactly is drawn, what is the drawing order, etc. But that single comment will help you to understand what this chunk is about and whether it is relevant for you at the moment. Same goes for \texttt{\#\ processing\ key\ presses} or \texttt{\#\ checking\ gameover\ conditions}, etc. But be careful and make sure that the comment describes the code correctly. E.g., if the comment says \texttt{\#\ drawing\ all\ stimuli} where should be no stimuli-drawing code anywhere else and no code that does something else!

\hypertarget{write-your-code-one-teeny-tiny-step-a-time}{%
\subsection{Write your code one teeny-tiny step a time}\label{write-your-code-one-teeny-tiny-step-a-time}}

Your motto should be ``slow but steady''. This is the way I will guide you through the games. Always start with a something extremely simple like a static rectangle or image. Make sure it works. Add a minor functionality: Change in color, position, another rectangle, storing it as an attribute, etc. Make sure it works. Never go to the next step unless you fully understand what your current code is doing and you are 100\% certain\footnote{Seriously, 100\%! If you have even a shadow of a doubt, check again. That shadow will grow and make you progressively uncertain about your code.} that it behaves as it should. This tortoise-speed approach may feel silly and overly slow but it is still faster than writing a large chunk of code and then trying to make it work. It is much easier to solve simple problems one at a time than a lot of them simultaneously.

\hypertarget{there-is-nothing-wrong-with-stackoverflow}{%
\subsection{There is nothing wrong with StackOverflow}\label{there-is-nothing-wrong-with-stackoverflow}}

Yes, you can always try to find a solution to your problem on StackOverflow\footnote{However, if you are doing the seminar, ask me first!}. I do it all the time! However, you should use the provided solution \emph{only if you understand it}! Do not copy-paste the code that \emph{seems} to solve a problem like yours. If you do that and you are lucky, it might work. Or, again if you are lucky, it won't work in an obvious manner. But if you are not so lucky, it will (sometimes) work incorrectly in a subtle way. And, since you did not really know what the code was doing when you pasted it, you will be even more confused. So use StackOverflow as a source of knowledge, not as a source of copy-pastable code!

\hypertarget{reading-tips}{%
\section{Reading the code}\label{reading-tips}}

Reading code is easy because computers are dumb and you are smart. This means that instructions you give the computer must necessarily be very simple and, therefore, are very easy to understand for a human. Unfortunately, reading code is also hard because computers are dumb and you are smart. Your are so smart that you don't even need to read the entire code to understand what it is doing, you just read the key bits and fill in the gaps. Unfortunately, this means that you will tend to read over mistakes. This is not unique to programming, if you ever proofraed a text, you now how hard it is to find tipos. Your brain corrects them on the fly using the context and you read the word as it should be, not as it is actually written\footnote{Tip: Read your text one sentence at a time starting from the back or read one random sentence at a time. This breaks the flow of the text and helps you concentrate on words rather than on the meaning and the story.}.

My experience with programming in general and on this seminar in particular is that most problems you get stuck with are simple to the point of being dumb and obvious in retrospect\footnote{Hindsight is always 20/20!}. Do not despair! It is not you, but just a consequence of how wonderfully your brain is wired for pattern-recognition. Below are several suggestions that could help you to make reading code more robust.

\hypertarget{think-like-a-computer}{%
\subsection{Think like a computer}\label{think-like-a-computer}}

Read the code line-by-line and ``execute'' it the way the compute would. Use pen-and-paper to keep the track of variables. Trace which chunks of code can be reached and when. Slow yourself down and make sure you understand each line and are able to keep track of the variables. Once you do that it will be easy to spot a mistake.

\hypertarget{pretend-that-youve-never-seen-this-code-in-your-life}{%
\subsection{Pretend that you've never seen this code in your life}\label{pretend-that-youve-never-seen-this-code-in-your-life}}

Assume that you have no idea what the code is doing. As I wrote, quite often you \emph{literally} do not see a mistake because your brain fills-in details and bends the reality to match your expectations\footnote{Recently, I spent half-an-hour trying to understand why two identical chunks of code give me different results. My son almost instantly found a difference (a missing comma in of the them) because for him it was just bunch of letters and numbers.}. You \emph{know} what this chunk of code should be doing, so instead of reading it you skim through it and, unless it looks obviously terribly wrong, assume that it does what it should. Turning your expectations off is hard but is immensely helpful.

\hypertarget{do-not-search-only-under-the-street-lamp}{%
\subsection{Do not search only under the street lamp}\label{do-not-search-only-under-the-street-lamp}}

Whenever you are using some new code or need to implement something that feels complicated and your code does not work as it should, you will tend to assume that a problem is with the new fancy code. Simply because it is new, fancy, and complicated. But, in my experience, the error will typically hide in plain sight in the simpler ``trivial'' code nearby which you never properly look at, because it is simple and trivial. Check everything, not just the places where you would expect to have made a mistake.

\hypertarget{use-the-debugger}{%
\subsection{Use the debugger}\label{use-the-debugger}}

In the book, you will learn how to pause an execution of your game, so you can investigate its state. Use this knowledge! Put breakpoints and execute the code step-by-step. Check values of variables using ``Watch'' tab. Use debug console to check whether functions return results that they should. For complex conditions or mathematical formulas, split them into small bits, copy and execute these bits in the debug console and check whether numbers add up. Make sure that a code chunk checks out and then proceed to analyze the next one. Debugging is particularly helpful to identify the code that is not reached or reached at the wrong moment.

\hypertarget{zen-of-python}{%
\section{Zen of Python}\label{zen-of-python}}

I found \href{https://www.python.org/dev/peps/pep-0020/}{Zen of Python} to be good inspiration on how to approach programming.

\hypertarget{python-basics}{%
\chapter{Python basics}\label{python-basics}}

Hopefully, you already \protect\hyperlink{files-folder}{created a special folder} for this book. Download the \href{notebooks/Basics.ipynb}{exercise notebook} (Alt+Click should download rather than open it), put it in a chapter's folder, and open it (see \protect\hyperlink{jupyter-notebooks}{relevant instructions}. You will need to switch between explanations here and the exercises in the notebook, so keep them both open.

\hypertarget{chapter-concepts}{%
\section{Chapter concepts}\label{chapter-concepts}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{variables}{Variables}.
\item
  \protect\hyperlink{constants}{Constants}.
\item
  Basic \protect\hyperlink{value-types}{value types}.
\item
  \protect\hyperlink{print}{Printing} things out.
\item
  Putting values \protect\hyperlink{string-formatting}{into strings}.
\end{itemize}

\hypertarget{variables}{%
\section{Variables}\label{variables}}

The first fundamental concept that we need to be acquainted with is \textbf{variable}. Variables are used to store information and you can think of it as a box with a name tag, so that you can put something into it. The name tag on that box is the name of the variable and its value what you store in it. For example, we can create a variable that stores the number of legs that a game character has. We begin with a number typical for a human being.

\begin{center}\includegraphics[width=0.5\linewidth]{images/variable-as-box} \end{center}

In Python, you would write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

The \textbf{assignment statement} above has very simple structure:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\textless{}}\NormalTok{variable}\OperatorTok{{-}}\NormalTok{name}\OperatorTok{\textgreater{}} \OperatorTok{=} \OperatorTok{\textless{}}\NormalTok{value}\OperatorTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Variable name (name tag on the box) should be meaningful, it can start with letters or \_ and can contain letters, numbers, and \_ symbol but not spaces, tabs, special characters, etc. Python recommends (well, actually, \href{https://www.python.org/dev/peps/pep-0008/}{insists}) that you use \textbf{snake\_case} (all lower-case, underscore for spaces) to format your variable names. The \texttt{\textless{}value\textgreater{}} on the right side is a more complex story, as it can be hard-coded (as in example above), computed using other variables or the same variable, returned by a function, etc.

Using variables means that you can concentrate what corresponding values \textbf{mean} rather than worrying about what these values are. For example, the next time you need to compute something based on number of character's legs (e.g., how many pairs of shoes does a character need), you can compute it based on current value of \texttt{number\_of\_legs} variable rather than assume that it is \texttt{1}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# BAD: why 1? Is it because the character has two legs or}
\CommentTok{\# because we issue one pair of shoes per character irrespective of}
\CommentTok{\# their actual number of legs?}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=} \DecValTok{1}

\CommentTok{\# BETTER (but what if our character has only one leg?)}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=}\NormalTok{ number\_of\_legs }\OperatorTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

Variables also give you flexibility. Their values can change during the program run: player's score is increasing, number of lives decreasing, number of spells it can cast grows or falls depending on their use, etc. Yet, you can always use the value in the variable to perform necessary computations. For example, here is a slightly extended \texttt{number\_of\_shoes} example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}

\CommentTok{\# ...}
\CommentTok{\# something happens and our character is turned into an octopus}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{8}
\CommentTok{\# ...}

\CommentTok{\# the same code still works and we still can compute the correct number of pairs of shoes}
\NormalTok{pairs\_of\_shoes }\OperatorTok{=}\NormalTok{ number\_of\_legs }\OperatorTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

As noted above, you can think about a variable as a labeled box you can store something in. That means that you can always ``throw away'' the old value and put something new. In case of variables, the ``throwing away'' part happens automatically, as a new value overwrites the old one. Check yourself, what will be final value of the variable in the code below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{5}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{1}
\NormalTok{number\_of\_legs}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

Note that a variable (``a box with a name tag'') exists only after you assign something to it. So, the following code will generate a \texttt{NameError}, a Python's way to tell that you it never heard of variable \texttt{number\_of\_hands}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2}
\NormalTok{number\_of\_gloves }\OperatorTok{=}\NormalTok{ number\_of\_hands }\OperatorTok{/} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

However, you can create a variable the does not hold any \emph{specific} value by assigning \texttt{None} to it. \texttt{None} was added to the language specifically to mean \emph{no value} or \emph{nothing}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_hands }\OperatorTok{=} \VariableTok{None} \CommentTok{\# variable exists now, but holds no particular value.}
\end{Highlighting}
\end{Shaded}

As you have already seen, you can \emph{compute} a value instead of specifying it. What would be the answer here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{2} \OperatorTok{*} \DecValTok{2}
\NormalTok{number\_of\_legs }\OperatorTok{=} \DecValTok{7} \OperatorTok{{-}} \DecValTok{2}
\NormalTok{number\_of\_legs}
\end{Highlighting}
\end{Shaded}

Do exercise \#2.

\hypertarget{assignments-are-not-equations}{%
\section{Assignments are not equations!}\label{assignments-are-not-equations}}

\textbf{Very important}: although assignments \emph{look} like mathematical equations, they are \textbf{not equations!} They follow a \textbf{very important} rule that you must keep in mind when understanding assignments: the right side of an expression is evaluated \emph{first} until the final value is computed, then and only then that final value is assigned to the variable specified on the left side (put in the box). What this means is that you can use the same variable on \emph{both} sides! Let's take a look at this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2}
\NormalTok{y }\OperatorTok{=} \DecValTok{5}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{{-}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

What happens when computer evaluates the last line? First, it takes \emph{current} values of all variables (\texttt{2} for \texttt{x} and \texttt{5} for \texttt{y}) and puts them into the expression. After that internal step, the expression looks like

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{2} \OperatorTok{+} \DecValTok{5} \OperatorTok{{-}} \DecValTok{4}
\end{Highlighting}
\end{Shaded}

Then, it computes the expression on the right side and, \textbf{once the computation is completed}, stores that new value in \texttt{x}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \DecValTok{3}
\end{Highlighting}
\end{Shaded}

Do exercise \#3 to make sure you understand this.

\hypertarget{constants}{%
\section{Constants}\label{constants}}

Although the real power of variables is that you can change their value, you should use them even if the value remains constant throughout the program. There are no true constants in Python, rather an agreement that their names should be all \texttt{UPPER\_CASE}. Accordingly, when you see \texttt{SUCH\_A\_VARIABLE} you know that you should not change its value. Technically, this is just a recommendation, as no one can stop you from modifying value of a \texttt{CONSTANT}. However, much of Python's ease-of-use comes from such agreements (such as a \texttt{snake\_case} convention above). We will encounter more of such agreements later, for example, when learning about objects.

Taking all this into account, if number of legs stays constant throughout the game, you should highlight that constancy and write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NUMBER\_OF\_LEGS }\OperatorTok{=} \DecValTok{2}
\end{Highlighting}
\end{Shaded}

I strongly recommend using constants and avoid hardcoding values. First, if you have several identical values that mean different things (2 legs, 2 eyes, 2 ears, 2 vehicles per character, etc.), seeing a \texttt{2} in the code will not tell you what does this \texttt{2} mean (the legs? the ears? the score multiplier?). You can, of course, figure it out based on the code that uses this number but you could spare yourself that extra effort and use a properly named constant instead. Then, you just read its name and the meaning of the value becomes apparent and it is the meaning not the actual value that you are mostly interested in. Second, if you decide to permanently \emph{change} that value (say, our main character is now a tripod), when using a constant means you have only one place to worry about, the rest of the code stays as is. If you hard-coded that number, you are in for an exciting\footnote{not really} and definitely long search-and-replace throughout the entire code.

Do exercise \#4.

\hypertarget{value-types}{%
\section{Value types}\label{value-types}}

So far, we only used integer numeric values (1, 2, 5, 1000\ldots). Although, Python supports \href{https://docs.python.org/3/library/stdtypes.html}{many different value types}, at first we will concentrate on a small subset of them:

\begin{itemize}
\tightlist
\item
  integer numbers, we already used, e.g.~\texttt{-1}, \texttt{100000}, \texttt{42}.
\item
  float numbers that can take any real value, e.g.~\texttt{42.0}, \texttt{3.14159265359}, \texttt{2.71828}.
\item
  strings that can store text. The text is enclosed between either paired quotes \texttt{"some\ text"} or apostrophes \texttt{\textquotesingle{}some\ text\textquotesingle{}}. This means that you can use quotes or apostrophes inside the string, as long as its is enclosed by the alternative. E.g., \texttt{"students\textquotesingle{}\ homework"} (enclosed in \texttt{"}, apostrophe \texttt{\textquotesingle{}} inside) or \texttt{\textquotesingle{}"All\ generalizations\ are\ false,\ including\ this\ one."\ Mark\ Twain\textquotesingle{}} (quotation enclosed by apostrophes). There is much much more to strings and we will cover that material throughout the course.
\item
  logical / Boolean values that are either \texttt{True} or \texttt{False}.
\end{itemize}

When using a variable it is important that you know what type of value it stores and this is mostly on you. In some cases, Python will raise an error, if you try doing a computation using incompatible value types. In other cases, Python will automatically convert values between certain types, e.g.~any integer value is also a real value, so conversion from \texttt{1} to \texttt{1.0} is mostly trivial and automatic. However, in other cases you may need to use explicit conversion. Go to exercise \#5 and try guessing which code will run and which will throw an error due to incompatible types?

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{+} \FloatTok{2.0}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \DecValTok{2}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \StringTok{\textquotesingle{}2\textquotesingle{}}
\CommentTok{\textquotesingle{}5\textquotesingle{}} \OperatorTok{+} \VariableTok{True}
\DecValTok{5} \OperatorTok{+} \VariableTok{True}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

Surprised by the last one? This is because internally, \texttt{True} is also \texttt{1} and \texttt{False} is \texttt{0}!

You can explicitly convert from one type to another using special functions. For example, to turn a number or a logical value into a string, you simply write \href{https://docs.python.org/3/library/functions.html\#func-str}{str(\textless value\textgreater)}. In examples below, what would be the result?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{str}\NormalTok{(}\DecValTok{10} \OperatorTok{/} \DecValTok{2}\NormalTok{)}
\BuiltInTok{str}\NormalTok{(}\FloatTok{2.5} \OperatorTok{+} \VariableTok{True}\NormalTok{)}
\BuiltInTok{str}\NormalTok{(}\VariableTok{True}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#6.

Similarly, you can convert to a logical/Boolean variable using \href{https://docs.python.org/3/library/functions.html\#bool}{bool(\textless value\textgreater)} function. The rules are simple, for numeric values \texttt{0} is \texttt{False}, any other non-zero value is converted to \texttt{True}. For string, an empty string \texttt{\textquotesingle{}\textquotesingle{}} is evaluated to \texttt{False} and non-empty string is converted to \texttt{True}. What would be the output in the examples below?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{bool}\NormalTok{(}\OperatorTok{{-}}\DecValTok{10}\NormalTok{)}
\BuiltInTok{bool}\NormalTok{(}\FloatTok{0.0}\NormalTok{)}

\NormalTok{secret\_message }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}
\BuiltInTok{bool}\NormalTok{(secret\_message)}

\BuiltInTok{bool}\NormalTok{(}\StringTok{\textquotesingle{}False\textquotesingle{}}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#7.

Converting to integer or float numbers using, respectively, \href{https://docs.python.org/3/library/functions.html\#int}{int(\textless value\textgreater)} and \href{https://docs.python.org/3/library/functions.html\#float}{float(\textless value\textgreater)} is trickier. The simplest case is from logical to integer/float, as \texttt{True} gives you \texttt{int(True)} is \texttt{1} and \texttt{float(True)} is \texttt{1.0} and \texttt{False} gives you \texttt{0}/\texttt{0.0}. When converting from float to integer, Python simply drops the fractional part (it does not do proper rounding!). When converting a string, it must be a valid number of the corresponding type or the error is generated. E.g., you can convert a string like \texttt{"123"} to an integer or a float but this won't work for \texttt{"a123"}. Moreover, you can convert \texttt{"123.4"} to floating-point number but not to an integer, as it has fractional part in it. Given all this, which cells would work and what output would they produce?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{float}\NormalTok{(}\VariableTok{False}\NormalTok{)}
\BuiltInTok{int}\NormalTok{(}\OperatorTok{{-}}\FloatTok{3.3}\NormalTok{)}
\BuiltInTok{float}\NormalTok{(}\StringTok{"67.8"}\NormalTok{)}
\BuiltInTok{int}\NormalTok{(}\StringTok{"123+3"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#8.

\hypertarget{print}{%
\section{Printing output}\label{print}}

To print the value, you need to use \href{https://docs.python.org/3/library/functions.html\#print}{print()} function (we will talk about functions in general later). In the simplest case, you pass the value and it will be printed out.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{\#\textgreater{} 5}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"five"}\NormalTok{)}
\CommentTok{\#\textgreater{} five}
\end{Highlighting}
\end{Shaded}

Of course, you already know about the variables, so rather than putting a value directly, you can pass a variable instead and its \emph{value} will be printed out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number\_of\_pancakes }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(number\_of\_pancakes)}
\CommentTok{\#\textgreater{} 10}
\end{Highlighting}
\end{Shaded}

or

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breakfast }\OperatorTok{=} \StringTok{"pancakes"}
\BuiltInTok{print}\NormalTok{(breakfast)}
\CommentTok{\#\textgreater{} pancakes}
\end{Highlighting}
\end{Shaded}

You can also pass more than one value/variable to the print function and all values will be printed one after another. For example, if we want to tell the user what did I had for breakfast, we can do

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{breakfast }\OperatorTok{=} \StringTok{"pancakes"}
\NormalTok{number\_of\_items }\OperatorTok{=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(breakfast, number\_of\_items)}
\CommentTok{\#\textgreater{} pancakes 10}
\end{Highlighting}
\end{Shaded}

What will be printed by the code below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dinner }\OperatorTok{=} \StringTok{"steak"}
\NormalTok{count }\OperatorTok{=} \DecValTok{4}
\NormalTok{desert }\OperatorTok{=} \StringTok{"cupcakes"}

\BuiltInTok{print}\NormalTok{(count, dinner, count, desert)}
\end{Highlighting}
\end{Shaded}

Do exercise \#9.

However, you probably would want to be more explicit, when you print out the information. For example, imagine you have these three variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meal }\OperatorTok{=} \StringTok{"breakfast"}
\NormalTok{dish }\OperatorTok{=} \StringTok{"pancakes"}
\NormalTok{count }\OperatorTok{=} \DecValTok{10}
\end{Highlighting}
\end{Shaded}

You could, of course do \texttt{print(meal,\ dish,\ count)} but it would be nicer to print ``\emph{I had \textbf{10 pancakes} for \textbf{breakfast}}'', where items in bold would be the inserted variables' values. For this, we need to use string formatting. Please note that the string formatting is not specific to printing, you can create a new string value via formatting and store it in a variable without printing it out or print it out without storing it.

\hypertarget{string-formatting}{%
\section{String formatting}\label{string-formatting}}

A great resource on string formatting in Python is \href{https://pyformat.info/}{pyformat.info}. As Python constantly evolves, it now has more than one way to format strings. Below, I will introduce the ``old'' format that is based on classic string formatting used in \texttt{sprintf} function in C, Matlab, R, and many other programming languages. It is somewhat less flexible than newer ones but for simple tasks the difference is negligible. Knowing the old format is useful because of its generality. If you want to learn alternatives, read at the link above.

The general call is \texttt{"a\ string\ with\ formatting"\%(tuple\ of\ values\ to\ be\ used\ during\ formatting)}. You will learn about tuples later. For now, assume that it is just a comma-separated list of values enclosed in round brackets: \texttt{(1,\ 2,\ 3)}.

In \texttt{"a\ string\ with\ formatting"}, you specify where you want to put the value via \texttt{\%} symbol that is followed by an \emph{optional} formatting info and the \emph{required} symbol that defines the \textbf{type} of the value. The type symbols are

\begin{itemize}
\tightlist
\item
  \texttt{s} for string
\item
  \texttt{d} for an integer
\item
  \texttt{f} for a float value
\item
  \texttt{g} for an ``optimally'' printed float value, so that scientific notation is used for large values (\emph{e.g.}, \texttt{10e5} instead of \texttt{100000}).
\end{itemize}

Here is an example of formatting a string using an integer:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"I had }\SpecialCharTok{\%d}\StringTok{ pancakes for breakfast"}\OperatorTok{\%}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\CommentTok{\#\textgreater{} I had 10 pancakes for breakfast}
\end{Highlighting}
\end{Shaded}

You are not limited to a single value that you can put into a string. You can specify more locations via \texttt{\%} but you must make sure that you pass the right number of values in the right order. Before running it, can you figure out which call will actually work (and what will be the output) and which will produce an error?

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and either }\SpecialCharTok{\%d}\StringTok{  or }\SpecialCharTok{\%d}\StringTok{ steaks for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and }\SpecialCharTok{\%d}\StringTok{ steaks for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}I had }\SpecialCharTok{\%d}\StringTok{ pancakes and }\SpecialCharTok{\%d}\StringTok{ steaks for dinner\textquotesingle{}}\OperatorTok{\%}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Do exercise \#10.

As noted above, in case of real values you have two options: \texttt{\%f} and \texttt{\%g}. The latter uses scientific notation (e.g.~\texttt{1e10} for \texttt{10000000000}) to make a representation more compact.

Do exercise \#11 to get a better feeling for the difference.

These is much more to formatting and you can read about it at \href{https://pyformat.info/}{pyformat.info}. However, these basics are sufficient for us to start programming our first game in the next chapter.

\hypertarget{guess-the-number-single-round}{%
\chapter{Guess the Number: a single round edition}\label{guess-the-number-single-round}}

The previous chapter covered Python basics, so now you are ready to start developing you first game! We will build it step by step as there will be a lot to learn about input, libraries, conditional statements, and indentation.

Before you start, create a new folder (inside your \protect\hyperlink{files-folder}{course folder}) called, for example, ``guess-the-number'', download \href{notebooks/Guess\%20the\%20number\%20-\%20single\%20round.ipynb}{exercise notebook}, copy it in the newly created folder, and open it in \protect\hyperlink{jupyter-notebooks}{Jupyter Notebook}. As in the chapter before, it will contain exercises on reading and understanding the code.

However, we will be using \protect\hyperlink{install-vs-code}{VS Code} to program scripts with the actual game. You will need to create a separate file for each code practice\footnote{You can ``Save as\ldots{}'' the previous code to avoid copy-pasting things by hand.} (e.g., \emph{code01.py}\footnote{I recommend using \texttt{01} instead of \texttt{1}, as it will ensure consistent file sorting in your file manager}, \emph{code02.py}, etc.) This is not the most efficient implementation of a version control and it will certainly clutter the folder. But it would allow me to see your solutions for every step, which will make it easier for me to give feedback. For submitting the assignment, just zip the folder and submit the zip-file.

\hypertarget{chapter-concepts-1}{%
\section{Chapter concepts}\label{chapter-concepts-1}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{documenting-your-code}{Documenting code}.
\item
  \protect\hyperlink{debugging}{Debugging code}.
\item
  Getting \protect\hyperlink{input-function}{input} from a user.
\item
  Using \protect\hyperlink{comparisons}{comparison} in \protect\hyperlink{if-statement}{conditional statements}.
\item
  Using \protect\hyperlink{indentation}{indentation} to group statements together.
\item
  Using Python \protect\hyperlink{using-libraries}{libraries}.
\item
  Generating \protect\hyperlink{picking-a-number-randomly}{random numbers}.
\end{itemize}

\hypertarget{the-game}{%
\section{The Game}\label{the-game}}

We will program a game in which one participant (computer) picks a number within a certain range (say, between 1 and 10) and the other participant (human player) is trying to guess it. After every guess of the human, the computer responds whether the actual number is lower than a guess, higher than a guess, or matches it. The game is over when the player correctly guesses the number or (in the later version of the game) runs out of attempts.

Our first version will allow just one attempt and the overall game algorithm will look like this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  computer generates a random number between 1 and 10
\item
  prints it out for debugging purposes
\item
  prompts user to enter a guess
\item
  compares two numbers and print outs the outcome: ``My number is lower'', ``My number is higher'', or ``Spot on!''
\end{enumerate}

\hypertarget{lets-pick-a-number}{%
\section{Let's pick a number}\label{lets-pick-a-number}}

Let us start by implementing just the first two steps of the program. First, create a variable holding a number that computer ``picked''. We will name it \texttt{number\_picked} (you can use some other meaningful name as well but it might be easier if we all stick to the same name). To make things simpler at the beginning, we will hard-code an arbitrary number between 1 and 10 (pick the one you like). Then, let us print it out, so that we know the number ourselves\footnote{Of course, we know it because we hard-coded it. But that won't be the case when computer will generate it randomly, so let us plan for the future}. Use string formatting to make things user-friendly, e.g., print out something like ``The number I've picked is \ldots{}''. You should be able to do this using the knowledge from the previous chapter. Your code should be a two-liner:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1. create variable and set its value}
\CommentTok{\# 2. print out the value}
\end{Highlighting}
\end{Shaded}

Try out this two-liner in a Jupyter Notebook (create an empty notebook just for that). Once you are happy with it, copy-paste the code into \texttt{code01.py} and read on to learn how to run it.

Put your code into \texttt{code01.py}.

\hypertarget{documenting-your-code}{%
\section{Documenting your code}\label{documenting-your-code}}

Now that you have your first file with Python program, you should document it. Documenting a two-lines long and simple program may feel silly but it should be an automatic thing. Later on you will find yourself using several lines of comments to document a single line function. Again, it is not about the code that works, it is about the code you can understand. In a sense, it is better to have a clean well-documented program that currently does not work correctly than an undocumented spaghetti code that does. You can fix and update the former, but maintaining or updating the latter\ldots{}

In Python, you have two ways to write comments multiline and single line

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\CommentTok{A }
\CommentTok{multiline }
\CommentTok{comment}
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}

\CommentTok{\#  A single line comment.}
\end{Highlighting}
\end{Shaded}

Use multiline comments to write documentation for individual files, functions, classes, methods, etc. You will learn how to format this documentation Numpy docstring style, once you learn about functions. In our case, you should start your \texttt{code01.py} file with a multiline comment that briefly describes what program it contains. Minimally, you should write that this is a \emph{Guess a Number} game. It is probably a good idea to sketch out what the game is about.

Use single line comments to explain what happens in a particular code block. You do not need to comment every line and you should not explain the code in human language. A comment should be about \emph{what} is going on not \emph{how}. At the moment, we have too little code to need this.

Document \texttt{code01.py} file.

\hypertarget{debugging}{%
\section{Running and debugging your game in VS Code}\label{debugging}}

Now that we have a two-lines-long program, we can run it and already start learning how to debug it. Yes, our current program is probably to simple to require actual debugging but it is also simple enough to make understanding debugging easier as well. And debugging is a crucial skill that turns a running program from a black box into something transparent and easy\footnote{Or, at least, easier.} to understand. Below I will describe how to debug in VS Code but you might want to consult \href{https://code.visualstudio.com/docs/python/debugging}{an official manual} in case things have changed in the meantime.

There are two ways to run a Python program in VS Code. First, you can use the \emph{``Run Python File in Terminal''} play button on the right. This runs your program \emph{without} a debugger, so you should use it only for the actual runs of the finalized code. Still, you can try running it and see whether it prints out what it should.

\begin{figure}
\centering
\includegraphics{images/debug-vs-run.png}
\caption{Running code without a debugger.}
\end{figure}

The alternative is the debugging tab, the one with a little bug on top of the run button. If you select it, it will show \emph{``Run and Debug''}. Click on the button and it will offer various choices for different kinds of Python projects and frameworks. For our intents and purposes, we will only need \emph{``Python File: Debug the currently active Python file''}. Click on that and it will execute your code (should run exactly the same way as with the other button).

\begin{figure}
\centering
\includegraphics{images/debug-select-debug-configuration.png}
\caption{Selecting debugging configuration.}
\end{figure}

You probably do not want to click through Debugging tab → Run and Debug button → Pick configuration all the time. A better way is to configure it once and for all and then use \textbf{F5} key to run your code. First, click on \emph{``create a launch.json file''} and select the \emph{``Python File: Debug the currently active Python file''} again. You will see a new \emph{launch.json} file appearing in the editor that should look like this:

\begin{figure}
\centering
\includegraphics{images/debug-launch-json.png}
\caption{Debug configuration in launch.json file.}
\end{figure}

That's it! VS Code created a configuration for you. Now you can close \emph{launch.json} file and run your program with a simple press of \textbf{F5} button. Try it! Again, it should work just like before, so why did we go through all this trouble? Because debugger will \emph{pause} an execution of your code whenever it encounters a problem, giving you a chance to examine variables, run snippets of code, etc. In contrast, running python file in terminal (the first option) will only print an error message and exit the program. Moreover, you can use \emph{breakpoints} to pause the program at any line, which gives you an opportunity to examine your code at any location that you need.

You enable breakpoints by clicking to the left of the line number that you are interested in. Here, I've clicked on line 6 and you can see a red dot that indicates an active breakpoint.

\begin{figure}
\centering
\includegraphics{images/debug-breakpoint.png}
\caption{Active breakpoint.}
\end{figure}

If I now run the code via \textbf{F5}, the program will stop at that line \emph{before} executing it.

\begin{figure}
\centering
\includegraphics{images/debug-pause.png}
\caption{Program paused at the breakpoint.}
\end{figure}

This gives me a chance to see what value my \texttt{number\_picked} variable has. It is already listed in local variables (top left). But I also added it to list of watched variables (\emph{Watch}, lift middle) and I also looked at its value in the \emph{Debug Console} (bottom tab) that allows me to execute \emph{any} Python code while my program is paused. Do the same and explore these different ways yourself. For example, see how you can compute \texttt{number\_picked\ +\ 1} or \texttt{number\_picked\ *\ number\_picked} in the \emph{Watch} tab and in \emph{Debug Console}.

Once you are done examining the current state of the program, you have six buttons at the top to decide what to do next (hover over them to see hints). They are, from left to right

\begin{itemize}
\tightlist
\item
  Continue (\textbf{F5}): resume the program.
\item
  Step Over (\textbf{F10}): executes the code without going into functions (this and two following options will become clearer once you learn about writing functions).
\item
  Step Into the code (\textbf{F11})
\item
  Step Out of the code (\textbf{Shift+F11}).
\item
  Restart the program (\textbf{Ctrl+Shift+F5}).
\item
  Stop the program (\textbf{Shift+F5}).
\end{itemize}

To better understand how this works, stop the program (\textbf{Shift+F5}) and put an additional breakpoint on the first line of your code (line \#5 in my program, the other lines are comments or are empty). Run the program again via \textbf{F5} and it will pause at that very first line. Can you figure out the value of variable \texttt{number\_picked} now?

The answer is ``no'' because that variable does not exist yet. Remember, the program pauses \emph{before} executing the line. Use \textbf{F10} to step through the code line by line to see how the variable appears and the information gets printed out.

This debugging exercise may not have been necessary to solve problems with your current code but it showed how to do that in the future. Do not hesitate to put a breakpoint to pause the program and check that reality (i.e., actual values of variables) matches your expectations. Use the stepping through the code to slow things down to watch and ponder.

\hypertarget{input-function}{%
\section{Asking a player for a guess}\label{input-function}}

It takes two to play the \emph{Guess the Number} game. The computer did its part by picking a number, now we need to ask a player to enter their guess. For this, we will use \href{https://docs.python.org/3/library/functions.html\#input}{input()} \emph{function}.

A function is an isolated code that accepts (optional) \emph{inputs}, performs an \emph{action}, and, optionally, returns a value (\emph{output}). This allows both to split the code into smaller chunks that are easier to maintain and to reuse the same code. You already used \href{https://docs.python.org/3/library/functions.html\#print}{print()} function to print things out, and \href{https://docs.python.org/3/library/functions.html\#func-str}{str()}, \href{https://docs.python.org/3/library/functions.html\#bool}{bool()}, \href{https://docs.python.org/3/library/functions.html\#int}{int()} and \href{https://docs.python.org/3/library/functions.html\#float}{float()} functions to convert values. For \href{https://docs.python.org/3/library/functions.html\#print}{print()} \emph{input} is an arbitrary number of values (even none, try this in Jupiter Notebook!), its \emph{action} is to print things out, but it returns nothing (no \emph{output}). \href{https://docs.python.org/3/library/functions.html\#float}{float()} function takes (somewhat surprisingly) zero or one value as \emph{input} (try giving it none or more than one in Jupiter Notebook as see the difference), attempts to convert given value to float (throwing an error, if it cannot do it), and returns a float value as an \emph{output}.

Similar \emph{input} → \emph{action} → \emph{output} scheme holds for the \href{https://docs.python.org/3/library/functions.html\#input}{input(prompt)}. It takes an optional \texttt{prompt} string as input. Then it prints the \texttt{prompt} message and waits for a user to enter a \emph{string} until they press \textbf{Enter}. It then returns this \emph{string} value. The latter bit about \emph{string} is important, because in our game we need a player to enter an \emph{integer} not a string. For a moment, let us assume that the input is always a valid integer number, so type only valid integers when testing the program! This way we can convert it to an integer without extra checks (will add them in the future) and assign this value to a new variable called \texttt{guess}. Thus, you need to add a single line assignment statement with \texttt{guess} variable on the left side and call to \href{https://docs.python.org/3/library/functions.html\#input}{input()} function on the right side (think of a nice prompt message) wrapped by (inside of) the type-conversion to integer via \href{https://docs.python.org/3/library/functions.html\#int}{int()}. Test this code but, again, only enter valid integers, so that the conversion works without an error.

Update your \texttt{code01.py}.

\hypertarget{if-statement}{%
\section{\texorpdfstring{Conditional \emph{if} statement}{Conditional if statement}}\label{if-statement}}

Now we have two numbers: One that computer picked (\texttt{number\_picked}) and one that the has player entered (\texttt{guess}). We need to compare them to provide correct output message. For this, we will use conditional \href{https://docs.python.org/3/tutorial/controlflow.html\#if-statements}{if statement}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
    \CommentTok{\# do something}
\ControlFlowTok{elif}\NormalTok{ some\_other\_condition\_is\_true:}
    \CommentTok{\# do something else}
\ControlFlowTok{elif}\NormalTok{ yet\_another\_condition\_is\_true:}
    \CommentTok{\# do yet something else}
\ControlFlowTok{else}\NormalTok{:}
    \CommentTok{\# do something only if all conditions above are false.}
\end{Highlighting}
\end{Shaded}

Only the \texttt{if} part is required, whereas \texttt{elif} (short for ``else, if'') and \texttt{else} are optional. Thus you can do something, only if a condition is true:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
    \CommentTok{\# do something, but OTHERWISE DO NOT DO ANYTHING }
    \CommentTok{\# and continue with code execution}
  
\CommentTok{\# some code that is executed after the if{-}statement,}
\CommentTok{\# irrespective of whether the condition was true or not.}
\end{Highlighting}
\end{Shaded}

Before we can use conditional statements in our game, you need to understand (1) the conditions themselves and (2) use of indentation as a mean of grouping statements together.

\hypertarget{comparisons}{%
\section{Conditions and comparisons}\label{comparisons}}

Condition is any expression that can be evaluated to see whether it is \texttt{True} or \texttt{False}. A straightforward example of such expression are comparisons expressed in human language as: \emph{Is today Thursday?} \emph{Is the answer (equal to) 42?} \emph{Is it raining and I have an umbrella?} We will concentrate on comparisons like that for a moment but later you will see that in Python \emph{any} expression is either \texttt{True} or \texttt{False}, even when it does not look like a comparison\footnote{This is because you can convert any value to a logical one via \href{https://docs.python.org/3/library/functions.html\#bool}{bool()} function that you learned about the last time and so any value is (converted to) either \texttt{True} or \texttt{False}.}.

For the comparison, you can use the following operators:

\begin{itemize}
\tightlist
\item
  \emph{``A is equal B''} is written as \texttt{A\ ==\ B}.
\item
  \emph{``A is not equal B''} is written as \texttt{A\ !=\ B}.
\item
  \emph{``A is greater than B''} and \emph{``A is smaller than B''} are, respectively, \texttt{A\ \textgreater{}\ B} and \texttt{A\ \textless{}\ B}.
\item
  \emph{``A is greater than or equal to B''} and \emph{``A is smaller than or equal to B''} are, respectively, \texttt{A\ \textgreater{}=\ B} and \texttt{A\ \textless{}=\ B} (please note the order of symbols as \texttt{=\textgreater{}} and \texttt{=\textless{}} will produce an error).
\end{itemize}

Go to exercise \#1 to solve some comparisons.

Note that Python also has an \href{https://docs.python.org/3/library/operator.html\#operator.is_}{is} operator that may \emph{look} identical to \texttt{==} (e.g., \texttt{x\ ==\ 2} looks equivalent to \texttt{x\ is\ 2}). Moreover, in \emph{some} cases it also works the same way. However, there is a subtle difference: \texttt{==} checks whether \emph{values} are identical, whereas \texttt{is} checks whether \emph{objects} (that ``hold'' values) are identical. You need to understand classes and objects before you can appreciate this difference, so for now just keep in mind that you should only use \texttt{==} (I will explicitly mentioned when \texttt{is} is needed).

You can \emph{invert} the logical value using \texttt{not} operator, as \texttt{not\ True} is \texttt{False} and \texttt{not\ False} is \texttt{True}. This means that \texttt{A\ !=\ B} is the same as \texttt{not\ A\ ==\ B} and, correspondingly, \texttt{A\ ==\ B} is \texttt{not\ A\ !=\ B}. To see how that works, consider both cases when \texttt{A} is indeed equal \texttt{B} and when it is not.

\begin{itemize}
\tightlist
\item
  If A is equal B then \texttt{A\ ==\ B} evaluates to \texttt{True}. The \texttt{A\ !=\ B} is then \texttt{False}, so \texttt{not\ A\ !=\ B} → \texttt{not\ False} → \texttt{True}.
\item
  If A is not equal B then \texttt{A\ ==\ B} evaluates to \texttt{False}. The \texttt{A\ !=\ B} is then \texttt{True}, so \texttt{not\ A\ !=\ B} → \texttt{not\ True} → \texttt{False}.
\end{itemize}

Go to exercise \#2 to explore this inversion yourself.

You can also combine several comparisons using \texttt{and} and/or\footnote{pun intended} \texttt{or} operators. As in human language, \texttt{and} means that both parts must be true: \texttt{True\ and\ True} → \texttt{True} but \texttt{True\ and\ False} → \texttt{False}, \texttt{False\ and\ True} → \texttt{False}, and \texttt{False\ and\ False} → \texttt{False}. Same holds if you have more have than two conditions/comparisons linked via \texttt{and}: \textbf{All} of them must be true. In case of \texttt{or} only one of the statements must be true, e.g.~\texttt{True\ or\ True} → \texttt{True}, \texttt{True\ or\ False} → \texttt{True}, \texttt{False\ or\ True} → \texttt{True}, but \texttt{False\ or\ False} → \texttt{False}. Again, for more than two comparisons/conditions at least one of them should be true for the entire expression to be true.

Do exercises \#3 and \#4.

Subtle but important point: conditions are evaluated from left to right until the whole expression is resolved one way or another. This means that if the first expression in a \texttt{and} pair is \texttt{False}, the second one is \textbf{never evaluated}. I.e., if \texttt{first\ and\ second} expressions both need to be \texttt{True} and you know that \texttt{first} expression already is false, the whole expression will be \texttt{False} in any case. This means that in the code below there will be no error, even though evaluating \texttt{int("e123")} alone would raise a \texttt{ValueError}.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{5} \KeywordTok{and} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\end{Highlighting}
\end{Shaded}

However, reverse the order, so that \texttt{int("e123")\ ==\ 123} needs to be evaluated first and you get the error message

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123} \KeywordTok{and} \DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{4}
\CommentTok{\# Generates ValueError: invalid literal for int() with base 10: \textquotesingle{}e123\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Similarly, if \emph{any} expression in \texttt{or} is \texttt{True}, you do not need to check the rest.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{4} \KeywordTok{or} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\end{Highlighting}
\end{Shaded}

However, if the first condition is \texttt{False}, we do need to continue (and stumble into an error):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{*} \DecValTok{2} \OperatorTok{==} \DecValTok{5} \KeywordTok{or} \BuiltInTok{int}\NormalTok{(}\StringTok{"e123"}\NormalTok{) }\OperatorTok{==} \DecValTok{123}
\CommentTok{\# Generates ValueError: invalid literal for int() with base 10: \textquotesingle{}e123\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

Finally, like in simple arithmetic, you can use brackets \texttt{()} to group conditions together. Thus a statement ``I always eat chocolate but I eat spinach only when I am hungry'' can be written as \texttt{food\ ==\ "chocolate"\ or\ (food\ ==\ "spinach"\ and\ hungry)}. Here, \texttt{the\ food\ ==\ "chocolate"} and \texttt{food\ ==\ "spinach"\ and\ hungry} are evaluated independently, their values are substituted in their place and then the \texttt{and} condition is evaluated.

Do exercise \#6.

Final thought on comparisons: Do not hesitate to test them in Jupyter Notebook using various combinations of values or pause the program at the condition via a breakpoint and evaluate a comparison in \emph{Watch} or \emph{Debug Console}.

\hypertarget{indentation}{%
\section{Grouping statements via indentation}\label{indentation}}

Let us go back to a conditional if-statement. Take a look at following code example (and note an \texttt{:} at the end of the \texttt{if\ some\_condition\_is\_true:}), in which \emph{statement \#1} is executed only if \emph{some condition} is true, whereas \emph{statement \#2} is executed after that \emph{irrespective} of the condition.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ some\_condition\_is\_true:}
\NormalTok{    statement }\CommentTok{\#1}
\NormalTok{statement }\CommentTok{\#2 }
\end{Highlighting}
\end{Shaded}

Both statements \#1 and \#2 appear after the if-statement, so how does Python now that the first one is executed only if condition is true but the other one always runs? The answer is indentation: The \textbf{4 (four!) spaces} that are automatically added whenever you press \textbf{Tab} in VS Code and removed whenever you press \textbf{Shift+Tab}. The indentation puts statement \#1 \emph{inside} the if-statement. Thus, indentation shows whether statements belong to the same group and must be executed one after another (same indentation level for \texttt{if} and \texttt{statement\ \#2}) or are inside conditional statement, loop, function, class, etc. (\texttt{statement\ \#1}). For more complex code that will have, for example, an if-statement inside an if-statement inside a loop, you will express this by adding more levels of indentation. E.g.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# some statements outside of the loop (0 indentation)}
\ControlFlowTok{while}\NormalTok{ game\_is\_not\_over: }\CommentTok{\# (0 indentation)}
    \CommentTok{\# statements inside of the loop }
    \ControlFlowTok{if}\NormalTok{ key\_pressed: }\CommentTok{\# (indentation of 4)}
        \CommentTok{\# inside loop and if{-}statement }
        \ControlFlowTok{if}\NormalTok{ key }\OperatorTok{==} \StringTok{"Space"}\NormalTok{: }\CommentTok{\# (indentation of 8)}
            \CommentTok{\# inside the loop, and if{-}statement, and another if{-}statement}
\NormalTok{            jump() }\CommentTok{\# (indentation of 12)}
        \ControlFlowTok{else}\NormalTok{: }\CommentTok{\# (indentation of 4)}
            \CommentTok{\# inside the loop, and if{-}statement, and else part of another if{-}statement}
\NormalTok{            stand() }\CommentTok{\# (indentation of 12)}
    
    \CommentTok{\# statements inside of the loop but outside of the outermost if{-}statement}
    \BuiltInTok{print}\NormalTok{(key) }\CommentTok{\# (indentation of 4)}
    
\CommentTok{\# some statements outside of the loop (0 indentation)}
\end{Highlighting}
\end{Shaded}

Pay very close attention to the indentation as it determines which statements are executed together! A wrong indentation level is unfortunately a very common mistake.

Do exercise \#7.

The \texttt{if} and \texttt{ifelse} statements are evaluated until one of them turns out to be \texttt{True}. After that any following \texttt{ifelse} and \texttt{else} statements are simply ignored.

Do exercise \#8.

\hypertarget{checking-the-answer}{%
\section{Checking the answer}\label{checking-the-answer}}

Now you have all necessary tools to finish the first version of our game. Add a conditional statements to your \texttt{code01.py}, so that

\begin{itemize}
\tightlist
\item
  if the computer pick is smaller than player's guess, it will print \texttt{"My\ number\ is\ lower!"}
\item
  if the computer pick is larger than player's guess, it will print \texttt{"My\ number\ is\ higher!"}
\item
  if two numbers are identical, it will print \texttt{"Spot\ on!"}
\end{itemize}

Update \texttt{code01.py}

Test that your code works. Again, use breakpoints if you need to better understand the control flow and check whether comparisons work the way you expect.

\hypertarget{using-libraries}{%
\section{Using libraries}\label{using-libraries}}

Our game is ``feature-complete'': computer picks a number, player makes a guess, computer responds appropriately. However, currently we are playing for both sides. Lets make computer pick a random number itself. For this we need to use \href{https://docs.python.org/3/library/random.html\#random.randint}{randint(a, b)}. It is a part of any Python distribution, so you would have it even if you would install a vanilla Python distribution instead of using one from PsychoPy. However, you cannot use it straightaway like you did with \texttt{print()} or \texttt{input()}. Type \texttt{randint(1,\ 3)} in your Jupyter Notebook and observe \emph{NameError: name `randint' is not defined}.

The reason for this is that Python has an awful lot of functions and loading them all at the same time would clog the memory with things you never intended to use. Instead, they are packaged into \emph{libraries}, so that you can import only functions (or libraries) that you actually need for your program. You \href{https://docs.python.org/3/reference/import.html}{import} them via an \texttt{import} statement that should go to the top of your file (but below the comment about the file content). There are several ways you can import libraries. First, you can import an \emph{entire} library (such as \emph{random} library that has function \texttt{randint()} that we need) and then use its functions as \texttt{\textless{}library\textgreater{}.\textless{}function\textgreater{}}. For \texttt{randint} this would be

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ random}

\NormalTok{computer\_pick }\OperatorTok{=}\NormalTok{ random.randint(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

I would suggest this as a preferred way of using libraries as it forces you to explicitly mention the name of the library when calling a function, i.e.~\texttt{random.randint()} instead of just \texttt{randint()}. This may not look important with just one imported library but even in a modestly-sized project you will import many libraries, so figuring out which library the function belongs to will be tricky. Even more importantly, different libraries may have functions with \emph{the same name}. In this case, the function you are using will come from the \emph{last} library you imported. But you may not realize this and this is a sort of mistake that is really hard to track down. Thus, unless you have a very good reason to do otherwise, always import the entire library and use \texttt{library.} notation!

Another and less explicit option is to import only \emph{some} functions and use them \emph{without} the \texttt{library.} prefix. You can import more than one function by listing them all

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint, randrange}

\NormalTok{computer\_pick }\OperatorTok{=}\NormalTok{ randint(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can also \emph{rename} a library or a function while importing it via \texttt{as}. In short, you should not do this as using a different name for a library or a function would make it harder for others (and even for future-you) to understand your code. However, there are some ``standard'' renaming patterns that are used universally and which you are likely to encounter.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this is a standard way to import these two libraries}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{np.}\BuiltInTok{abs}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}

\CommentTok{\# you can rename individual functions as well, if you really have to (but, please, don\textquotesingle{}t!)}
\ImportTok{from}\NormalTok{ random }\ImportTok{import}\NormalTok{ randint }\ImportTok{as}\NormalTok{ random\_integer}

\NormalTok{computer\_pick }\OperatorTok{=}\NormalTok{ random\_integer(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Finally, there is a \textbf{very bad way} to import functions from a library: \texttt{from\ random\ import\ *}. The asterisk means that you want to import \emph{all} functions from the library and you want to call them by their names without \texttt{random.} prefix. Never, never, never\footnote{Did I already say never? Never!} do this! This fills your environment with functions that you may not be aware of, potentially overwriting some other functions, creating conflicts, etc. Never ever! I am showing you this only because you will, at some point, see a code that uses this approach and you might think that this is a good idea. It is a terrible idea! Import the library, not the functions, so you can explicitly show which library you are relying on when calling a function. Always remember the \href{https://www.python.org/dev/peps/pep-0020/}{Zen of Python}: ``Explicit is better than implicit.''

\hypertarget{picking-a-number-randomly}{%
\section{Picking a number randomly}\label{picking-a-number-randomly}}

Now that you know how to import a library, we can use \href{https://docs.python.org/3/library/random.html\#random.randint}{randint()} function. For this, save a copy of your original code into \texttt{code02.py}. Import the library and use \href{https://docs.python.org/3/library/random.html\#random.randint}{randint()} to generate a random number between 1 and 10. Read the documentation on \href{https://docs.python.org/3/library/random.html\#random.randint}{randint()} to understand how to use it. Reading manuals is a necessary part of programming, so this is a good point to start practicing.

Once you implemented this in \texttt{code02.py}, run it several times to check that computer does pick different random values. Again, use breakpoints if you want to double-check what is going on.

Put your code into \texttt{code02.py}.

Congratulations, you just programmed your first computer game! Yes, it is very simple but it has key ingredients: a random decision by computer, a user input, and feedback. Next time, you will learn about loops to allow for multiple attempts and will start writing functions to make your code modular and reliable. In the meantime, let us solidify your knowledge by programming yet another game!

\hypertarget{one-armed-bandit-a-single-round-edition}{%
\section{One-armed bandit (a single round edition)}\label{one-armed-bandit-a-single-round-edition}}

You know everything you need to program a simple version of an ``one-armed bandit'' game. Here is the game logic:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Import random library, so you could use \texttt{randint} function
\item
  Generate three random integers (say, between 1 and 5) and store them in three variables \texttt{slot1}, \texttt{slot2}, and \texttt{slot3}.
\item
  Print out the numbers, use string formatting to make it look nice.
\item
  In addition,

  \begin{itemize}
  \tightlist
  \item
    if all three values are the same, print \texttt{"Three\ of\ a\ kind!"}.
  \item
    If only two numbers match, print \texttt{"Pair!"}.
  \item
    Do not print anything, if all numbers are different.
  \end{itemize}
\end{enumerate}

Do not forget to document the new \texttt{code03.py} file and feel free to use breakpoints to debug it.

Put your code into \texttt{code03.py}.

\hypertarget{submitting-for-the-seminar}{%
\section{Submitting for the seminar}\label{submitting-for-the-seminar}}

For the seminar, submit a zipped folder with exercise notebook and all three programs.

\hypertarget{guess-the-number-multi-round}{%
\chapter{Guess the Number: a multi round edition}\label{guess-the-number-multi-round}}

In previous chapter, you programmed a single-attempt-only ``Guess the Number'' game. Now, we will expand to allow multiple attempts and will add other bells-and-whistles to make it more fun. Create a new subfolder and download the \href{notebooks/Guess\%20the\%20number\%20-\%20multi\%20round.ipynb}{exercise notebook} before we start!

\hypertarget{chapter-concepts-2}{%
\section{Chapter concepts}\label{chapter-concepts-2}}

\begin{itemize}
\tightlist
\item
  Repeating code using \protect\hyperlink{while-loop}{while} loop.
\item
  Making in \protect\hyperlink{break}{emergency exit} from a loop.
\end{itemize}

\hypertarget{while-loop}{%
\section{While loop}\label{while-loop}}

If you want to repeat something, you need to use loops. There are two types of loops: \href{https://docs.python.org/3/reference/compound_stmts.html\#the-while-statement}{while} loop, which is repeated \emph{while} a condition is true, and \href{https://docs.python.org/3/reference/compound_stmts.html\#the-for-statement}{for} loop that iterates over items (we will use it later).

The basic structure of a \emph{while} loop is

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# statements before the loop}

\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{condition}\OperatorTok{\textgreater{}}\NormalTok{:}
    \CommentTok{\# statements inside are executed}
    \CommentTok{\# repeatedly for as long as}
    \CommentTok{\# the condition is True}
    
\CommentTok{\# statements after the loop}
\end{Highlighting}
\end{Shaded}

The \texttt{\textless{}condition\textgreater{}} here is any expression that is evaluated to be either \texttt{True} or \texttt{False}, just like in an \texttt{if...elif...else} \protect\hyperlink{comparisons}{conditional statement}. Also, the same \protect\hyperlink{indentation}{indentations rules} determine which code is inside the loop and which outside.

Do exercise \#1.

Let us use \emph{while} loop to allow the player to keep guessing until they finally get it right. You can copy-paste the code you programmed during the last seminar or could redo it from scratch (I would strongly recommend you doing the latter!). The overall program structure should be the following

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import random library so you can use randint function}

\CommentTok{\# generated a random number and store in number\_picked variable}
\CommentTok{\# get player input, convert it to an integer, and store in guess variable}

\CommentTok{\# while players guess is not equal to the value the computer picked:}
    \CommentTok{\# print out "my number is smaller" or "my number is larger" using if{-}else statement}
    \CommentTok{\# get player input, convert it to an integer, and store in guess variable}
    
\CommentTok{\# print "Spot on!" }
\CommentTok{\# (because if we got here that means guess is equal to the computer\textquotesingle{}s pick)}
\end{Highlighting}
\end{Shaded}

Put your code into \texttt{code01.py}.

Do not forget to document the file and use breakpoints and step overs to explore the program flow.

\hypertarget{counting-attempts}{%
\section{Counting attempts}\label{counting-attempts}}

Now let us add a variable that will count a total number of attempts by the player. For this, create a new variable (call it \texttt{attempts} or something similar) \emph{before the loop} and initialize it \texttt{1}. Add \texttt{1} to it every time the player enters a guess. After the loop, expand the \texttt{"Spot\ on!"} message by adding information about the number of attempts. Use \protect\hyperlink{ux5cux23string-formatting}{string formatting} to make things look nice, e.g., \texttt{"Spot\ on,\ and\ you\ needed\ just\ 5\ attempts!"}. Check that the number of attempts your required \emph{matches} the number of attempts reported by the program!

Put your code into \texttt{code02.py}.

\hypertarget{break}{%
\section{Breaking (and exiting)}\label{break}}

Code inside the \emph{while} loop is executed repeatedly while the condition is \texttt{True} and, importantly, all of code inside is executed before the condition is evaluated again. However, sometimes you may need to abort sooner without executing the remaining code. For this, Python has a \href{https://docs.python.org/3/tutorial/controlflow.html\#break-and-continue-statements-and-else-clauses-on-loops}{break} statement that causes the program to exit the loop immediately without executing the rest of the code inside the loop, so that the program continues with the code \emph{after} the loop.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this code runs before the loop}

\ControlFlowTok{while} \OperatorTok{\textless{}}\NormalTok{somecondition}\OperatorTok{\textgreater{}}\NormalTok{:}
  \CommentTok{\# this code runs on every iteration}
  
    \ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{someothercondition}\OperatorTok{\textgreater{}}\NormalTok{:}
        \ControlFlowTok{break}
  
  \CommentTok{\# this code runs on every iteration but not when you break out of the loop}

\CommentTok{\# this code runs after the loop}
\end{Highlighting}
\end{Shaded}

Do exercise \#2 to build your intuition.

\hypertarget{limiting-number-of-attempts-via-break}{%
\section{Limiting number of attempts via break}\label{limiting-number-of-attempts-via-break}}

Let's put the player under some pressure! Decide on maximal number of attempts you allow and stores it as a \protect\hyperlink{constants}{CONSTANT}. Pick an appropriate name (e.g.~\texttt{MAX\_ATTEMPTS}) and REMEMBER, ALL CAPITAL LETTERS for a constant name! Now, use \texttt{break} to quit the \texttt{while} loop, if the current attempt number is greater than \texttt{MAX\_ATTEMPTS}. Think about when (within the code inside the loop) you should check this.

Put your code into \texttt{code03.py}.

\hypertarget{correct-end-of-game-message}{%
\section{Correct end-of-game message}\label{correct-end-of-game-message}}

Let us update the final message. Currently it says ``Spot on\ldots{}'' because we assumed that program exited the loop only if the player gave a correct answer. With limited attempts that is not necessarily the case. Now there are two reasons why it exited the while loop:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The player answered correctly
\item
  The player ran out of attempts.
\end{enumerate}

Use \texttt{if-else} conditional statement to print out an appropriate message. E.g., print \texttt{"Better\ luck\ next\ time!"}, if the player lost (ran out of attempts).

Put your code into \texttt{code04.py}.

\hypertarget{limiting-number-of-attempts-without-a-break}{%
\section{Limiting number of attempts without a break}\label{limiting-number-of-attempts-without-a-break}}

Although it was my idea to add the \texttt{break} statement, you should use it sparingly. Without \texttt{break} there is a \emph{single} place in the code that you need to check to understand when the program will exit the loop: the condition. However, if you add a \texttt{break}, you now have \emph{two} places that need to be examined. And every additional \texttt{break} keeps adding to that. This does not mean that you should avoid them at all costs! You \emph{should} use them, if this makes the code easier to understand. But always check if a modified condition could also do the trick.

Let us try exactly that. Modify your code to work \emph{without} the \texttt{break} statement. You need a more complicated condition for your while loop. so that it repeats while player's guess is incorrect and the number of attempts is still less than the maximally allowed. Test that your code works both when you win and when you lose.

Put your code into \texttt{code05.py}.

\hypertarget{show-remaining-attempts}{%
\section{Show remaining attempts}\label{show-remaining-attempts}}

It is all about a user interface! Modify the \texttt{input} prompt message to include a number of \emph{remaining} attempts. E.g. \texttt{"Please\ enter\ the\ guess,\ you\ have\ X\ attempts\ remaining"}.

Put your code into \texttt{code06.py}.

\hypertarget{guess-the-number-repeat-game}{%
\section{Repeating the game}\label{guess-the-number-repeat-game}}

Let us give an option for the player to play again. This means putting \emph{all} the current code inside of another \texttt{while} loop (this is called \emph{nested loops}) that is repeated for as long as the player wants to keep playing. The code should look as follows:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# import random library so you can use randint function}

\CommentTok{\# define MAX\_ATTEMPTS}

\CommentTok{\# define a variable called "want\_to\_play" and set to True}
\CommentTok{\# while the player still wants to play}
  
  \CommentTok{\# your current working game code goes here}
  
  \CommentTok{\# ask user whether via input function. E.g. "Want to play again? Y/N"}
  \CommentTok{\# want\_to\_play should be True if user input is equal to "Y" or "y"}
  
\CommentTok{\# very final message, e.g. "Thank you for playing the game!"}
\end{Highlighting}
\end{Shaded}

\textbf{Pay extra attention to indentations to group the code properly!}

Put your code into \texttt{code07.py}.

\hypertarget{you-do-not-need-a-comparison-if-you-already-have-the-value}{%
\section{You do not need a comparison, if you already have the value}\label{you-do-not-need-a-comparison-if-you-already-have-the-value}}

In your updated code, you have \texttt{want\_to\_play} variable that is either \texttt{True} or \texttt{False}. It is used in the loop that repeats while its value is \texttt{True}. Sometimes, people write \texttt{want\_to\_play\ ==\ True} to express that. While it is technically correct and will certaintly work correctly, it is also redundant. Since \texttt{want\_to\_play} can only be \texttt{True} or \texttt{False} this comparison turns into \texttt{True\ ==\ True} (which is of course \texttt{True}) or \texttt{False\ ==\ True} (which is \texttt{False}). So comparing either value to \texttt{True} produces exactly the same value. Thus, you can just write \texttt{while\ want\_to\_play:} and use the logical value directly.

\hypertarget{best-score}{%
\section{Best score}\label{best-score}}

A ``proper'' game typically keeps the track of players' performance. Let us record a fewest number of attempts that the player needed to guess the number. For this, create a new variable \texttt{fewest\_attempts} and set it to \texttt{MAX\_ATTEMPTS} (this is as bad as the player can be). Think, where do you need to create it. You should update it after each game round. Add the information about ``Best so far'' into the round-over message.

Put your code into \texttt{code08.py}.

\hypertarget{counting-game-rounds}{%
\section{Counting game rounds}\label{counting-game-rounds}}

Let us count how many rounds the player played. The idea and implementation is the same as with counting the attempts. Create a new variable, initialize it to 0, increment by 1 whenever a new round starts. Include the total number of rounds into the very final message, e.g.~``Thank you for playing the game \emph{X} times!''

Put your code into \texttt{code09.py}.

\hypertarget{wrap-up}{%
\section{Wrap up}\label{wrap-up}}

Most excellent, you now have a proper working computer game with game rounds, limited attempts, best score, and what not! Zip the folder and submit.

\hypertarget{guess-the-number-ai}{%
\chapter{Guess the Number: AI takes a turn}\label{guess-the-number-ai}}

Let us program Guess the Number game again\footnote{This is the last time, I promise!} but \emph{reverse} the roles. Now \emph{you} will pick a number and the computer will guess. Think about the algorithm that a computer could use for this before reading the next paragraph\footnote{You should imagine Dora the Explorer staring at you while you think.}.

The optimal way to do this is to use the middle of the interval for a guess. This way you rule out \emph{half} the numbers that are either greater or smaller than your guess (or you guess the number correctly, of course). So, if you know that the number is between 1 and 10, you should split things in the middle, that is picking 5 or 6, as you cannot pick 5.5 (we assume that you can use only integers). If your opponent tells that their number is greater than your pick, you know that it must be somewhere between your guess and the original upper limit, e.g., between 5 and 10. Conversely, if the opponent responds ``lower'', the number is the lower limit and you guess, e.g., between 1 and 5. On your next attempt, you pick split the interval again until you either guess the number correctly or end up with an interval that contains just one number. Then you do not need to guess anymore.

To implement this program, you will need to learn about functions, how to document them like a pro, and how to use your own libraries. Grab the \href{notebooks/Guess\%20the\%20number\%20-\%20AI.ipynb}{exercise notebook} before we start!

\hypertarget{chapter-concepts.}{%
\section{Chapter concepts.}\label{chapter-concepts.}}

\begin{itemize}
\tightlist
\item
  Writing you own \protect\hyperlink{function}{functions}.
\item
  Understanding variable \protect\hyperlink{scopes-for-immutable-values}{scopes}.
\item
  Adopting \protect\hyperlink{numpy-docstring}{standard ways} to document your code.
\item
  Using your \protect\hyperlink{using-you-own-libraries}{own libraries}.
\end{itemize}

\hypertarget{guess-the-number-players-response}{%
\section{Player's response}\label{guess-the-number-players-response}}

Let us warm up by writing a code that will allow a player to respond to computer's guess. Recall that there are just three options: your number is greater, smaller, or equal to a computer's guess. I would suggest using, respectively, \texttt{\textgreater{}}, \texttt{\textless{}}, and \texttt{=} symbols to communicate this. You need to write the code that will prompt a player for their response until they enter one of these symbols. I.e., the prompt should be repeatedly repeated if they enter anything else. Thus, you definitely need to use the \href{https://docs.python.org/3/library/functions.html\#input}{input({[}prompt{]})} and a \protect\hyperlink{while-loop}{while} loop. Think of a useful and informative prompt message for this. Test that it works. Using breakpoints might be very useful here.

Put your code into \texttt{code01.py}.

\hypertarget{function}{%
\section{Functions}\label{function}}

You already now how to use function, now it is turn for you to learn more about why you should care. The purpose of a function is to isolate certain code that performs a single computation making it testable and reusable. Let us go through the last sentence bit by bit using examples.

\hypertarget{function-performs-a-single-computation}{%
\subsection{Function performs a single computation}\label{function-performs-a-single-computation}}

I already \protect\hyperlink{programming-tips}{told you} that reading code is easy because every action has to be spelled-out for computers in a simple and clear way. However, \emph{a lot} of simple things can be very overwhelming and confusing. Think about the final code for the previous seminar: we had two loops with conditional statements nested inside. Add a few more of those and you have so many branches to trace, you never be quite sure what will happen. This is because our cognition and working memory, which you use to trace all branches, are limited to just about four items\footnote{The official magic number is \href{https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}{7±2} but reading the original paper tells you that this is more like four for most of us}.

Thus, a function should perform \emph{one} computation / action that is conceptually clear and those purpose should be understood directly from its name or, at most, from a single sentence that describes it\footnote{This is similar to scientific writing, where a single paragraph conveys a single idea. For me, it helps to first write the idea of the paragraph in a single sentence before writing the paragraph itself. If one sentence is not enough, I need to split the text into more paragraphs.}. The name of a function should typically be a \emph{verb} because function is about performing an action. If you need more than once sentence to explain what function does, you should consider splitting the code further. This does not mean that entire description / documentation must fit into a single sentence. The full description can be lengthy, particularly if underlying computation is complex and there are many parameters to consider. However, these are optional details that tell the reader \emph{how} the function is doing its job or how its behavior can be modified. Still, they should be able to understand \emph{what} the job is just from the name or from a single sentence. I am repeating myself and stressing this so much because conceptually simple single-job functions are a foundation of a clear robust reusable code. And future-you will be very grateful that it has to work with easy-to-understand isolated reliable code you wrote.

\hypertarget{function-isolates-code-from-the-rest-of-the-program}{%
\subsection{Function isolates code from the rest of the program}\label{function-isolates-code-from-the-rest-of-the-program}}

Isolation means that your code runs in a separate scope where the only things that exist are function arguments (limited number of values you pass to it from outside with fixed meaning) and local variables that you define inside the function. You have no access to variables defined in the outside script\footnote{This is not strictly true but that will concern us only once we get to so-called ``mutable'' objects like lists or dictionaries.} or to variables defined inside of other functions. Conversely, neither global script nor other functions have access to variables and values that you use inside. This means that you only need to study the code \emph{inside} the function to understand how it works. Accordingly, when you write the code it should be \emph{independent} of any global context the function can be used in. The isolation is both practical (no run-time access to variables from outside means fewer chance that things go terribly wrong) and conceptual (no further context is required to understand the code).

\hypertarget{function-makes-code-easier-to-test}{%
\subsection{Function makes code easier to test}\label{function-makes-code-easier-to-test}}

You can build even moderately complex programs only if you can be certain what individual chunks of code are doing under every possible condition. Do they produce the correct results? Do the fail clearly and raise a correct error, if the inputs are wrong? Do they use defaults when required? However, testing all chunks together means running extreme number of runs as you need to test all possible combinations of conditions for one chunk given all possible conditions for other chunk, etc. Functions make your life much easier. Because they have a single point of entry, fixed number of parameters, a single return value, and are isolated (see above), you can test them one at a time independent of other functions of the rest of the code. This is called \emph{unit testing} and it is a heavy usage of \href{https://docs.python.org/3/library/unittest.html}{automatic unit testing}\footnote{It is normal to have more code devoted to testing than to the actual program} that ensures reliable code for absolute majority of programs and apps that you use\footnote{You still need tests for the integrated system but testing individual functions is a clear prerequisite.}.

\hypertarget{function-makes-code-reusable}{%
\subsection{Function makes code reusable}\label{function-makes-code-reusable}}

Sometimes, this is given as a primary reason to use functions. Turning code into a function means that you can call the function instead of copy-pasting the code. The latter approach is a terrible idea as it means that you have to maintain the same code at many places and you might not be even sure in just how many. This is a problem even if a code is extremely simple. Here, we define a \emph{standard} way to compute an initial by taking the first symbol from a string (you will learn about indexing and slicing later). The code is as simple as it gets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\NormalTok{initial }\OperatorTok{=} \StringTok{"test"}\NormalTok{[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ filename[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ first\_name[}\DecValTok{0}\NormalTok{]}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Imagine that you decided to change it and use first \emph{two} symbols. Again, the computation is not complicated, use just replace \texttt{{[}0{]}} with \texttt{{[}:2{]}}. But you have to do it for \emph{all} the code that does this computation. And you cannot use \emph{Replace All} option because sometimes you might use the first element for some other purposes. And when you edit the code, you are bound to forget about some locations (I do it all the time) making things even less consistent and more confusing. Turning code into a function means you need to modify and test at just \emph{one} location. Here is the original code implemented via a function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first symbol.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : single symbol}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[}\DecValTok{0}\NormalTok{]}

\NormalTok{...}
\NormalTok{initial }\OperatorTok{=}\NormalTok{ generate\_initial(}\StringTok{"test"}\NormalTok{)}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ generate\_initial(filename)}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ generate\_initial(first\_name)}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

and here is the ``alternative'' initial computation. Note that the code that uses the function \emph{stays the same}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first TWO symbols.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : two symbols long}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[:}\DecValTok{2}\NormalTok{]}

\NormalTok{...}
\NormalTok{initial }\OperatorTok{=}\NormalTok{ generate\_initial(}\StringTok{"test"}\NormalTok{)}
\NormalTok{...}
\NormalTok{initial\_for\_file }\OperatorTok{=}\NormalTok{ generate\_initial(filename)}
\NormalTok{...}
\NormalTok{initial\_for\_website }\OperatorTok{=}\NormalTok{ generate\_initial(first\_name)}
\NormalTok{...}
\end{Highlighting}
\end{Shaded}

Thus, turning the code into a function is particularly useful when the reused code is complex but it pays off even if computation is as simple and trivial as in example above. With a function you have a single code chunk to worry about and you can be sure that the same computation is performed whenever you call the function (and that these are not several copies of the code that might or might not be identical).

Note that I put reusable code as the last and the least reason to use functions. This is because the other three reasons are far more important. Having a conceptually clear isolated and testable code is advantageous even if you call this function only once. It still makes code easier to understand and to test and helps you to reduce its complexity by replacing chunks of code with its meaning. Take a look at the example below. The first code takes the first symbol but this action (taking the first symbol) does not \emph{mean} anything by itself, it is just a mechanical computation. It is only the original context \texttt{initial\_for\_file\ =\ filename{[}0{]}} or additional comments that give it its meaning. In contrast, calling a function called \emph{compute\_initial} tells you what is happening, as it disambiguates the purpose. I suspect that future-you is very pro-disambiguation and anti-confusion.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ filename[}\DecValTok{0}\NormalTok{] }\OperatorTok{==} \StringTok{"A"}\NormalTok{:}
\NormalTok{    ...}
    
\ControlFlowTok{if}\NormalTok{ compute\_initial(filename) }\OperatorTok{==} \StringTok{"A"}\NormalTok{:}
\NormalTok{    ...}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions-in-python}{%
\section{Functions in Python}\label{functions-in-python}}

\hypertarget{defining-a-function-in-python}{%
\subsection{Defining a function in Python}\label{defining-a-function-in-python}}

A function in Python looks like this (note the indentation and \texttt{:} at the end of the first line)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def} \OperatorTok{\textless{}}\NormalTok{function name}\OperatorTok{\textgreater{}}\NormalTok{(param1, param2, ...):}
\NormalTok{    some internal computation}
    \ControlFlowTok{if}\NormalTok{ somecondition:}
        \ControlFlowTok{return}\NormalTok{ some value}
    \ControlFlowTok{return}\NormalTok{ some other value}
\end{Highlighting}
\end{Shaded}

The parameters are optional, so is the return value. Thus the minimal function would be

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ minimal\_function():}
    \ControlFlowTok{pass} \CommentTok{\# pass means "do nothing"}
\end{Highlighting}
\end{Shaded}

You must define your function (once!) before calling it (one or more times). Thus, you should create functions \emph{before} the code that uses it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ do\_something():}
    \CommentTok{"""}
\CommentTok{    This is a function called "do\_something". It actually does nothing.}
\CommentTok{    It requires no input and returns no value.}
\CommentTok{    """}
    \ControlFlowTok{return}
    
\KeywordTok{def}\NormalTok{ another\_function():}
\NormalTok{    ...}
    \CommentTok{\# We call it in another function.}
\NormalTok{    do\_something()}
\NormalTok{    ...}

\CommentTok{\# This is a function call (we use this function)}
\NormalTok{do\_something()}

\CommentTok{\# And we use it again!}
\NormalTok{do\_something()}

\CommentTok{\# And again but via another\_function call}
\NormalTok{another\_function()}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

You must also keep in mind that redefining a function (or defining a technically different function that has the same name) overwrites the original definition, so that only the \emph{latest} version of it is retained and can be used.

Do exercise \#2.

Although example in the exercise makes the problem easy to spot, in a large code that spans multiple files and uses various libraries, solving the same problem may not be so straightforward!

\hypertarget{function-arguments}{%
\subsection{Function arguments}\label{function-arguments}}

Some functions may not need arguments (also called parameters), as they perform a fixed action:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ ping():}
    \CommentTok{"""}
\CommentTok{    Machine that goes "ping!"}
\CommentTok{    """}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"ping!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

However, you may need to pass information to the function via arguments in order to influence how the function performs its action. In Python, you simply list arguments within the round brackets after the function name (there are more bells and whistles but we will keep it simple for now). For example, we could write a function that computes and prints person's age given two parameters 1) their birth year, 2) current year:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ print\_age(birth\_year, current\_year):}
    \CommentTok{"""}
\CommentTok{    Prints age given birth year and current year.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    birth\_year : int}
\CommentTok{    current\_year : int}
\CommentTok{    """}
    \BuiltInTok{print}\NormalTok{(current\_year }\OperatorTok{{-}}\NormalTok{ birth\_year)}
\end{Highlighting}
\end{Shaded}

It is a \textbf{very good idea} to give meaningful names to functions, parameters, and variables. The following code will produce exactly the same result but understanding \emph{why} and \emph{what for} it is doing what it is doing would be much harder (so \textbf{always} use meaningful names!):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ x(a, b):}
    \BuiltInTok{print}\NormalTok{(b }\OperatorTok{{-}}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

When calling a function, you must pass the correct number of parameters and pass them in a \emph{correct order}, another reason for a function arguments to have meaningful names\footnote{This is also not strictly true but you will have to wait until you learn about named parameters and default values}.

Do exercise \#3.

When you call a function, values you \emph{pass} to the function are assigned to the parameters and they are used as \emph{local} variables (more on \emph{local} bit later). However, it does not matter \emph{how} you came up with this values, whether they were in a variable, hard-coded, or returned by another function. If you are using numeric, logical, or string values (\emph{immutable} types), you can assume that any link to the original variable or function that produced it is gone (we'll deal with \emph{mutable} types, like lists, later). Thus, when writing a function or reading its code, you just assume that it has been set to some value during the call and you can ignore the context in which this call was made

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# hardcoded}
\NormalTok{print\_age(}\DecValTok{1976}\NormalTok{, }\DecValTok{2020}\NormalTok{)}

\CommentTok{\# using values from variables}
\NormalTok{i\_was\_born }\OperatorTok{=} \DecValTok{1976}
\NormalTok{today\_is }\OperatorTok{=} \DecValTok{2020}
\NormalTok{print\_age(i\_was\_born, today\_is)}

\CommentTok{\# using value from a function}
\KeywordTok{def}\NormalTok{ get\_current\_year():}
    \ControlFlowTok{return} \DecValTok{2020}

\NormalTok{print\_age(}\DecValTok{1976}\NormalTok{, get\_current\_year())}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions-returned-value-output}{%
\subsection{Functions' returned value (output)}\label{functions-returned-value-output}}

Your function may perform an action without returning any value to the caller (this is what out \texttt{print\_age} function was doing). However, you may need to return the value instead. For example, to make things more general, we might want write a new function called \texttt{compute\_age} that returns the age instead of printing it (we can always print it ourselves).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ compute\_age(birth\_year, current\_year):}
    \CommentTok{"""}
\CommentTok{    Computes age given birth year and current year.}

\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    birth\_year : int}
\CommentTok{    current\_year : int}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    int : age}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ current\_year }\OperatorTok{{-}}\NormalTok{ birth\_year}
\end{Highlighting}
\end{Shaded}

Note that even if a function returns the value, it is retained only if it is actually used (stored in a variable, used as a value, etc.). Thus, just calling it will not by itself store the returned value anywhere!

Do exercise \#4.

\hypertarget{scopes-for-immutable-values}{%
\subsection{Scopes (for immutable values)}\label{scopes-for-immutable-values}}

As we have discussed above, turning code into a function \emph{isolates} it, so makes it run in it own \emph{scope}. In Python, each variable exists in the \emph{scope} it has been defined in. If it was defined in the \emph{global} script, it exists in that \emph{global} scope as a \emph{global} variable. However, it is not accessible (at least not without special effort via a \texttt{global} operator) from within a function. Conversely, function's parameters and any variables defined \emph{inside a function}, exists and are accessible only \textbf{inside that function}. It is fully invisible for the outside world and cannot be accessed from a global script or from another function. Conversely, any changes you make to the function parameter or local variable have no effect on the outside world\footnote{Again, almost, as \emph{mutable} objects like lists are more complicated, more on that later}.

The purpose of scopes is to isolate individual code segments from each other, so that modifying variables within one scope has no effect on all other scopes. This means that when writing or debugging the code, you do not need to worry about code in other scopes and concentrate only on the code you working on. Because scopes are isolated, they may have \emph{identically named variables} that, however, have no relationship to each other as they exists in their own parallel universes. Thus, if you want to know which value a variable has, you must look only within the scope and ignore all other scopes (even if the names match!).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this is variable \textasciigrave{}x\textasciigrave{} in the global scope}
\NormalTok{x  }\OperatorTok{=} \DecValTok{5} 

\KeywordTok{def}\NormalTok{ f1():}
  \CommentTok{\# This is variable \textasciigrave{}x\textasciigrave{} in the scope of function f1}
  \CommentTok{\# It has the same name as the global variable but}
  \CommentTok{\# has no relation to it: many people are called Sasha }
  \CommentTok{\# but they are still different people. Whatever}
  \CommentTok{\# happens to \textasciigrave{}x\textasciigrave{} in f1, stays in f1\textquotesingle{}s scope.}
\NormalTok{  x }\OperatorTok{=} \DecValTok{3}
  
  
\KeywordTok{def}\NormalTok{ f2(x):}
  \CommentTok{\# This is parameter \textasciigrave{}x\textasciigrave{} in the scope of function f2.}
  \CommentTok{\# Again, no relation to other global or local variables.}
  \CommentTok{\# It is a completely separate object, it just happens to }
  \CommentTok{\# have the same name (again, just namesakes)}
  \BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

\hypertarget{players-response-as-a-function}{%
\section{Player's response as a function}\label{players-response-as-a-function}}

Let us put all that theory about functions into practice. Use the code that you created to acquire \protect\hyperlink{guess-the-number-players-response}{player's response} and turn it into function. It should have no parameters (for now) and should return player's response. I suggest that you call it \texttt{input\_response} (or something along these lines). Test that the code works by calling this function for the main script.

Put your code into \texttt{code02.py}.

\hypertarget{debugging-a-function}{%
\section{Debugging a function}\label{debugging-a-function}}

Now that we have your first function, you can make sense of three step over/in/out buttons that the debugger offers you. Copy-paste the following code in a separate file (call it \texttt{test01.py}, for example).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ f1(x, y):}
  \ControlFlowTok{return}\NormalTok{ x }\OperatorTok{/}\NormalTok{ y}
  
\KeywordTok{def}\NormalTok{ f2(x, y):}
\NormalTok{  x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \DecValTok{5}
\NormalTok{  y }\OperatorTok{=}\NormalTok{ y }\OperatorTok{*} \DecValTok{2}
  \ControlFlowTok{return}\NormalTok{ f1(x, y)}
  
\NormalTok{z }\OperatorTok{=}\NormalTok{ f2(}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

First, put a break point on the line in the main script that calls function \texttt{f2()}. Run the debugger via \textbf{F5} and the program will pause at that line. If you now press \textbf{F10} (step over), the program will go to the next line \texttt{print(z)}. However, if you are to press \textbf{F11} (step into) instead, the program will \emph{step into} the function and go to \texttt{x\ =\ x\ +\ 5} line. When inside the function, you have the same two choices we just looked at but also, you can press \textbf{Shift+F11} to step out of the function. Here, the program will run all the code until you reach the next line \emph{outside} of the function (you should end up at \texttt{print(z)} again). Experiment with putting breakpoints at various lines and stepping over/in/out to get a hang of these useful debugging tools.

Now, put the breakpoint inside of \texttt{f1()} function and run the code via \textbf{F5}. Take a look at the left pane, you will see a \emph{Call Stack} tab. While yellow highlighted line in the editor shows you where you currently are (should be inside the \texttt{f1()} function), the \emph{Call Stack} shows you how did you get where. In this case it should show:

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
f1 & test01.py & 2:1 \\
f2 & test01.py & 7:1 \\
\textless module\textgreater{} & test01.py & 9:1 \\
\end{longtable}

The calls are stacked from bottom to top, so this means that a function was called in the main module in line 9, you ended up in function \texttt{f2} in line 7, and then in function \texttt{f1} and in line 2. Experiment with stepping in and out of functions while keeping an eye on this. You might not need this information frequently but could be useful in our later projects with multiple nested function calls.

\hypertarget{numpy-docstring}{%
\section{Documenting your function}\label{numpy-docstring}}

Writing a function is only half the job. You need to document it! \protect\hyperlink{programming-tips}{Remember}, this is a good habit that makes your code easy to use and reuse. There are different ways to document the code but we will use \href{https://numpydoc.readthedocs.io/en/latest/format.html\#docstring-standard}{NumPy docstring convention}. Here is an example of such documented function

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ generate\_initial(full\_string):}
    \CommentTok{"""Generates an initial using first symbol.}
\CommentTok{    }
\CommentTok{    Parameters}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    full\_string : str}
\CommentTok{    }
\CommentTok{    Returns}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    str : single symbol}
\CommentTok{    """}
    \ControlFlowTok{return}\NormalTok{ full\_string[}\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Take the look at the \href{https://numpydoc.readthedocs.io/en/latest/format.html\#docstring-standard}{manual} and document the \texttt{input\_response} function. You will not need the \texttt{Parameters} section as it currently accepts no inputs.

Update your code in \texttt{code02.py}.

\hypertarget{using-prompt}{%
\section{Using prompt}\label{using-prompt}}

In the future, we will be asking about a specific number that is a current guess by the computer, thus we cannot use a fixed prompt message. Modify the \texttt{input\_response} function by adding a \texttt{guess} parameter. Then, modify the prompt that you used for the \href{https://docs.python.org/3/library/functions.html\#input}{input()} to include that number. Update functions' documentation. Test it by calling with different values for the \texttt{guess} parameter.

Put your code into \texttt{code03.py}.

\hypertarget{splitting-interval-in-the-middle}{%
\section{Splitting interval in the middle}\label{splitting-interval-in-the-middle}}

Let us practice writing functions a bit more. Recall that the computer should use the middle of the interval as a guess. Create a function (let us call it \texttt{split\_interval()} or something like that) that takes two parameters --- \texttt{lower\_limit} and \texttt{upper\_limit} --- and returns \emph{an integer} that is closest to the middle of the interval. The only tricky part is how you convert a potentially float number (e.g, when you are trying to find it for the interval 1..10) to an integer. You can use function \href{https://docs.python.org/3/library/functions.html\#int}{int()} for that. However, read the documentation carefully, as it \emph{does not} perform a proper rounding (what does it do? read the docs!). Thus, you should \href{https://docs.python.org/3/library/functions.html\#round}{round()} the number to the closest integer before converting it.

Write a function, document it, and test it by checking that numbers are correct.

Put you \texttt{split\_interval()} function and the testing code into \texttt{code04.py}.

\hypertarget{single-round}{%
\section{Single round}\label{single-round}}

You have both functions that you need, so let us write the code to initialize the game and play a single round. The initialization boils down to creating two variables that correspond to the lower and upper limits of the game range (we used 1 to 10 so far, but you can always change that). Next, the computer should generate a guess (you have your \texttt{split\_interval()} function for that) and ask the player about the guess (that is the \texttt{input\_response()} function). Once you have the response (stored in a separate variable, think of the name yourself), you can update your upper or lower limit using an \protect\hyperlink{if-statement}{if..elif..else} statement based on player's response. Print out a joyous message, if computer's guess was correct.

Put both functions and the script code into \texttt{code05.py}.

\hypertarget{multiple-rounds}{%
\section{Multiple rounds}\label{multiple-rounds}}

Extend the game, so that the computer keeps guessing until it finally wins. You already know how to use the \protect\hyperlink{while-loop}{while} loop, just think how you can use participant's response as a loop condition variable. Also, think about the initial value of that variable and how to use it so you call \texttt{input\_response()} only at one location.

Put the updated code into \texttt{code06.py}.

\hypertarget{playing-again}{%
\section{Playing again}\label{playing-again}}

Modify the code, so that you can play this game several times. You already know how to do this and the only thing you need to consider is where exactly should you perform initialization before each round. As you already implemented that for the last game, you might be tempted to look how you did it or, even, copy-paste the code. However, I would recommend writing it from scratch. Remember, your aim is not to write a program but to learn how to do this and, therefore, the journey is more important than a destination.

Put the updated code into \texttt{code07.py}.

\hypertarget{best-score-1}{%
\section{Best score}\label{best-score-1}}

Add the code to count the number of attempts that the computer required in each round and
report the best score (fewest number of attempts) after the game is over. You will need one variable to count the number of attempts and one to keep the best score. Again, try writing it without looking at your previous game.

Put the updated code into \texttt{code08.py}.

\hypertarget{using-you-own-libraries}{%
\section{Using you own libraries}\label{using-you-own-libraries}}

You already know how to \protect\hyperlink{using-libraries}{use existing libraries} but you can also create and use your own. Take the two functions that you developed and put them into a new file called \texttt{utils.py} (do not forget to put a multiline comment at the top of the file to remind you what is inside!) . Copy the remaining code (the global script) into \texttt{code09.py}. It will not work in its current state as it won't find the two functions (try it to see the error message), so you need to import from your own \texttt{utils} module. Importing works exactly the same way as for other libraries. Note that even though your file is \texttt{utils.py}, the module name is \texttt{utils} (without the extension).

Put function into \texttt{utils.py}, the remaining code into \texttt{code09.py}.

\hypertarget{keep-imports-tidy}{%
\section{Ordnung muss sein!}\label{keep-imports-tidy}}

So far, you only imported one library at most. However, as Python is highly modular, it is very common to have many imports in a single file. There are several rules that make it easier to track the imports. When you import libraries, all import statements should be at the top of your file and you should avoid putting them in random order. The recommended order is 1) system libraries, like \texttt{os} or \texttt{random}; 2) third-party libraries, like \texttt{psychopy}; 3) your project modules . And, within each section you should put the libraries \emph{alphabetically}, so

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

This may not look particularly useful for our simple code but as your projects will grow, you will need to include more and more libraries. Keeping them in that order makes it easy to understand which libraries you use and which are non-standard. Alphabetic order means that you can quickly check whether a library is included, as you can quickly find the location where its import statement should appear.

\hypertarget{putting-video-into-videogames}{%
\section{Putting video into videogames}\label{putting-video-into-videogames}}

Submit your files and be ready for more excitement as we are moving onto ``proper'' videogames with PsychoPy.

\hypertarget{psychopy-basics}{%
\chapter{Gettings started with PsychoPy}\label{psychopy-basics}}

Before we program our first game using \href{https://psychopy.org/}{PsychoPy}, we need to spend some time figuring out its basics. It is not the most suitable library for writing games, for that you might want to use \href{https://arcade.academy/}{Python Arcade} or \href{https://www.pygame.org/}{PyGame}. However, it is currently the best Python library for developing psychophysical experiments (and this is what we are after).

\hypertarget{chapter-concepts-3}{%
\section{Chapter concepts}\label{chapter-concepts-3}}

\begin{itemize}
\tightlist
\item
  Understanding how to use \protect\hyperlink{classes-and-objects}{classes and objects}.
\item
  Using \protect\hyperlink{arguments-by-position-or-name}{named parameters} in functions.
\item
  Understanding PsychoPy \protect\hyperlink{psychopy-units}{units system}.
\item
  Using basic Psycho \protect\hyperlink{adding-text-message}{visual stimuli} and handling \protect\hyperlink{make-the-square-jump-on-your-command}{user inputs}.
\end{itemize}

\hypertarget{minimal-psychopy}{%
\section{Minimal PsychoPy code}\label{minimal-psychopy}}

Copy-paste the following code into \texttt{code01.py} file (you did remember to create a new folder for the chapter?):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{"""}
\CommentTok{A minimal PsychoPy code.}
\CommentTok{"""}

\CommentTok{\# this imports two modules from psychopy}
\CommentTok{\# visual has all the visual stimuli, including the Window class}
\CommentTok{\# that we need to create a program window}
\CommentTok{\# event has function for working with mouse and keyboard}
\ImportTok{from}\NormalTok{ psychopy }\ImportTok{import}\NormalTok{ visual, event}

\CommentTok{\# creating a 800 x 600 window}
\NormalTok{win }\OperatorTok{=}\NormalTok{ visual.Window(size}\OperatorTok{=}\NormalTok{(}\DecValTok{800}\NormalTok{, }\DecValTok{600}\NormalTok{))}

\CommentTok{\# waiting for any key press}
\NormalTok{event.waitKeys()}

\CommentTok{\# closing the window}
\NormalTok{win.close()}
\end{Highlighting}
\end{Shaded}

Run it to check that PsychoPy work. If you get an error saying that \texttt{psychopy} library is not found, check the \protect\hyperlink{install-vs-code}{active Python interpreter}. You should get a gray window with \emph{PsychoPy} title. Press any key (click on the window, if you switched to another one, so that it registers a key press) and it should close. Not very exciting but does show that everything works as it should.

Put your code into \emph{code01.py}.

The code is simple but packs quite a few novel bits. First line is easy, we simply import \href{https://psychopy.org/api/visual/index.html}{visual} and \href{https://psychopy.org/api/event.html}{event} modules from \emph{psychopy} library (a library can be itself organized into sublibraries to make things even more modular). Then, we create an \emph{object} \texttt{win} using a \emph{class} \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{Window} with custom size. Third line uses function \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} from \emph{event} module to wait for a key press. The last one closes the window by calling its \texttt{close} \emph{method}. You should have little trouble with lines \#1 and \#3 but you need to learn about object-oriented programming to understand \#2 and \#4.

\hypertarget{classes-and-objects}{%
\section{Classes and objects}\label{classes-and-objects}}

The PsychoPy library is a collection of \emph{classes} that you use to create \emph{objects}, an approach called \emph{object-oriented programming}. The core idea is in the name: Instead of keeping variables (data) separate from functions (actions), you combine them in an object that has attributes\footnote{Also called properties} (its own variables) and methods (its own functions). This approach utilizes our natural tendency to perceive the world as a collection of interacting objects.

First, you need to understand an important distinction between \emph{classes} and \emph{objects}. A \emph{class} is a ``blueprint'' that describes properties and behavior of \emph{all} objects of that class. This ``blueprint'' is used to create an \emph{instance} of that class, which is called an \emph{object}. For example, Homo sapiens is a \emph{class} that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class has only a \emph{concept} of height but no specific height itself. E.g., you cannot ask ``What is height of Homo sapiens?'' only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say ``Run, Homo sapiens! Run!'' as abstract concepts have trouble performing real actions like that. Instead, it is Alexander Pastukhov who is an \emph{instance} of Homo sapiens class with a specific height and a specific (not particularly good) ability to run. Other instances of Homo sapiens (other people) have different height and a different (typically better) ability to run. Thus, a class describes all common properties and methods that all \emph{instances} of the class (all objects) will have. But individual object will behave differently because of different values of their properties. This means that whenever you meet a Homo sapien, you could be sure that they have height per se but will need to look at an individual \emph{instance} to figure what height they have.

\texttt{Window} is a class that describes properties that a PsychoPy window must have and actions it can perform (you can see the complete list in \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{the manual}). To create an object, we use its class definition and store the result in a variable. In the code above we call \texttt{Window} class\footnote{Technically, we call a class constructor method called \texttt{\_\_init\_\_} but this is not important for now.} while passing custom parameters to it (\texttt{size=(800,\ 600)}) and store an object that it returns in variable \texttt{win}.

Attributes are, essentially, variables that belong to the class and, therefore, variables that each object will possess. For example, a \texttt{Window} class has \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.size}{size} attribute that determines its on-screen size in pixels. It also has (background) \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.color}{color}, an attribute that determines whether it should be shown in \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.fullscr}{full screen mode}, etc. Thus, a \texttt{win} object will have all these attributes and they will have specific values.

To understand both properties and class/object distinction better, put a breakpoint on the third line of code (\texttt{event.waitKeys()}) and fire up the debugger via \textbf{F5}. Once the window is created, the execution will pause and you will find a \texttt{win} object in \emph{Variables/Locals}. Click on it and it will expand to show all attributes and its values, including \texttt{size} (check that it is \texttt{{[}800,\ 600{]}}). Note that you will not see \texttt{Window} itself in the same list. This is because it is a class, an abstract concept, whereas as \texttt{win} is its instance and object of that class.

Methods, such as \texttt{Window.close()} are, essentially, functions that belong to the class/object and perform certain actions on the object. For example, method \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.close}{close()} closes the window, \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.flip}{flip()} updates it after we finished drawing in it, etc. What is important is to remember is that each method will act only on the object \emph{it belongs to} and not on other instances of the same class. This means that you can create two windows (\texttt{win1} and \texttt{win2}) and calling \texttt{win1.close()} will close the first but not the second window (try this out!). Same goes for attributes, changing them in one object will not affect any other objects of the same class, just like changing a value in one variable will not affect the other ones.

Although we barely scratched the surface of object-oriented programming, it will be enough for us to be able to use classes defined for us in PsychoPy library.

\hypertarget{arguments-by-position-or-name}{%
\section{Function parameters: default values, passing by position or by name}\label{arguments-by-position-or-name}}

There are a few more curious bits in the \texttt{visual.Window(size=(800,\ 600))} call above that we need to discuss. These curiosities are related to functions (and, therefore, methods) not classes per se. First, constructor method of the Window class has \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{a lot of arguments} (when we construct an object, we call a constructor \emph{method} of the class, which is why we are talking about functions). And yet, we only passed one of them. This is because you can specify \href{https://docs.python.org/3/tutorial/controlflow.html\#default-argument-values}{default values} for individual parameters. In this case, if a parameter is omitted, a default value is used instead

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ divide(x1, x2}\OperatorTok{=}\DecValTok{2}\NormalTok{):}
  \CommentTok{"""}
\CommentTok{  Divides numbers, uses 2 as a second value if a second term is omitted.}
\CommentTok{  }
\CommentTok{  Parameters:}
\CommentTok{  {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{  x1 : number}
\CommentTok{  x2 : number, defaults to 2}
\CommentTok{  }
\CommentTok{  Returns:}
\CommentTok{  {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{  number}
\CommentTok{  """}
  \ControlFlowTok{return}\NormalTok{ x1 }\OperatorTok{/}\NormalTok{ x2}
\BuiltInTok{print}\NormalTok{(divide(}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} 1.0}
\BuiltInTok{print}\NormalTok{(divide(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} 0.5}
\end{Highlighting}
\end{Shaded}

If you look at \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{documentation}, you will see that for the Window class constructor \emph{all} parameters have a default value. This is a part of PsychoPy's philosophy of combining rich customization (just look at the sheer number of parameters!) with simplicity of use through sensible defaults (specify nothing and the window will still work).

Second, we did not just pass the value but specified which parameter this value is for via \texttt{size=(800,\ 600)}. This notation is called \href{https://docs.python.org/3/tutorial/controlflow.html\#keyword-arguments}{keyword arguments}. The advantage is in making it more explicit which parameter you are passing a value through. Plus, it allows you to put parameters any order, if that is more relevant given the context\footnote{However, stick to original order for consistency otherwise.}. If you do not use names, the values are assigned to individual parameters based on their \emph{position} (a.k.a. positional parameters). You can even mix the two, but positional parameters must come first, see \href{https://docs.python.org/3/tutorial/controlflow.html\#more-on-defining-functions}{documentation} if you want to know more.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# using positional parameters}
\BuiltInTok{print}\NormalTok{(divide(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} 0.5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# using keyword arguments}
\BuiltInTok{print}\NormalTok{(divide(x2}\OperatorTok{=}\DecValTok{4}\NormalTok{, x1}\OperatorTok{=}\DecValTok{2}\NormalTok{))}
\CommentTok{\#\textgreater{} 0.5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# mixing positional and keyword arguments}
\BuiltInTok{print}\NormalTok{(divide(}\DecValTok{2}\NormalTok{, x2}\OperatorTok{=}\DecValTok{4}\NormalTok{))}
\CommentTok{\#\textgreater{} 0.5}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-main-loop}{%
\section{Adding main loop}\label{adding-main-loop}}

Currently, not much is happening in our program. One thing we need to add is a loop in which we can repeatedly draw in a window (and update it via its \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.flip}{flip()} method), check user input, and perform any other necessary actions.

First, let us add the loop and handling of user inputs (the fun drawing part will be next). The loop goes between opening and closing the window:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing libraries}
\NormalTok{opening the window}

\OperatorTok{{-}{-}\textgreater{}}\NormalTok{ our main loop }\OperatorTok{\textless{}{-}{-}}

\NormalTok{closing the window}
\end{Highlighting}
\end{Shaded}

The loop should be repeated until the user presses an \emph{escape} key and, therefore, you will need a variable that signals this. My approach is to create a variable \texttt{gameover} initializing it to \texttt{False} and repeat the loop as long as the game not over. Then, in the loop, use function \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{event.getKeys()} to check whether \emph{escape} button was pressed (for this, you need to pass \texttt{keyList={[}\textquotesingle{}escape\textquotesingle{}{]}}). The function returns a \emph{list} of keys, if any of them were pressed in the meantime or an empty list, if no keys from the \texttt{keyList} were pressed. Store that returned value in a temporary variable (I tend to call it \texttt{keys}). You will learn about lists only in the \emph{next} chapter, so for now use a ready-made: \texttt{len(keys)\ \textgreater{}\ 0} is a comparison that is \texttt{True} if list is not empty. If the list is indeed not empty, that means that the user pressed \emph{escape} (as that is the only key that we specified in the function call) and the game should be over. Think how can you do it \emph{without} an \texttt{if} statement, computing the logical value directly?

Put your code into \emph{code02.py}.

\hypertarget{adding-text-message}{%
\section{Adding text message}\label{adding-text-message}}

Although we are now running a nice game loop, we still have only a boring gray window to look at. Let us create a text stimulus, which would say ``Press escape to exit'' and display it during the loop. For this we will use \href{https://psychopy.org/api/visual/textstim.html}{visual.TextStim} class from PsychoPy library.

First, you need to create the \texttt{press\_escape\_text} object (instance of the \href{https://psychopy.org/api/visual/textstim.html\%20class}{TextStim}) before the main loop. There are quite a few parameters that you can play with but minimally, you need to pass the window the text should be displayed in (our \texttt{win} variable) and the actual text you want to display (\texttt{text="Press\ escape\ to\ exit"}). For all other settings PsychoPy will use its \protect\hyperlink{arguments-by-position-or-name}{defaults} (default font family, color and size, placed right at the windows' center).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{press\_escape\_text }\OperatorTok{=}\NormalTok{ visual.TextStim(win, }\StringTok{"Press escape to exit"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To show the visuals in PsychoPy, you first \emph{draw} each element by calling its \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim.draw}{draw()} method and then update the window by \emph{flipping}\footnote{This is called flipping because a window has two buffers: one that is currently displayed on the screen and the other one in which you can draw your stimuli. Once you are done with drawing, you ``flip'' the buffers so that they exchange their places. Now the one you drew in gets displayed and you have the other buffer to draw in.} it. Note that you call \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.flip}{flip()} only \emph{once} after \emph{all} stimuli are drawn. I typically organize this code into a separate chunk and prepend it with a comment line \texttt{\#\ drawing\ stimuli}.

The \texttt{\#\ drawing\ stimuli} chunk goes inside the main loop either before\footnote{My personal preference is to draw first but in most cases it makes no difference.} or after the keyboard check. Organize the latter also as a separate code chunk with its own brief comment.

Put your code into \emph{code03.py}.

Now, you should have a nice, although static, message positioned at the window's center that tells you how you can exit the game. Check out the manual page for \href{https://psychopy.org/api/visual/textstim.html}{visual.TextStim} and try changing it by passing additional parameters to the class call. For example you can change its \texttt{color}, whether text is \texttt{bold} and/or \texttt{italic}, how it is aligned, etc. However, if you want to change \emph{where} the text is displayed, read on below.

\hypertarget{adding-a-square-and-placing-it-not-at-the-center-of-the-window}{%
\section{\texorpdfstring{Adding a square and placing it \emph{not} at the center of the window}{Adding a square and placing it not at the center of the window}}\label{adding-a-square-and-placing-it-not-at-the-center-of-the-window}}

Now, let us figure out how create and move visuals to an arbitrary location on the screen. In principle, this is very straightforward as every visual stimulus (including \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} we just used) has \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim.pos}{pos} property that specifies (you guessed it!) its position within a window. However, to make your life easier, PsychoPy first complicates it by having \href{https://psychopy.org/general/units.html}{\textbf{five} (5!) different position units systems}.

Before we start exploring the units, let us create a simple white square. The visual class we need is \href{https://psychopy.org/api/visual/rect.html}{visual.Rect}. Just like the \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} above, it requires \texttt{win} variable (so it knows which window it belongs to), \texttt{width} (defaults to 0.5 of those mysterious units), \texttt{height} (also defaults to 0.5), \texttt{pos} (defaults to (0,0)), \texttt{lineColor} (defaults to \texttt{white}) and \texttt{fillColor} (defaults to \texttt{None}). Thus, to get a ``standard'' white outline square with size of \texttt{(0.5,\ 0.5)} units at \texttt{(0,\ 0)} location you only need pass the \texttt{win} variable: \texttt{white\_square\ =\ visual.Rect(win)}. However, on \emph{some} computers a curious bug prevents PsychoPy from drawing the outline correctly. If you end up staring at an empty screen, add \texttt{fillColor="white"} to the call and you should see a filled white square.

You draw the square just like you drew the text stimulus, via its \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect.draw}{draw()} method. Create the code (either keep the text and draw both, or drop the text), run it to see a very white square.

Put your code into \emph{code04.py}.

What? Your square is not really a square? Well, I've warned you: \href{https://psychopy.org/general/units.html\#units}{Five unit systems}!

\hypertarget{psychopy-units}{%
\section{Five unit systems}\label{psychopy-units}}

\hypertarget{psychopy-units-height}{%
\subsection{Height units}\label{psychopy-units-height}}

With \href{https://psychopy.org/general/units.html\#height-units}{height units} everything is specified in the units of window height. The center of the window is at \texttt{(0,0)} and the window goes vertically from \texttt{-0.5} to \texttt{0.5}. However, horizontal limits depend on the aspect ratio. For our 800×600 window (4:3 aspect ratio), it will go from -0.666 to 0.666 (the window is 1.3333 window heights wide). For a 600×800 window (3:4 aspect ratio) from -0.375 to 0.375 (the window is 0.75 window heights wide), for a square window 600×600 (aspect ratio 1:1) from -0.5 to 0.5 (again, in all these cases it goes from -0.5 to 0.5 vertically). This means that the actual on-screen distance for the units is the same for both axes. So that a square of \texttt{size=(0.5,\ 0.5)} is actually a square (it spans the same distance vertically and horizontally). Thus, height units make \emph{sizing} objects easier but \emph{placing them on horizontal axis correctly} harder (as you need to know the aspect ratio).

Modify your code by specifying the unit system when you create the window: \texttt{win\ =\ visual.Window(...,\ units="height")}. Play with your code by specifying position of the square when you create it. You just need to pass an extra parameter \texttt{pos=(\textless{}x\textgreater{},\ \textless{}y\textgreater{})}.

Put your code into \emph{code05.py}.

By the way, which way is up when y is below or above zero? Unfortunately, unlike x-axis, the y-axis can go both ways. For PsychoPy y-axis points up (so negative values move the square down and positive up). However, if you would use an Eyelink eye tracker to record where participants looked \emph{on the screen}, it assumes that y-axis starts at the top of the screen and points down\footnote{This could be very confusing, if you forget about this when overlaying gaze data on an image you used in the study and wondering what on Earth the participants were doing}.

Now, modify the size of the square (and turn it into a non-square rectangle) by passing \texttt{width=\textless{}some-width-value\textgreater{}} and \texttt{height=\textless{}some-height-value\textgreater{}}.

Put your code into \emph{code06.py}.

\hypertarget{psychopy-units-norm}{%
\subsection{Normalized units}\label{psychopy-units-norm}}

\href{https://psychopy.org/general/units.html\#normalised-units}{Normalized units} are default units and assume that the window goes from -1 to 1 both along x- and x-axis. Again, (0,0) is the center of the screen but the bottom-left corner is (-1, -1) whereas the top-right is (1, 1). This makes \emph{placing} your objects easier but \emph{sizing} them harder (you need to know the aspect ratio to ensure that a square is a square).

Modify your code, so that it uses \texttt{"norm"} units when you create the window and size your white square stimulus, so it does look like a square.

Put your code into \emph{code07.py}.

\hypertarget{pixels-on-screen}{%
\subsection{Pixels on screen}\label{pixels-on-screen}}

For \href{https://psychopy.org/general/units.html\#pixels-on-screen}{pixels on screen} units, the window center is still at \texttt{(0,0)} but it goes from \texttt{-\textless{}width-in-pixels\textgreater{}/2} to \texttt{\textless{}width-in-pixels\textgreater{}/2} horizontally (from -400 to 400 in our case) and \texttt{-\textless{}height-in-pixels\textgreater{}/2} to \texttt{\textless{}height-in-pixels\textgreater{}/2} vertically (from -300 to 300). These units could be more intuitive when you are working with a fixed sized window, as the span is the same along the both axes (like for the height units). However, they spell trouble if your window size has changed or you are using a full screen window on a monitor with an unknown resolution. In short, you should use them only if they dramatically simplify your code.

Modify your code to use \texttt{"pix"} units and briefly test sizing and placing your square within the window.

Put your code into \emph{code08.py}.

\hypertarget{degrees-of-visual-angle}{%
\subsection{Degrees of visual angle}\label{degrees-of-visual-angle}}

Unlike the three units above, using \href{https://psychopy.org/general/units.html\#degrees-of-visual-angle}{degrees of visual angle} requires you knowing a physical size of the screen, its resolution, and viewing distance (how far your eyes are away from the screen). They are \emph{the} measurement units used in visual psychophysics as they describe stimulus size as it appears on the retina (see \href{https://en.wikipedia.org/wiki/Visual_angle}{Wikipedia} for details). Thus, these are the units you want to use when running an actual experiment in the lab.

\hypertarget{centimeters-on-screen}{%
\subsection{Centimeters on screen}\label{centimeters-on-screen}}

Here, you would need know the physical size of your screen and its resolution. These are fairly exotic units for very specific usage cases\footnote{So specific that I cannot think of one, to be honest.}.

\hypertarget{make-your-square-jump}{%
\section{Make your square jump}\label{make-your-square-jump}}

So far, we fixed the location of the square when we created it. However, you can move it at any time by assigning a new \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} coordinates to its \texttt{pos} property. \emph{E.g.}, \texttt{white\_square.pos\ =\ (-0.1,\ 0.2)}. Let us experiment by moving the square to a random location on every iteration of the loop (this could cause a lot of flashing, so if you have a photosensitive epilepsy that can be triggered by flashing lights, you probably should do it just once before the loop). Use the units of your choice and generate a new position using \href{https://docs.python.org/3/library/random.html\#random.uniform}{random.uniform(a, b)} function, that generates a random value within \emph{a..b} range\footnote{You need to import the random library for this, of course.}. Generate two values (one for x, one for y). If you use \texttt{"norm"} units, your range is the same (from -1 to 1) for the two dimensions. However, if you used \texttt{"height"} units, you need to take into account the aspect ratio of your window (4:3 if you are using 800×600 pix window).

Put your code into \emph{code09.py}.

\hypertarget{make-the-square-jump-on-your-command}{%
\section{Make the square jump on your command}\label{make-the-square-jump-on-your-command}}

This was very flashy, so let us make the square jump only when you press \textbf{space} button. For this, we need to expand the code that processes keyboard input. So far, we restricted it to just \textbf{escape} button and checked whether any (hence, \textbf{escape}) button was pressed.

You will learn about lists and indexes in the next chapter, so here is another ready-made. First, add \texttt{"space"} to the \texttt{keyList} parameter. Next, use conditional \protect\hyperlink{ux5cux257Bux5cux23if-statement}{if statement} to check whether \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{event.getKeys()} returned a key press. If it did (\texttt{len(keys)\ \textgreater{}\ 0}), you can now check whether \texttt{keys{[}0{]}} is equal to \texttt{"space"} or \texttt{"escape"}\footnote{You can use \texttt{if..else}, because we only have two options but I would recommend to go for a more general solution \texttt{if..elif}}. If it was the latter, the game is over as before. If it was \texttt{"space"} then move the square to a new random position (and do not move it on every frame!)

Hint, if you are debugging, put you breakpoint inside the \texttt{if} statement, so that the program pauses only once you pressed a key (what happens if you put it on the \texttt{win.flip()} line?)

Put your code into \emph{code10.py}.

\hypertarget{basics-covered}{%
\section{Basics covered}\label{basics-covered}}

There is plenty more to learn about PsychoPy but we've got the basics covered. Submit your files and get ready to \protect\hyperlink{whack-a-mole}{Whack a Mole}!

\hypertarget{whack-a-mole}{%
\chapter{Whack-a-Mole}\label{whack-a-mole}}

Today you will create your first \emph{video} game Whack-a-Mole. The game itself is very much a reaction time experiment: moles/targets appear after a random delay at one of the predefined locations, the player's task is to whack (press a corresponding button) the mole/target before it disappears. Your final game should look approximately like the one in the video: Circles (moles) turn white, if I hit the correct button in time.

Grab the \href{notebooks/Whack-a-mole.ipynb}{exercise notebook} before we start!

\hypertarget{chapter-concepts-4}{%
\section{Chapter concepts}\label{chapter-concepts-4}}

\begin{itemize}
\tightlist
\item
  Storing many items in \protect\hyperlink{lists}{lists}.
\item
  Iterating over items use \protect\hyperlink{for-loop}{for} loop.
\item
  Generating a list of number using \protect\hyperlink{range}{range()}.
\item
  Making \protect\hyperlink{clock-wait}{a pause} and limiting time you \protect\hyperlink{waitKeys-maxwait}{wait for a key}.
\end{itemize}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

So far, we were using variables to store single values: computer's pick, player's guess, number of attempts, PsychoPy window object, etc. But sometimes we need to handle more than one value. We already had this problem in the \protect\hyperlink{guess-the-number-ai}{computer-based Guess-the-Number} game when we needed to store the remaining number range. We got away by using two variables, one for the lower and one for the upper limit. However, this approach clearly does not scale well and, sometimes, we might not even know how many values we will need to store. Python's \href{https://docs.python.org/3/library/stdtypes.html\#lists}{lists} are the solution to the problem.

A list is a mutable\footnote{More on that and tuples (list's immutable cousins) later.} sequence of items where individual elements can be accessed via their zero-based index. Extending the idea of \protect\hyperlink{variables}{variable-as-a-box}, you can think about lists as a box with numbered slots. To store and retrieve a particular piece you will need to know both the \emph{variable name} and the \emph{index of the item} you are interested in within that box. Then, you work with a variable-plus-index in exactly the same way you work with a normal variable, accessing or changing its value via the same syntax as before.

A list is defined via square brackets \texttt{\textless{}variable\textgreater{}\ =\ {[}\textless{}value1\textgreater{},\ \textless{}value2\textgreater{},\ ...\ \textless{}valueN\textgreater{}{]}}. An individual slot within a list is also accessed via square brackets \texttt{\textless{}variable\textgreater{}{[}\textless{}index\textgreater{}{]}} where index is, again, \textbf{zero-based}\footnote{This is typical for ``classic'' programming languages but less so for ones that are linear algebra / data science oriented. Both Matlab and R use one-based indexing, so you need to be careful and double-check whether you are using correct indexes.}. This means that the \emph{first} items is \texttt{variable{[}0{]}} and, if there are \emph{N} items in the list, the last one is \texttt{variable{[}N-1{]}}. You can figure out the total number of items in a list by getting its length via a special \href{https://docs.python.org/3/library/functions.html\#len}{len()} function. Thus, you can access the last item via \texttt{variable{[}len(variable)-1{]}}\footnote{There is a simpler way to do this, which you will learn in a little while.}. Note the \texttt{-1}: If your list has 3 items, the index of the last one is 2, if it has 100, then 99, etc. I am spending so much time on this because it is a fairly common source of confusion.

Do exercise \#1 see how lists are defined and indexed.

Lists also allow you access more than one slot/index at a time via \href{https://docs.python.org/3/library/functions.html\#slice}{slicing}. You can specify index of elements via \texttt{\textless{}start\textgreater{}:\textless{}stop\textgreater{}} notation. For example, \texttt{x{[}1:3{]}} will give you access to two items with indexes 1 and 2. Yes, \emph{two} items: Slicing index goes from the \texttt{start} up to \textbf{but not including} the \texttt{stop}. Thus, if you want to get \emph{all} the items of a list, you will need to write \texttt{x{[}0:length(x){]}} and, yet, to get the last item alone you still write \texttt{x{[}len(x)-1{]}}. Confusing? I think so. I understand the logic but I find this stop-is-not-included to be counterintuitive and I still have to consciously remind myself about this. Unfortunately, this is a standard way to define sequences of numbers in Python, so you need to memorize this.

Do exercise \#2 to build the intuition.

When slicing, you can omit either \texttt{start} or \texttt{stop}. In this case, Python will assume that a missing \texttt{start} means \texttt{0} (the index of the first element) and missing \texttt{stop} means \texttt{len(\textless{}list\textgreater{})} (so, last item is included). If you omit \emph{both}, e.g., \texttt{my\_pretty\_numbers{[}:{]}} it will return all values, as this is equivalent to \texttt{my\_pretty\_numbers{[}0:len(my\_pretty\_numbers){]}}.\footnote{Note, that this is almost but not quite the same thing as just writing \texttt{my\_pretty\_numbers}, as \texttt{my\_pretty\_numbers{[}:{]}} returns a \emph{different} list with \emph{identical} content. The difference is subtle but important and we will return to it later when talking about mutable versus immutable types.}

Do exercise \#3.

You can also use \emph{negative} indexes that are computed relative to length of the list\footnote{If you are coming from R, negative indexing is completely different in Python.}. For example, if you want to get the \emph{last} element of the list, you can say \texttt{my\_pretty\_numbers{[}len(my\_pretty\_numbers)-1{]}} or just \texttt{my\_pretty\_numbers{[}-1{]}}. The last-but-one element would be \texttt{my\_pretty\_numbers{[}-2{]}}, etc. You can use negative indexes for slicing but keep in mind the \emph{including-the-start-but-excluding-the-stop} catch: \texttt{my\_pretty\_numbers{[}:-1{]}} will return all but last element of the list not the entire list!

Do exercise \#4.

Slicing can be extended by specifying a \texttt{step} via \texttt{start:stop:step} notation. \texttt{step} can be negative, allowing you to build indexes in the reverse order:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers[}\DecValTok{4}\NormalTok{:}\DecValTok{0}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} [5, 4, 3, 2]}
\end{Highlighting}
\end{Shaded}

However, you must pay attention to the sign of the step. If it goes in the wrong direction then \texttt{stop} cannot be reached, Python will return an empty list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers[}\DecValTok{4}\NormalTok{:}\DecValTok{0}\NormalTok{:}\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} []}
\end{Highlighting}
\end{Shaded}

Steps can be combined with omitted and negative indexes. To get every \emph{odd} element of the list, you write \texttt{my\_pretty\_numbers{[}::2{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers[::}\DecValTok{2}\NormalTok{]}
\CommentTok{\#\textgreater{} [1, 3, 5, 7]}
\end{Highlighting}
\end{Shaded}

Do exercise \#5.

If you try to to access indexes \emph{outside} of a valid range, Python will raise an \href{https://docs.python.org/3/library/exceptions.html\#IndexError}{IndexError}\footnote{If you are familiar with R and its liberal attitude towards indexes, you will find this very satisfying.}. Thus, trying to get 6\textsuperscript{th} element (index 5) of a five-element-long list will generate a simple and straightforward error. However, if your \emph{slice} is larger than the range, it will be truncated without an extra warning or an error. So, for a five-element list \texttt{my\_pretty\_numbers{[}:6{]}} or \texttt{my\_pretty\_numbers{[}:600{]}} will both return all numbers (effectively, this is equivalent to \texttt{my\_pretty\_numbers{[}:{]}}). Moreover, if the slice is empty (\texttt{2:2}, cannot include 2 because it is a stop value, even though it starts from 2 as well) or the entire slice is outside of the range, Python will return an empty list, again, neither warning or error is generated.

Do exercise \#6.

In Python lists are dynamic, so you can always add or remove elements to it, see \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{the list of methods}. You can add a new item to the of the end of the list via \texttt{.append(\textless{}new\_value\textgreater{})} method

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers.append(}\DecValTok{10}\NormalTok{)}
\NormalTok{my\_pretty\_numbers}
\CommentTok{\#\textgreater{} [1, 2, 3, 4, 5, 6, 7, 10]}
\end{Highlighting}
\end{Shaded}

Or, you can \texttt{insert(\textless{}index\textgreater{},\ \textless{}new\_value\textgreater{})} \emph{before} an element with that index. Unfortunately, this means that you can use an arbitrary large index and it will insert a new value as a \emph{last} element without generating an error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers.insert(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{my\_pretty\_numbers.insert(}\DecValTok{500}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\NormalTok{my\_pretty\_numbers}
\CommentTok{\#\textgreater{} [1, 2, 10, 3, 4, 5, 6, 7, 20]}
\end{Highlighting}
\end{Shaded}

You can remove an item using its index via \texttt{pop(\textless{}index\textgreater{})}, note that the item is \emph{returned} as well. If you omit the index, \texttt{pop()} removes the \emph{last} element of the list. Here, you can only use valid indexes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my\_pretty\_numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{]}
\NormalTok{my\_pretty\_numbers.pop(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\CommentTok{\#\textgreater{} 7}
\NormalTok{my\_pretty\_numbers.pop(}\DecValTok{3}\NormalTok{)}
\CommentTok{\#\textgreater{} 4}
\NormalTok{my\_pretty\_numbers}
\CommentTok{\#\textgreater{} [1, 2, 3, 5, 6]}
\end{Highlighting}
\end{Shaded}

Do exercise \#7.

\hypertarget{basic-game-scaffolding}{%
\section{Basic game scaffolding}\label{basic-game-scaffolding}}

Phew that was \emph{a lot} about lists\footnote{And we barely scratched the surface!}. However, \href{https://en.wikipedia.org/wiki/All_work_and_no_play_makes_Jack_a_dull_boy}{All work and no play makes Jack a dull boy}! So let us start with a basic PsychoPy scaffolding. Here the code structure:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ libraries }\ImportTok{from}\NormalTok{ [psychopy]}
\NormalTok{create the PsychoPy window (visual.Window())}
\NormalTok{flip the window (.flip())}
\NormalTok{wait }\ControlFlowTok{for}\NormalTok{ a player to press the escape key (event.waitKeys())}
\NormalTok{close the window (.close())}
\end{Highlighting}
\end{Shaded}

Try doing it from scratch. I have left hints to help you with this and you can always consult the \href{https://psychopy.org/api/index.html}{online documentation}. Do not forget to document the file and to split your code into meaningful chunks with comments (if needed).

Put your code into \emph{code01.py}.

\hypertarget{three-moles}{%
\section{Three moles}\label{three-moles}}

Let us create three moles that will be represented by \href{https://psychopy.org/api/visual/circle.html\#psychopy.visual.circle.Circle}{circles}. Create a new list variable \texttt{moles} and put three circles into it. One should go to the left, one dead center, and one to the right. Watch a video above to see what I mean. Think of a reasonable size (which \protect\hyperlink{psychopy-units}{units} make keeping circle a circle easier?) and position. You can also use different colors for them, as I did.

You can either create an empty list and then \texttt{.append()} circles one at a time or you can use square brackets to put all three of them into the list in one go. Then \href{https://psychopy.org/api/visual/circle.html\#psychopy.visual.circle.Circle.draw}{draw()} circles before you \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.flip}{flip} the window and wait for a key press. Note that you have to draw them one at a time. Therefore, you will need to add three lines for this but the next section will show you an easier way.

Put your code into \emph{code02.py}.

\hypertarget{for-loop}{%
\section{For loop}\label{for-loop}}

In the code above, we needed to iterate over three moles (circles) that we had in a list. Python has a tool just for that: a
\href{https://docs.python.org/3/tutorial/controlflow.html?highlight=loop\#for-statements}{for loop} that iterates over the items in any sequence (our list is a sequence!). Here is an example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{42}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ a\_number }\KeywordTok{in}\NormalTok{ numbers:}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Value of a\_number variable on this iteration is }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{\%}\NormalTok{(a\_number))}
\NormalTok{    a\_number }\OperatorTok{=}\NormalTok{ a\_number }\OperatorTok{+} \DecValTok{3}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"  Now we incremented it by 3: }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{\%}\NormalTok{(a\_number))}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"  Now we use in a formula a\_number / 10: }\SpecialCharTok{\%g}\StringTok{"}\OperatorTok{\%}\NormalTok{(a\_number }\OperatorTok{/} \DecValTok{10}\NormalTok{))}
\CommentTok{\#\textgreater{} Value of a\_number variable on this iteration is 2}
\CommentTok{\#\textgreater{}   Now we incremented it by 3: 5}
\CommentTok{\#\textgreater{}   Now we use in a formula a\_number / 10: 0.5}
\CommentTok{\#\textgreater{} Value of a\_number variable on this iteration is 4}
\CommentTok{\#\textgreater{}   Now we incremented it by 3: 7}
\CommentTok{\#\textgreater{}   Now we use in a formula a\_number / 10: 0.7}
\CommentTok{\#\textgreater{} Value of a\_number variable on this iteration is 42}
\CommentTok{\#\textgreater{}   Now we incremented it by 3: 45}
\CommentTok{\#\textgreater{}   Now we use in a formula a\_number / 10: 4.5}
\end{Highlighting}
\end{Shaded}

Here, the code inside the \texttt{for} loop is repeated three times because there are three items in the list. On each iteration, next value from the list gets assigned to a temporary variable \texttt{a\_number} (see the output). Once the value is assigned to a variable, you can use it just like any variable. You can print it out (first \texttt{print}), you can modify it (second line within the loop), use its value for when calling other functions, etc. To better appreciate this, copy-paste this code into a temporary file (call it \texttt{test01.py}), put a \protect\hyperlink{debugging}{breakpoint} onto the first \texttt{print} statement and then use \textbf{F10} to step through the loop and see how value of \texttt{a\_number} variable changes on each iteration and then it gets modified in the second line within the loop.

Note that you can use the same \href{https://docs.python.org/3/tutorial/controlflow.html?highlight=loop\#break-and-continue-statements-and-else-clauses-on-loops}{break} statement as for the \href{https://docs.python.org/3/reference/compound_stmts.html\#the-while-statement}{while} loop.

Do exercise \#8.

\hypertarget{drawing-in-a-loop}{%
\section{Drawing in a loop}\label{drawing-in-a-loop}}

Now that you have learned about the \protect\hyperlink{for-loop}{for} loop, it is easy to draw the moles. Just iterate over the list (come up with a good temporary variable name) and \texttt{draw()} a current item (which is in your temporary variable).

Put your code into \emph{code03.py}.

\hypertarget{range}{%
\section{range() function: Repeating code N times}\label{range}}

Sometimes, you might need to repeat the code several times. For example, imagine that you have 40 trials in an experiment. Thus, you need to repeat a trial-related code 40 times. You can, of course, build a list 40 items long by hand and iterate over it but Python has a handy \href{https://docs.python.org/3/tutorial/controlflow.html?highlight=loop\#the-range-function}{range()} function for that. \texttt{range(N)} yields N integers from 0 to N-1 (same up-to-but-not-including rule as for slicing) that you can iterate over in a for loop.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{3}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"Value of x is }\SpecialCharTok{\%d}\StringTok{"}\OperatorTok{\%}\NormalTok{(x))}
\CommentTok{\#\textgreater{} Value of x is 0}
\CommentTok{\#\textgreater{} Value of x is 1}
\CommentTok{\#\textgreater{} Value of x is 2}
\end{Highlighting}
\end{Shaded}

You can modify \href{https://docs.python.org/3/library/stdtypes.html\#range}{range()} function behavior by providing a starting value and a step size. But in its simplest form \texttt{range(N)} is a handy tool to repeat the code that many times. Note that while you always need to have a temporary variable in a \texttt{for} loop, sometimes you may not use it at all. In cases like this, you should use \texttt{\_} (underscore symbol) as a variable name to indicate the lack of use.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ \_ }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"I will be repeated twice!"}\NormalTok{)}
\CommentTok{\#\textgreater{} I will be repeated twice!}
\CommentTok{\#\textgreater{} I will be repeated twice!}
\end{Highlighting}
\end{Shaded}

Alternatively, you can use \texttt{range()} to loop through indexes of a list (remember, you can always access an individual list item via \texttt{var{[}index{]}}). Do exactly that\footnote{Note, this is not a \emph{better} way but an \emph{alternative} way to do this.}! Modify your code to use \href{(https://docs.python.org/3/library/stdtypes.html\#range)}{range()} function in the for loop (how can you compute the number of iterations from the length of the list?), use temporary variable as an index for the list to draw each item\footnote{Style hint: if a variable is an \emph{index} of something, I tend to call it \texttt{isomething}. E.g., if it holds an index to a current mole, I would call it \texttt{imole}. This is \emph{my} way of doing it. Others use \texttt{i\_} prefix or an \texttt{\_i} suffix. But either way, it is a useful naming convention. Remember, the easier it is to understand the meaning of a variable from its name, the easier it is for you to read and modify the code.}. When in doubt, put a breakpoint inside (or just before) the loop and step through your code to understand what values a temporary loop variable gets and how it is used.

Put your modified code into \emph{code04.py}.

\hypertarget{random-mole}{%
\section{A random mole}\label{random-mole}}

Drawing all three moles served as a practical exercise with loops but in a real game we need to shown only one random target at a time. We could create the three targets as before and draw one of them. However, later on we would like to change the color of the target to indicate that the player did hit it, so it is simpler (if a bit wasteful) to create a single mole every time we need one.

For this, define one \protect\hyperlink{constants}{CONSTANT} with a list of three colors that you used and another one with three horizontal locations (the vertical location is the same, so we do not need to worry about it). Next, randomly pick which target out of three you want to create, i.e., we need to generate an \emph{index} of the target. You can do it either via \href{https://docs.python.org/3/library/random.html\#random.randrange}{random.randrange()} or via \href{https://docs.python.org/3/library/random.html\#random.choice}{random.choice()} building the range yourself via \href{}{the function with the same name} you have just learned about (remember to organize your imports alphabetically). Store the index in a variable with a meaningful name\footnote{\texttt{itarget}? \texttt{imole}?} and use it with constants to create the target of the corresponding color at a corresponding location. Then, you need to draw that single target before waiting for a key press.

Once you have the code, put a breakpoint and check that the value of the index variable matches what is shown on a screen\footnote{I know it feels redundant but these are little checks that cost little time by themselves but help you avoid wasting lots of time on tracing weird mistakes. Here, you check that your expectations (if the middle target is shown, the index should be 1) match the reality. Once you check this, you do not \emph{expect} it to be true, you \emph{know} it to be true!}.

Put your modified code into \emph{code05.py}.

\hypertarget{clock-wait}{%
\section{Random time}\label{clock-wait}}

What makes Whack-a-Mole game fun is not only that you do not know \emph{which} mole will appear but you also do not know \emph{when} it will appear and \emph{how much time} you have to whack it. Thus, we need to modify our presentation schedule. We need a blank period of a random duration (I would suggest between 0.75 s to 1.5 s) and limited presentation duration (between 0.5 to 0.75 s). First, you need to define these ranges as \protect\hyperlink{constants}{constants}. Now that you know lists you can use a single variable to hold both ends of the range. Then, you need to generate two numbers (one for the blank another for the presentation) coming from \href{https://docs.python.org/3/library/random.html\#random.uniform}{a uniform distrubition} within that range. Finally, you need to time your blank and presentation using the \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait()} function from the \href{https://psychopy.org/api/clock.html}{clock} module.

Now is time to update and structure you code. Here is a approximate outline (note that I have dropped the wait for keys):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{"""Document your file}
\CommentTok{"""}
\ImportTok{import} \BuiltInTok{all}\NormalTok{ libaries you need }\KeywordTok{in}\NormalTok{ an alphabetical order}

\NormalTok{define CONSTANTS}

\NormalTok{create window}

\CommentTok{\# generating random parameters for the trial}
\NormalTok{pick random index }\ControlFlowTok{for}\NormalTok{ the mole}
\NormalTok{create the mole}
\NormalTok{generate random durations }\ControlFlowTok{for}\NormalTok{ blank }\KeywordTok{and}\NormalTok{ presentation interval}

\CommentTok{\# blank}
\NormalTok{clear window (win.flip() alone)}
\NormalTok{wait }\ControlFlowTok{for} \StringTok{"blank duration"}\NormalTok{ seconds}

\CommentTok{\# presentation}
\NormalTok{draw the mole}
\NormalTok{wait }\ControlFlowTok{for} \StringTok{"presentation duration"}\NormalTok{ seconds}

\NormalTok{close the window}
\end{Highlighting}
\end{Shaded}

Note that it has no response processing at the moment and that window should close right after the stimulus is presented.

Put your code into \emph{code06.py}.

\hypertarget{repeating-trials}{%
\section{Repeating trials}\label{repeating-trials}}

You already know how to \protect\hyperlink{range}{repeat} the same code many times. Decide on number of trials / rounds (define this as a constant) and repeat the single round that many times. Think about what code goes inside the loop and what should stay outside for the randomization to work properly.

Put your code into \emph{code07.py}.

\hypertarget{waitKeys-maxwait}{%
\section{Exit strategy}\label{waitKeys-maxwait}}

I hope that you used a small number of trials because (on my advice, yes!) we did not program a possibility to exit the game via the \textbf{escape} key. To put it in, we will replace \emph{both} \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait()} calls with \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} function. It has \texttt{maxWait} parameter that by default is set to infinity but can be set to the duration we require. If a player does not press a key, it will work just like \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait()} did. If a player presses a key (allow only \texttt{"escape"} for now), it means that they want to abort the game (the only possible action at the moment). Thus, assign the returned value to a temporary variable (\texttt{keys}?) and check whether it is equal to \texttt{None}\footnote{Confusingly, if no key was pressed, \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{getKeys()} returns an empty list that has length of zero but \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} returns \texttt{None} and \texttt{None} has no length.}. If it is not equal to \texttt{None}, \protect\hyperlink{break}{break} out of the loop!

Put your code into \emph{code08.py}.

\hypertarget{whacking-that-mole}{%
\section{Whacking that mole}\label{whacking-that-mole}}

We have moles that appear at a random location after a random delay for a random period of time. Now we just need to add an ability to whack 'em! You whack a mole only when it is present. Thus, we only need to modify and handle the \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} call for the presentation interval.

First, create a new constant with three keys that correspond to three locations. I would suggest using \texttt{{[}"left",\ "down",\ "right"{]}}, which are cursor keys\footnote{Want to know key codes for sure? Write a small program that opens a window and then repeatedly waits for any key press and prints out into console.}. Next, you need to use them for the \texttt{keyList} parameter. However, we cannot use this list directly, as we also need the \textbf{escape} key. The simplest way is to put ``escape'' into its own list and concatenate the two lists via \texttt{+}: \texttt{{[}"escape"{]}\ +\ YOUR\_CONSTANT\_WITH\_KEYS}. Do this concatenation directly when you set a value to the \texttt{keyList} in the function call. Before we continue, run the code and test that you can abort the program during the presentation (but not during the blank interval) by pressing any of these three keys. Also check that \textbf{escape} still works!

Now that we have keys to press, we need more sophisticated processing (we gonna have quite a few nested conditional statements). We still need to check whether \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} returned \texttt{None} first. If it did not, it must have returned a list of pressed keys. Actually, it will be a list with just a single item\footnote{You will get more than one item in that list only if you set \texttt{clearEvents=False}. In this case, you will get the list of keys pressed before the call. However, if you opted for a default \texttt{clearEvents=True}, you will get only one key press in the list (at least I was never able to get more than one).}, so we can work with it directly via \texttt{keys{[}0{]}}. Use conditional \protect\hyperlink{if-statement}{if-else statement} to break out of the loop if the player pressed \textbf{escape}. Otherwise, it was one of the three ``whack'' keys.

Our next step is to establish which index the key corresponds to. Python makes it extremely easy as lists have \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{.index(value)} method that returns the index of the value within the list. You have the (CONSTANT) list with the keys and you have the pressed key: Figure out the index and check whether it matches the index of the target (\texttt{imole} variable in my code). If it does, let us provide a visual feedback of success: change mole (circle) \texttt{fillColor} to white, draw it, and \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait} for 300 ms (setup a constant for feedback duration). This way, the mole will turn white and remain briefly on the screen when hit but will disappear immediately, if you missed.

Put your code into \emph{code09.py}.

\hypertarget{you-did-it}{%
\section{You did it!}\label{you-did-it}}

Congratulations on your first video game! It could use some bells-and-whistles like having a score, combos would be cool, proper mole images instead circle, etc. but it works and it is fun (if you do not feel challenged, reduce the presentation time)! Submit your files and next time we will ditch the keyboard and learn how to handle the mouse in the Memory game.

\hypertarget{memory-game}{%
\chapter{Memory game}\label{memory-game}}

Today, you will write a good old \emph{Memory} game: Eight cards are lying ``face down'', you can turn any two of them and, if they are identical, they are taken off the table. If they are different, the cards turn ``face down'' again.

Before we start, create a new folder for the game and create a subfolder \emph{Images} in it. Then, download \href{material/chicken.zip}{images of chicken}\footnote{The images are courtesy of \href{https://openclipart.org/artist/Firkin}{Kevin David Pointon} and were downloaded
  from \href{https://openclipart.org/}{OpenClipart}. They are \href{https://creativecommons.org/publicdomain/zero/1.0/}{public domain} and can be used and distributed freely.} that we will use for the game and unzip them into \emph{Images} subfolder. Also, grab the \href{notebooks/Memory\%20game.ipynb}{exercise notebook}!

\hypertarget{chapter-concepts-5}{%
\section{Chapter concepts}\label{chapter-concepts-5}}

\begin{itemize}
\tightlist
\item
  \protect\hyperlink{mutable-objects}{Mutable} vs.~\protect\hyperlink{variables-as-boxes-immutable-objects}{immutable} objects
\item
  Showing \protect\hyperlink{imagestim}{images}.
\item
  Working with files via \protect\hyperlink{os-library}{os} library.
\item
  Using other \protect\hyperlink{dictionaries}{dictionary} containers.
\item
  \protect\hyperlink{list-operations}{List operations}.
\item
  Looping over both index and item via list \protect\hyperlink{enumerate}{enumeration}.
\end{itemize}

\hypertarget{variables-as-boxes-immutable-objects}{%
\section{Variables as Boxes (immutable objects)}\label{variables-as-boxes-immutable-objects}}

In this game, you will use \protect\hyperlink{dictionaries}{dictionaries}. These are \emph{mutable}, like \protect\hyperlink{lists}{lists} in contrast to ``normal'' \emph{immutable} values (integers, floats, strings). You need to learn about this distinction as these two kinds of objects (values) behave very differently under some circumstances, which is both good (power!) and bad (weird unexpected behavior!) news.

You may remember the \emph{variable-as-a-box} metaphor that I used it to introduce \protect\hyperlink{variables}{variables}. In short, a variable can be thought of as a ``box'' with a variable name written on it and a value being stored ``inside''. When you use this value or assign it to a different variable, you can assume that Python \emph{makes a copy} of it\footnote{Not really, but this makes it easier to understand.} and puts that \emph{copy} into a different variable ``box''. When you \emph{replace} value of a variable, you take out the old value, destroy it (by throwing it into a nearest black hole, I assume), create a new one, and put it into the variable ``box''. When you \emph{change} a variable based on its current state, the same thing happens. You take out the value, create a new value (by adding to the original one or doing some other operation), destroy the old one, and put the new one back into the variable ``box''. The important point is that although a \emph{variable} can have different immutable values (we \protect\hyperlink{random-mole}{changed} \texttt{imole} variable on every round), the immutable \emph{value} itself never changes. It gets \emph{replaced} with another immutable value but \emph{never changes}\footnote{A metaphor attempt: You can wear different shirts, so your \emph{look} (variable) changes but each individual shirt (potential values) remains the same (we ignore the wear and tear here) irrespective of whether your are wearing it (value is assigned to a variable) or not.}.

The box metaphor explains why the \protect\hyperlink{scopes-for-immutable-values}{scopes} work the way they do. Each scope has its own set of boxes and whenever you pass information between scopes, e.g., from a global script to a function, a copy of a value (from a variable) is created and put into a new box (e.g., a parameter) inside the function. When a function returns a value, it is copied and put in one of the boxes in the global script (variable you assigned the returned value to), etc.

However, this is true only for \emph{immutable} objects (values) such as numbers, strings, logical values, etc. but also \href{https://docs.python.org/3/library/stdtypes.html?highlight=tuple\#tuple}{tuples} (see below for what these are). As you could have guessed from the name, this means that there are other \emph{mutable} objects and they behave very differently.

\hypertarget{mutable-objects}{%
\section{Variables as post-it stickers (mutable objects)}\label{mutable-objects}}

Mutable objects are for example lists or dictionaries\footnote{Coming up shortly!}, i.e., things that can change. The key difference is that \emph{immutable} objects can be thought as fixed in their size. A number takes up that many bytes to store, same goes for a given string (although a different string would require more or fewer bytes). Still, they do not change, they are created and destroyed when unneeded but never truly updated.

\emph{Mutable} objects can be changed\footnote{Building on the looks metaphor: You can change your look by using a different (immutable) shirt or by \emph{changing} your haircut. You hair is mutable, you do not wear a different one on different days to look different, you need to modify it to look different.}. For example, you can add elements to your list, or remove them, or shuffle them. Same goes for \href{https://docs.python.org/3/tutorial/datastructures.html?highlight=dictionary\#dictionaries}{dictionaries}. Making such object \emph{immutable} would be computationally inefficient: Every time you add a value a (long) list is destroyed and recreated with just that one additional value. Which is why Python simply \emph{updates} the original object. For further computation efficiency, these objects are not copied when you assign them to a different variable or use as a parameter value but \emph{passed by reference}. This means that the variable is no longer a ``box'' you put values into but a ``sticker'' you put on an object (a list, a dictionary). And you can put as many stickers on an object as you want \emph{and it still will be the same object}!

What on Earth do I mean? Keeping in mind that a variable is just a sticker (one of many) for a mutable object, try figuring out what will be the output below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=}\NormalTok{ x}
\NormalTok{y.append(}\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#1.

Huh? That is precisely what I meant with ``stickers on the same object''. First, we create a list and put an \texttt{x} sticker on it. Then, we assign \emph{the same list} to \texttt{y}, in other words, we put a \texttt{y} sticker on the same list. Since both \texttt{x} and \texttt{y} are stickers on the \emph{same} object, they are, effectively, synonyms. In that specific situation, once you set \texttt{x\ =\ y}, it does not matter which variable name you use to change \emph{the} object, they are just two stickers hanging side-by-side on the \emph{same} list. Again, just a reminder, this is \emph{not} what would happen for \emph{immutable} values, like numbers, where things would behave the way you expect them to behave.

This variable-as-a-sticker, a.k.a. ``passing value by reference'', has very important implications for function calls, as it breaks your scope without ever giving you a warning. Look at the code below and try figuring out what the output will be.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ change\_it(y):}
\NormalTok{    y.append(}\DecValTok{4}\NormalTok{)}

\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{change\_it(x)}
\BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

Do exercise \#2.

How did we manage to modify a \emph{global} variable from inside the function? Didn't we change the \emph{local} parameter of the function? Yep, that is exactly the problem with passing by reference. Your function parameter is yet another sticker on the \emph{same} object, so even though it \emph{looks} like you do not need to worry about global variables (that's why you wrote the function and learned about scopes!), you still do. If you are perplexed by this, you are in a good company. This is one of the most unexpected and confusing bits in Python that routinely catches people\footnote{Well, at least me!} by surprise. Let us do a few more exercises, before I show you how to solve the scope problem for mutable objects.

Do exercise \#3.

\hypertarget{tuple}{%
\section{Tuple: a frozen list}\label{tuple}}

The wise people who created Python were acutely aware of the problem that the \emph{variable-as-a-sticker} creates. Which is why, they added an \textbf{immutable} version of a list, called a \href{https://docs.python.org/3/library/stdtypes.html?highlight=tuple\#tuple}{tuple}. It is a ``frozen'' list of values, which you can loop over, access its items by index, or figure out how many items it has, but you \emph{cannot modify it}. No appending, removing, replacing values, etc. For you this means that a variable with a frozen list is a box rather than a sticker and that it behaves just like any other ``normal'' \textbf{immutable} object. You can create a \texttt{tuple} by using round brackets.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can loop over it, e.g.,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ number }\KeywordTok{in}\NormalTok{ i\_am\_a\_tuple:}
    \BuiltInTok{print}\NormalTok{(number)}
\CommentTok{\#\textgreater{} 1}
\CommentTok{\#\textgreater{} 2}
\CommentTok{\#\textgreater{} 3}
\end{Highlighting}
\end{Shaded}

but, as I said, appending will throw a mistake

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\CommentTok{\# throws AttributeError: \textquotesingle{}tuple\textquotesingle{} object has no attribute \textquotesingle{}append\textquotesingle{}}
\NormalTok{i\_am\_a\_tuple.append(}\DecValTok{4}\NormalTok{)}
\CommentTok{\#\textgreater{} Error in eval(expr, p): AttributeError: \textquotesingle{}tuple\textquotesingle{} object has no attribute \textquotesingle{}append\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Same goes for trying to change it

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i\_am\_a\_tuple }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}

\CommentTok{\# throws TypeError: \textquotesingle{}tuple\textquotesingle{} object does not support item assignment}
\NormalTok{i\_am\_a\_tuple[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{1} 
\CommentTok{\#\textgreater{} Error in eval(expr, p): TypeError: \textquotesingle{}tuple\textquotesingle{} object does not support item assignment}
\end{Highlighting}
\end{Shaded}

This means that when you need to pass a list of values to a function and you want them to have no link to the original variable, you should instead pass \emph{a tuple of values} to the function. The function still has a list of values but the link to the original list object is now broken. You can turn a list into a tuple using \texttt{tuple()}. Keeping in mind that \texttt{tuple()} creates a frozen copy of the list, what will happen below?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{y }\OperatorTok{=} \BuiltInTok{tuple}\NormalTok{(x)}
\NormalTok{x.append(}\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

Do exercise \#4.

As you probably figured out, when \texttt{y\ =\ tuple(x)}, Python creates \textbf{a copy} of the list values, freezes them (they are immutable now), and puts them into the ``y'' box. Hence, whatever you do to the original list, has no effect on the immutable ``y''.

Conversely, you ``unfreeze'' a tuple by turning it into a list via \texttt{list()}. Please note that it creates \textbf{a new list}, which has no relation to any other existing list, even if values are the same or were originally taken from any of them!

Do exercise \#5.

Remember I just said that \texttt{list()} creates a new list? This means that you can use it to create a copy of a list directly, without an intermediate tuple step. This way you can two \emph{different} lists with \emph{identical} values. You can also achieve the same results by slicing an entire list, e.g.~\texttt{list(x)}, is the same as \texttt{x{[}:{]}}.

Do exercise \#6.

Here, \texttt{y\ =\ list(x)} created a new list (which was a carbon copy of the one with the ``x'' sticker on it) and the ``y'' sticker was put on that new list, while the ``x'' remained hanging on the original.

Confusing? You bet! If you feel overwhelmed by this whole immutable/mutable, tuple/list, copy/reference confusion, you are just being a normal human being. I understand the (computational) reasons for doing things this way, I am aware of this difference and how useful this can be but it still catches me by surprise from time to time!

\hypertarget{minimal-code}{%
\section{Minimal code}\label{minimal-code}}

Enough of theory, let us get busy writing the game. As usual, let us start with a minimal code (try doing it from scratch instead of copy-pasting from the last game):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{importing psychopy modules that we need}
 
\NormalTok{creating a window of a useful size }\KeywordTok{and}\NormalTok{ useful units}

\NormalTok{waiting }\ControlFlowTok{for}\NormalTok{ a key press}

\NormalTok{closing the window}
\end{Highlighting}
\end{Shaded}

The first thing you need to decide on is the window size \emph{in pixels} and which units would sizing and placing cards easier. Each chicken image is 240×400 pixels and, for the game, we need place for \emph{exactly} 4×2 images, i.e.~our window must be 4 cards wide and 2 cards high. Do not forget to document the file!

Put your code into \texttt{code01.py}.

\hypertarget{imagestim}{%
\section{Drawing an image}\label{imagestim}}

We used (abstract and boring) circles to represent moles but today we will use actual images of chicken (see instructions above on downloading them). Using an \href{https://psychopy.org/api/visual/imagestim.html}{image stimulus} in PsychoPy is very straightforward because it behaves very much like other visual stimuli you already know. First, you need to create an new object by calling \texttt{visual.ImageStim(...)}. You can find the complete list of parameters in the \href{(https://psychopy.org/api/visual/imagestim.html)}{documentation} but for our initial intents and purposes, we only need to pass three of them:

\begin{itemize}
\tightlist
\item
  our window variable: \texttt{win}.
\item
  image file name: \texttt{image="Images/r01.png"} (images are in a subfolder and therefore we need to use a relative path).
\item
  size: \texttt{size=(???,\ ???)}. That is one for you to compute. If you picked \protect\hyperlink{psychopy-units-norm}{norm} units, as I did, then window is 2 units wide and 2 units high but for \protect\hyperlink{psychopy-units-height}{height} it is 1 units height and \emph{aspect-ratio} units wide. We want to have a 4×2 images, what is the size (both width and height) of each image in the units of your choice?
\end{itemize}

Draw chicken image (it should appear at the center of the screen).

Put your code into \texttt{code02.py}.

\hypertarget{placing-an-image-index-to-position}{%
\section{Placing an image (index to position)}\label{placing-an-image-index-to-position}}

By default, our image is placed at the center of the screen, which is a surprisingly useful default for a typical psychophysical experiment that shows stimuli at fixation (which is also, typically, at the center of the screen). However, we will need to draw eight images, each at its designated location. You need to create a function that takes an image index (it goes 0 to 7) and returns a list with pair of values with its location on the screen. Below is a sketch of how index correspond to the location. Note that image location (\href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim.pos\%20attribute}{pos} corresponds to the \emph{center} of the image.

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{images/memory-location-index.png}
\caption{Card location index}
\end{figure}

Name the function \texttt{position\_from\_index}. It should take one argument (\texttt{index}) and return a list with \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} coordinates in the PsychoPy units (from now on I assume that these are \protect\hyperlink{psychopy-units-norm}{norm}). You can then use this value for the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim.pos}{pos} argument of the \href{https://psychopy.org/api/visual/imagestim.html\#imagestim}{ImageStim()}.

The computation might look complicated, so let me get you started. How can you compute \emph{x} coordinate for the \emph{top} row? Concentrating on the top row alone makes things simpler because here the \emph{column index} is the same as the overall index: The left-most column is 0, the next one is 1, etc. You need a simple algebra of \(x = a_x + b_x \cdot column\). You can easily deduce out both \(a_x\) and \(b_x\) if you figure out locations of the first and second cards by hand. Same goes for the \emph{y} coordinate. Assuming that you know the \emph{row}, which is either 0 (top row) or 1 (bottom row), you can compute \(y = a_y + b_y \cdot row\).

But, I hear you say, you do not have row and column indexes, only the overall index! To compute those you only need to keep in mind that each row has \emph{four} cards. Then, you can make use of two special division operators: \href{https://python-reference.readthedocs.io/en/latest/docs/operators/floor_division.html}{floor division operator \texttt{//}} and \href{https://python-reference.readthedocs.io/en/latest/docs/operators/modulus.html}{modulos, divison remainder \texttt{\%}} operators. The former returns only the integer part of the division, so that \texttt{4\ //\ 3} is \texttt{1} (because 4/3 is 1.33333) and \texttt{1\ //\ 4} is \texttt{0} (because 1/4 is 0.25). The latter returns the remaining integers, so that \texttt{4\ \%\ 3} is \texttt{1} and \texttt{1\ \%\ 4} is \texttt{0}.

My suggestion would be first to play with individual formulas in Jupyter Notebook, which makes it easier to try out (dividing) things and seeing the result, putting various values into formulas, etc. Once you are confident that the code is working, turn it into a function, document it, and put into a separate file (\emph{utilities.py}, do not forget to put a comment at the top of the file as well!). You can then import it in the main script and use it to place the card. Try out different indexes and make sure that the card appears where it should. Remember, put a breakpoint and step through the program while watching variables, if things do not work as you expected.

Put \texttt{position\_from\_index} into \texttt{utilities.py}.
Put update code into \texttt{code03.py}

\hypertarget{backside-of-the-card}{%
\section{Backside of the card}\label{backside-of-the-card}}

A chicken image is a card \emph{face} but the game starts with the cards face down, so the player should see their backs. We will use a plain \href{https://psychopy.org/api/visual/rect.html}{rectangle} as a backside. Pick a nice looking combination of \texttt{fillColor} (inside) and \texttt{lineColor} (contour) colors. Modify your code, to draw image (face of the card) and rectangle (back of the card) side-by-side (\emph{e.g.}, if face is at position with index 0, rectangle should be at position 1 or 4). This way you can check that sizes match and that they are positioned correctly.

Put your code into \texttt{code04.py}.

\hypertarget{dictionaries}{%
\section{Dictionaries}\label{dictionaries}}

Each card that we use has plenty of properties: A front (image), a back (rectangle), and will have other properties such as which side should be shown or whether card is already taken off the screen. This calls for a container, so we could put all these relevant bits into a single variable. We \emph{could} put these values into a list and use numerical indexes to access individual elements (e.g., \texttt{card{[}0{]}} would be front image but \texttt{card{[}2{]}} would indicate the active side) but indexes do not have meaning per se, so figuring out how \texttt{card{[}0{]}} is different from \texttt{card{[}2{]}} would be tricky. Python has a solution for cases like this: \href{https://docs.python.org/3/library/stdtypes.html\#dict}{dictionaries}.

A dictionary is a container that stores information using \emph{key : value} pairs. This is similar to how you look up a meaning or a translation (value) of a word (key) in a real dictionary, hence the name. To create a dictionary, you use \emph{curly} brackets \texttt{\{\textless{}key1\textgreater{}\ :\ \textless{}value1\textgreater{}\},\ \{\textless{}key2\textgreater{}\ :\ \textless{}value2\textgreater{},\ ...\}} or create it via \texttt{dict(\textless{}key1\textgreater{}=\textless{}value1\textgreater{},\ \textless{}key2\textgreater{}=\textless{}value2\textgreater{},\ ...)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{book }\OperatorTok{=}\NormalTok{ \{}\StringTok{"Author"}\NormalTok{ : }\StringTok{"Walter Moers"}\NormalTok{,}
        \StringTok{"Title"}\NormalTok{: }\StringTok{"Die 13½ Leben des Käpt\textquotesingle{}n Blaubär"}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Once you created a dictionary, you can access or modify each field using its key, \emph{e.g.} \texttt{print(book{[}"Author"{]})} or \texttt{book{[}"Author"{]}\ =\ "Moers,\ W."}. You can also add new fields by assigning values to them, e.g., \texttt{book{[}"Publication\ year"{]}\ =\ 1999}. In short, you can use a combination of \texttt{\textless{}dictionary-variable\textgreater{}{[}\textless{}key\textgreater{}{]}} just like you would use a normal variable. This is similar to using the \texttt{list{[}index{]}} combination, the only difference is that \texttt{index} must be an integer, whereas \texttt{key} can be any hashable\footnote{Immutable values are \href{https://docs.python.org/3/glossary.html\#term-hashable}{hashable}, whereas mutable ones, like dictionaries and lists, are not. This is because mutable objects can \emph{change} while the program is running and therefore are unusable as a key. I.e., it is hard to match by a key, if the key can be different by the time you need to access the dictionary.} value.

\hypertarget{using-a-dictionary-to-represent-a-card}{%
\section{Using a dictionary to represent a card}\label{using-a-dictionary-to-represent-a-card}}

Our card has the following properties, so these will be key-value entries in a dictionary

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{"front"}: front side (image of a chicken).
\item
  \texttt{"back"}: back side (rectangle).
\item
  \texttt{"filename"}: identity on the card that we will use later to check whether the player opened two identical cards (their filenames match) or two different ones.
\item
  \texttt{"side"}: can be either \texttt{"front"} or \texttt{"back"}, information about which side is up (drawn on the screen). Set it to \texttt{"back"} because, initially, all cards are face down. However, you can always set it temporarily to \texttt{"front"} to see how the cards are distributed.
\item
  \texttt{"show"}: a logical value, set it to \texttt{True}. We will use it later to mark out cards that are off the table and are, therefore, not shown. Initially, all cards are shown, so all cards should be created with \texttt{"show"} being equal to \texttt{True}.
\end{enumerate}

Create a dictionary variable (name it \texttt{card}) and fill it with relevant values (use either \texttt{"front"} and ``\texttt{back"} for \texttt{"side"} key) and stimuli (you can put PsychoPy stimuli into a dictionary just like we put them into a list earlier). Modify your code so that it draws the correct image based on the value of the \texttt{"side"} entry. Note that you \textbf{do not need an if-statement for this}! Think about a key you need to access these two sides and the value that you have in for the \texttt{"side"} key.

Put your code into \texttt{code05.py}.

\hypertarget{card-factory}{%
\section{Card factory}\label{card-factory}}

You have the code to create one card but we need eight of them. This definitely calls for a function. Write a function (put it into \texttt{utilities.py} to declutter the main file) that takes three parameters

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  a window variable (you need it to create PsychoPy stimuli),
\item
  a filename,
\item
  card position index,
\end{enumerate}

and returns a dictionary, just like the one you created. You very much have the code, you only need to wrap it into a function and document it. Call function \texttt{create\_card} and use it in the main script to create \texttt{card} dictionary. Think about libraries you will now need to import in \emph{utilities.py}.

Put \texttt{create\_card} into \texttt{utilities.py}.
Put code into \texttt{code06.py}.

\hypertarget{getting-a-list-of-files}{%
\section{Getting a list of files}\label{getting-a-list-of-files}}

For a single card, we simply hard-coded the name of an image file, as well as its location. However, for a real game (or an experiment) we would like to be more flexible and automatically determine which files we have in the \emph{Images} folder. This is covered by \href{https://docs.python.org/3/library/os.html}{os} library that contains various utilities for working with your operating system and, in particular, with files and directories. Specifically, \href{https://docs.python.org/3/library/os.html\#os.listdir}{os.listdir(path=``.'')} returns a list with filenames of \emph{all} the files in a folder specified by path. By default, it is a current path (\texttt{path="."}). However, you can use either a relative path - \texttt{os.listdir("Images")}, assuming that \emph{Images} is a subfolder in your current directory - or an absolute path \texttt{os.listdir("E:/Teaching/Python/MemoryGame/Images")} (in my case)\footnote{Use absolute path only if it is the only option, as it will almost certainly will break your code on another machine.}.

Try this out in a Jupyter Notebook (do not forget to import the \href{https://docs.python.org/3/library/os.html\#module-os}{os} library). You should get a list of 8 files that are coded as \emph{{[}r\textbar l{]}{[}index{]}.png}, where \emph{r} or \emph{l} denote a direction the chicken is looking. However, for our game we need only four images (4 × 2 = 8 cards). Therefore, we need to select a subset of them, e.g., four random cards, chicken looking to the left or to the right only. Here, let us work with chicken looking to the left, meaning that we need to pick only files that start with ``l''. To make this filtering easier, we will use a cool Python trick called \href{https://docs.python.org/3/tutorial/datastructures.html\#list-comprehensions}{list comprehensions}.

\hypertarget{list-comprehension}{%
\section{List comprehension}\label{list-comprehension}}

List comprehension provides an elegant and easy-to-read way to create, modify and/or filter elements of the list creating a new list. The general structure is

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new\_list }\OperatorTok{=}\NormalTok{ [}\OperatorTok{\textless{}}\NormalTok{transform}\OperatorTok{{-}}\NormalTok{the}\OperatorTok{{-}}\NormalTok{item}\OperatorTok{\textgreater{}} \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ old\_list }\ControlFlowTok{if} \OperatorTok{\textless{}}\NormalTok{condition}\OperatorTok{{-}}\NormalTok{given}\OperatorTok{{-}}\NormalTok{the}\OperatorTok{{-}}\NormalTok{item}\OperatorTok{\textgreater{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Let us look at examples to understand how it works. Imagine that you have a list \texttt{numbers\ =\ {[}1,\ 2,\ 3{]}} and you need increment each number by 1\footnote{A very arbitrary example!}. You can do it by creating a new list and adding 1 to each item in the part:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_plus\_1 }\OperatorTok{=}\NormalTok{ [item }\OperatorTok{+} \DecValTok{1} \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers]}
\end{Highlighting}
\end{Shaded}

Note that this is equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_plus\_1 }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers:}
\NormalTok{    numbers\_plus\_1.append(item }\OperatorTok{+} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Or, imagine that you need to convert each item to a string. You can do it simply as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_as\_strings }\OperatorTok{=}\NormalTok{ [}\BuiltInTok{str}\NormalTok{(item) }\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers]}
\end{Highlighting}
\end{Shaded}

What would be an equivalent form using a normal for loop? Write both versions of code in Jupiter cells and check that the results are the same.

Do exercise \#7 in Jupyter notebook.

Now, implement the code below using list comprehension. Check that results match.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{strings }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{]}
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ astring }\KeywordTok{in}\NormalTok{ strings:}
\NormalTok{    numbers.append(}\BuiltInTok{int}\NormalTok{(astring) }\OperatorTok{+} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Do exercise \#8 in Jupyter notebook.

As noted above, you can also use a conditional statement to filter which items are passed to the new list. In our numbers example, we can retain numbers that are greater than 1

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_greater\_than\_1 }\OperatorTok{=}\NormalTok{ [item }\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers }\ControlFlowTok{if}\NormalTok{ item }\OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Sometimes, the same statement is written in three lines, instead of one, to make reading easier:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{numbers\_greater\_than\_1 }\OperatorTok{=}\NormalTok{ [item }
                          \ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ numbers}
                          \ControlFlowTok{if}\NormalTok{ item }\OperatorTok{\textgreater{}} \DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

You can of course combine the transformation and filtering in a single statement. Create code that filters out all items below 2 and adds 4 to them.

Do exercise \#9 in Jupyter notebook.

\hypertarget{getting-list-of-relevant-files}{%
\section{Getting list of relevant files}\label{getting-list-of-relevant-files}}

Use list comprehension to create a list of files of chicken looking left, \emph{i.e.} with filenames that start with ``l''. Use \href{https://docs.python.org/3/library/stdtypes.html\#str.startswith}{.startswith()} to check whether it starts with ``l'', store the list in \texttt{filenames} variable. Test your code in a Jupyter Notebook. You should get a list of four files.

\hypertarget{list-operations}{%
\section{List operations}\label{list-operations}}

Our list consists of four unique filenames but in the game each card should appear twice. There are several ways of duplicating lists. Here, We will use this as a opportunity to learn about list operations. Python lists implement two operations:

\begin{itemize}
\tightlist
\item
  Adding two lists together: \texttt{\textless{}list1\textgreater{}\ +\ \textless{}list2\textgreater{}}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{b }\OperatorTok{=}\NormalTok{ [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{]}
\NormalTok{a }\OperatorTok{+}\NormalTok{ b}
\CommentTok{\#\textgreater{} [1, 2, 3, 4, 5, 6]}
\end{Highlighting}
\end{Shaded}

Note that this produces a \emph{new} list and, therefore, that this is not equivalent to \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{extend} method \texttt{a.extend(b)}! The \texttt{+} creates a \emph{new} list, \texttt{.extend()} extends the original list \texttt{a}.\footnote{You will learn about practical implications of this later. For now, keep in mind that seemingly identical output might be fundamentally different underneath.}

\begin{itemize}
\tightlist
\item
  List replication:: \texttt{\textless{}list\textgreater{}\ *\ \textless{}integer-value\textgreater{}} creates a \emph{new} list by replicating the original one \texttt{\textless{}integer-value\textgreater{}} times. For example:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{b }\OperatorTok{=} \DecValTok{4}
\NormalTok{a }\OperatorTok{*}\NormalTok{ b}
\CommentTok{\#\textgreater{} [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]}
\end{Highlighting}
\end{Shaded}

Use either operation or \texttt{.extend()} method to create the list where each filename is repeated twice. Hint, you can apply list multiplication directly to the filenames list you created via list comprehension (so, replicate it in that same line). Try this code out in a Jupyter Notebook.

\hypertarget{enumerate}{%
\section{Looping over both index and item via list enumeration}\label{enumerate}}

Now that we have a list of filenames, we can create a list of cards out of it. Our dictionary function requires both index and filename. The latter is the \emph{item} of the list, the former is the \emph{index} of that item. You could build the index using \protect\hyperlink{range}{range()} function but Python has a better solution for this: a \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()} function! If, instead of iterating over a list, you iterate over \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()}, you get a tuple with both \texttt{(index,\ value)}. Here is an example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ index, letter }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(letters):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{\textquotesingle{}}\OperatorTok{\%}\NormalTok{(index, letter))}
\CommentTok{\#\textgreater{} 0: a}
\CommentTok{\#\textgreater{} 1: b}
\CommentTok{\#\textgreater{} 2: c}
\end{Highlighting}
\end{Shaded}

And here is how you can use \href{https://docs.python.org/3/library/functions.html\#enumerate}{enumerate()} for list comprehension.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters }\OperatorTok{=}\NormalTok{ [}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{]}
\NormalTok{[}\StringTok{"}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{\%}\NormalTok{(index, letter) }\ControlFlowTok{for}\NormalTok{ index, letter }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(letters)]}
\CommentTok{\#\textgreater{} [\textquotesingle{}0: a\textquotesingle{}, \textquotesingle{}1: b\textquotesingle{}, \textquotesingle{}2: c\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

\hypertarget{os-library}{%
\section{Computing path}\label{os-library}}

Originally, we specified image file name as \texttt{"Images/r01.png"}. This did the job but now we have many filenames that we need to join with the folder name to form a path string. On top of that, major operating systems disagree with Windows on where \texttt{/} (forward slash) or \texttt{\textbackslash{}} (backslash) should be used for paths. To make your code platform-independent and, therefore, more robust, you need to construct a filename string using \href{https://docs.python.org/3/library/os.path.html\#os.path.join}{join} function in \href{https://docs.python.org/3/library/os.path.html}{path} submodule. Thus, you can import \emph{os} library and call it as \texttt{os.path.join(...)} (my personal preference). Or, you can use the same approach as for PsychoPy modules and import \texttt{path} from \emph{os}, shortening the code. Or, of course, you can even import \emph{join} directly but I find that lack of library information during use makes things harder to understand (even though the code is even shorter).

\href{https://docs.python.org/3/library/os.path.html\#os.path.join}{join} takes path components as parameters and joins them to match the OS format. E.g., \texttt{os.path.join("Python\ seminar",\ "Memory\ game",\ "memory01.py")} on Windows will return \texttt{\textquotesingle{}Python\ seminar\textbackslash{}\textbackslash{}Memory\ game\textbackslash{}\textbackslash{}memory01.py\textquotesingle{}}. As we need to load multiple files, the \emph{filename} part will vary. However, the \emph{folder} where the images are located will be the same and, as per usual, it would a good idea to turn it into a formally declared \protect\hyperlink{constants}{CONSTANT}.

Modify the \texttt{create\_card} function so that it assumes that the \texttt{filename} parameter is just the filename with the folder name and, therefore, build the path by \href{https://docs.python.org/3/library/os.path.html\#os.path.join}{join} it with the folder name (defined as a constant in the this module!). You now need to drop the \texttt{"Images/"} in the value that you pass to it. Test that the code works as before!

Update \texttt{create\_card} in \texttt{utilities.py}
Put updated code into \texttt{code07.py}.

\hypertarget{a-deck-of-cards}{%
\section{A deck of cards}\label{a-deck-of-cards}}

Let us put together all the code we need for figuring out cards' filenames, duplicating them, and creating the cards using filename and index.

Copy the code for building a duplicated list of filenames that you tested in Jupyter notebook to your main script (that'll be \texttt{code09.py}). Then, use enumerate and list comprehension over enumerated duplicate filenames to create \texttt{cards} (plural, replacing your singular \texttt{card} variable) via \texttt{create\_card} function you wrote earlier. Update your drawing code to loop over and draw all cards. If your default is \texttt{"side"} is \texttt{"back"}, things will look pretty boring. Change that to '``front''` for all cards to see their faces.

Put your code into \texttt{code08.py}.

\hypertarget{shuffle}{%
\section{Shuffling cards}\label{shuffle}}

When you draw cards faces, you will notice that duplicating filenames list produces a very orderly sequence that makes playing the game easy (and boring). We need to \href{https://docs.python.org/3/library/random.html\#random.shuffle}{shuffle()} the filename list \emph{before} we create \texttt{cards}. Note that \href{https://docs.python.org/3/library/random.html\#random.shuffle}{shuffle()} shuffles list item \emph{in place} using the fact that the list is \protect\hyperlink{mutable-objects}{mutable}. That means you simply call the function and pass the list as an argument. The list gets modified, nothing is returned and nothing need to be assigned back of \texttt{filenames} variable.

Put your code into \texttt{code09.py}.

\hypertarget{lets-have-a-break}{%
\section{Let's have a break!}\label{lets-have-a-break}}

We covered a lot of ground, so it might be a good point to take a break and submit your code for my review.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{adding-main-game-loop}{%
\section{Adding main game loop}\label{adding-main-game-loop}}

At this point, we have a shuffle deck of cards that we show until a player presses a key. Modify the code to have the main presentation loop, similar to one we had when we experimented with \protect\hyperlink{psychopy-basics}{PsychoPy} stimuli. Previously, we used a logical \texttt{gameover} variable to control the \protect\hyperlink{ux5cux23while-loop}{while} loop. Here, we will have two reasons to exit the loop: the player pressed an \textbf{escape} key or they won the game. Therefore, let us use a \emph{string} \texttt{game\_state} variable that is initialized to \texttt{"running"}. Repeat the loop while the \texttt{game\_state} is equal to \texttt{"running"} but change it \texttt{"abort"} if a player pressed \textbf{escape}. You also need to replace \href{https://psychopy.org/api/event.html\#psychopy.event.waitKeys}{waitKeys()} with \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{getKeys()}.

Put your code into \texttt{code10.py}.

\hypertarget{psychopy-mouse}{%
\section{Detecting a mouse click}\label{psychopy-mouse}}

In the game, the player will click on individual cards to turn them over. Before you can use a \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{mouse} in PsychoPy, you must create it via \texttt{mouse\ =\ event.Mouse(visible=True,\ win=win)} call, where \texttt{win} is the PsychoPy window you already created. This code should appear immediately below the line where you create the window itself.

Now, you can check whether the left button was pressed using \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPressed}{mouse.getPressed()} method. It returns a three-item tuple with \texttt{True}/\texttt{False} values indicating whether each of the three buttons are \emph{currently being pressed}. Use it the main loop, so that if the player presses \emph{left} button (its index in the returned list is 0), you change \texttt{"side"} of the first card (so, the card with index 0 in the list) to \texttt{"front"}. This assumes that you initialized card with their \texttt{"back"} shown, of course. If you run the code and click \emph{anywhere}, this should flip the first card.

Put the mouse-click-processing code \emph{before} drawing cards. At the moment, it makes no difference but will be useful later on, as it will allow us to draw the latest state of the card (i.e., right after it was flipped by a player).

Put your code into \texttt{code11.py}.

\hypertarget{position-to-index}{%
\section{Position to index}\label{position-to-index}}

Currently, the first card is flipped if you click \emph{anywhere}. But the card you flip should be the card the player clicked on. For this we need to implement a function \texttt{index\_from\_position} that is an inverse of \texttt{position\_from\_index}. It should take an argument \texttt{pos}, which is a tuple of \texttt{(\textless{}x\textgreater{},\ \textless{}y\textgreater{})} values (a mouse position within the window), and return an \emph{integer card index}. You have float values (with decimal points) in the \texttt{pos} argument (because it ranges from -1 to 1 for \protect\hyperlink{psychopy-units-norm}{norm} units) and by default the values you compute from them will also be float. However, an index \emph{must} be integer, so you will need to wrap it in \href{https://docs.python.org/3/library/functions.html\#int}{int()} function call, before returning it.

Going backwards --- from position to index --- is (IMHO) easier. First, you need to think how you can convert an \emph{x} coordinate (goes from -1 to 1) to a column index (goes from 0 to 3) given that you have 4 columns (draw a sketch on paper as it will make figuring out math simpler). Similarly, you translate \emph{y} (from -1 to 1) into row index given that there are only two rows. Once you know row and column index, you can compute the index itself, keeping in mind that there are four card in a row. As with \texttt{position\_from\_index}, I think it is easier to first play with formulas in a Jupyter Notebook, before turning the code into a function, documenting it, and putting it into \texttt{utilities.py}.

Put \texttt{index\_from\_position} into \texttt{utilities.py}.

\hypertarget{flip-a-selected-card-on-click}{%
\section{Flip a selected card on click}\label{flip-a-selected-card-on-click}}

Now that you have function that returns an index from position (don't forget to import it), you can flip the card that the player clicked on. For this, you need to extend the card-flipping code inside the \emph{if left-mouse button was pressed} code. Get the position of the mouse within the window by calling \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPos}{mouse.getPos()}. This will return a pair of \texttt{(x,\ y)} values, which you can pass to your \texttt{index\_from\_position()} function. This, in turn will return the index of the card the player click on. Change the \texttt{"side"} of a card with that index to \texttt{"front"}. Test the code by turning different cards over, make sure that it is the card that you clicked on that gets turned. And a usual reminder, do not hesitate to put a breakpoint inside the if-statement to check the actual mouse position values and how they are translated into index, if things do not work.

Put your code into \texttt{code12.py}.

\hypertarget{keeping-track-of-open-cards}{%
\section{Keeping track of open cards}\label{keeping-track-of-open-cards}}

In the actual game, a player is allowed to flip only \emph{two} cards at a time. If they match, they are removed. If not, they are flipped to their backs again. This means we need to keep track of which and how many cards are face up. We can always figure this out by doing a list comprehension scanning for cards that have their \texttt{"side"} as \texttt{"face"}. But, mutable nature of dictionaries presents us with a simpler solution. We create a new list (let us call it \texttt{face\_up}) and add cards to it. Mutable dictionary will not be copied but rather a reference to it will be present in both lists (same card dictionary will have two stickers on it, one from the \texttt{cards} list, one from \texttt{face\_up} list). This way we know \emph{which} cards are face up (those that are in the list) and we know how many (length of the \texttt{face\_up} list).

However, you need to be careful not do add a card more than once (this will mess up our ``how many cards are face up'' number). There are several ways to do this. Assuming that \texttt{icard} is the index of the card, which you computed via \texttt{position\_to\_index()} from mouse position, you can simply check whether this card \texttt{"side"} is \texttt{"front"}. Alternatively, you can check whether this card is already \href{https://docs.python.org/3/reference/expressions.html?highlight=list\%20dictionary\#in}{in} the \texttt{face\_up} list. Either way will tell you whether the card is face up. If it is not, you should set its \texttt{"side"} to \texttt{"front"} and add it to \texttt{face\_up} list. Finally, you can store the cards in a \href{https://docs.python.org/3/tutorial/datastructures.html\#sets}{set}, which is an unordered collection that does not allow duplicate items. This means that you can add the card multiple times but it will appear only once in the set.

Implement this code, open a few cards. Then, use a breakpoint to pause the program and check that \texttt{face\_up} list (or set) contains exactly these (this many) cards. If it has \emph{more} then your face-up checks do not work. Put a breakpoint on them and step through the code to see what happens.

Put your code into \texttt{code13.py}.

\hypertarget{opening-only-two-cards}{%
\section{Opening only two cards}\label{opening-only-two-cards}}

Now we need to check whether a player opened exactly two cards. In your code, mouse checks should be \emph{before} the drawing code. This means that cards are drawn face up immediately after a click. Once they are drawn, check the length of \texttt{face\_up}, if it equal to 2:

\begin{itemize}
\tightlist
\item
  pause the program for \textasciitilde0.5 s\footnote{Pick the timing you like!} via \href{https://psychopy.org/api/clock.html\#psychopy.clock.wait}{wait}, so that the player can see both cards.
\item
  flip both cards back (i.e., set their \texttt{"side"} to \texttt{"back"}).
\item
  remove them from \texttt{face\_up} list (see \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{.clear()} method).
\end{itemize}

Put your code into \texttt{code14.py}.

\hypertarget{taking-a-matching-pair-off-the-table}{%
\section{Taking a matching pair off the table}\label{taking-a-matching-pair-off-the-table}}

Our code turns cards back even you found a matching pair but we need to take them off the table. Once you have two cards in the \texttt{face\_up} list (if you have a set, you can convert it to the list via \texttt{list()}), you need to check whether they have the same chicken on them, i.e., their filenames are the same. If they are, you set \texttt{"show"} field to \texttt{False}. If not, you set their \texttt{"side"} to \texttt{"back"} (what your code is already doing). Either way, you still need to pause the program to allow the player to see them and to clear \texttt{face\_up} list/set (they are either off the table or face down, definitely not face up).

We also need to modify our code to handle \texttt{"show"} field correctly. First, modify your drawing code to draw only the cards that should be shown. Second, when handling mouse click, you need to check both that the card is not face up and that it is shown (otherwise you can ``open'' invisible cards).

Put your code into \texttt{code15.py}.

\hypertarget{game-over-once-all-the-cards-are-off-the-table}{%
\section{Game over once all the cards are off the table}\label{game-over-once-all-the-cards-are-off-the-table}}

When your code works correctly, you can take all the card off the table, so that only the gray screen remains. However, that should be the point when the game finishes and congratulates you on your success. Write a function \texttt{remaining\_cards} that will take the list with cards (i.e., our \texttt{cards} list) and will return how many cards are still shown (their \texttt{"show"} field is \texttt{True}). You definitely need a \protect\hyperlink{for-loop}{for} for this but implementation can be very different. You could use an extra counter variable that you initialize to 0 and then increment by one (see \href{https://docs.python.org/3/reference/simple_stmts.html\#augmented-assignment-statements}{+=} for a shortcut). Alternatively, you can use \href{l\#list-comprehension}{list comprehensions} to filter out all cards that are not shown and return the length of that list (a single line solution). Implement this function in \emph{utilities.py} and exit the loop by setting \texttt{game\_state} to \texttt{"victory"}. After the loop, you can check the \texttt{game\_state} variable and if the player was victorious, show a congratulatory message (\href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim}, note that you don't even need to create a variable for it, you can create an object and call \texttt{.draw()} on it, i.e., \texttt{visual.TextStim(...).draw()}) and wait for a key press before you close the window.

Put your code into \texttt{code16.py}.

\hypertarget{do-it-fast}{%
\section{Do it fast!}\label{do-it-fast}}

There are different ways on how you can quantify speed in this game. You could look at the number of pairs the player had to open until clearing them up (the fewer, the better). Or, you could measure how fast the player did it in seconds. Or use a combination of these two measures. Let us use the second option --- total time taken --- as an opportunity to learn about using PsychoPy \href{https://psychopy.org/api/clock.html}{clocks}.

The two classes you will be primarily interested in are \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} and \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{CountdownTimer}. The only difference between the two is that \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} starts at (and \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock.reset}{resets} to) 0 and start counting \emph{elapsed} time, so its \href{https://psychopy.org/api/clock.html\#psychopy.clock.MonotonicClock.getTime}{getTime()} method will return only \emph{positive} values. In contrast, the \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{CountdownTimer} start with (and resets to) a value you initialized it with and starts counting \emph{remaining} time down. Importantly, it will not stop once it reaches 0, so you will eventually end up with \emph{negative} remaining time. Thus, for \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} you check whether the \emph{elapsed} time is longer than some predefined value, whereas for \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{CountdownTimer} you start at a predefined value and check that the \emph{remaining} time is above zero. Note it is not guaranteed that the remaining time will be exactly zero. If anything, it is extremely unlikely that this will ever happen, so never test for an exact equality with zero\footnote{More generally, never compare float values to exact numbers. They are \href{http://www.lahey.com/float.htm}{tricky}, as the underlying representation \href{https://docs.python.org/3/tutorial/floatingpoint.html}{does not guarantee} that the computation will produce \emph{exactly} the number that it should: \texttt{.1\ +\ .1\ +\ .1\ ==\ .3} is surprisingly \texttt{False}, try it yourself}!

Here, we are interested in the \emph{elapsed} time, so \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} is the obvious choice. Create a clock before the game loop and use the elapsed time in the congratulatory message.

Put your code into \texttt{code17.py}.

\hypertarget{how-can-you-improve-it}{%
\section{How can you improve it?}\label{how-can-you-improve-it}}

Excellent game but you can always improve it: highscore, multiple round, etc. The sky is the limit!

\hypertarget{christmas-special}{%
\chapter{Christmas special}\label{christmas-special}}

Today we are going to program a Christmas-special. However, this is still an opportunity to learn something new. You will learn about zipping lists and we will start offloading settings into a separate file. Here is how the Christmas tree looks for me:

\hypertarget{chapter-concepts-6}{%
\section{Chapter concepts}\label{chapter-concepts-6}}

\begin{itemize}
\tightlist
\item
  Building Christmas spirit
\item
  Zipping over lists
\item
  Loading setting from JSON or YAML file.
\end{itemize}

\hypertarget{christmas-tree}{%
\section{Christmas tree}\label{christmas-tree}}

Let us start our Christmas decoration with a Christmas tree. You can download \href{material/pine-tree.png}{the one I've found}\footnote{Created by \href{https://openclipart.org/artist/isaiah658}{isaiah658}.} or find an image that you like. Create your basic PsychoPy code to create a window (we will be using \href{https://psychopy.org/api/visual/circle.html\#psychopy.visual.circle.Circle}{Circle} later, so think about suitable units), an \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} with a tree, draw it and wait for any key press.

Put your code into \texttt{code01.py}.

\hypertarget{christmas-tree-decoration}{%
\section{Christmas tree decoration}\label{christmas-tree-decoration}}

For the decoration, let us use \href{https://psychopy.org/api/visual/circle.html\#psychopy.visual.circle.Circle}{Circle} objects of various sizes and color. We could create each one separately with its own custom hard-coded values, but let us instead create three constants that are lists of equal length that describe, respectively position of each ball (\texttt{BALL\_POS} would be a good name, each entry should be a tuple of \texttt{(x,\ y)}), size (\texttt{BALL\_SIZE}), and color (\texttt{BALL\_COLOR}, stick to \texttt{"red"}, \texttt{"blue"}, and \texttt{"yellow"}, this limited selection of specific colors will be important later when we animate them).

Create a list of balls by iterating over these three lists. You have two choices, you can either use an index variable, building an index via \href{https://docs.python.org/3/library/functions.html\#func-range}{range()} using \href{https://docs.python.org/3/library/functions.html\#len}{len()} of one of the lists (they should all be of the same length). But let use a cool trick of iterating over a \href{https://docs.python.org/3/library/functions.html\#zip}{zip()} of lists. \href{https://docs.python.org/3/library/functions.html\#zip}{zip()} gives you a tuple combining one element from each list that you can unpack on the fly as in the example below (note that loop variables will receive values in the order that you used for lists).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{numbers }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\NormalTok{letters }\OperatorTok{=}\NormalTok{ [}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{  a\_number, a\_letter }\KeywordTok{in}  \BuiltInTok{zip}\NormalTok{(numbers, letters):}
  \BuiltInTok{print}\NormalTok{(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{: }\SpecialCharTok{\%s}\StringTok{"}\OperatorTok{\%}\NormalTok{(a\_number, a\_letter))}
\CommentTok{\#\textgreater{} 1: A}
\CommentTok{\#\textgreater{} 2: B}
\CommentTok{\#\textgreater{} 3: C}
\end{Highlighting}
\end{Shaded}

You can zip as many lists as you want. We, obviously, want three. Decide on whether you want to create \texttt{balls} as an empty list and then append each newly created \href{https://psychopy.org/api/visual/circle.html\#psychopy.visual.circle.Circle}{Circle} to it in the loop or use list comprehension. Do not forget to draw the balls and think about what you should draw first: the tree or the balls. Experiment with position and sizes to makes it look just perfect.

Put your code into \texttt{code02.py}.

\hypertarget{twinkle-twinkle-little-star}{%
\section{Twinkle, twinkle, little star}\label{twinkle-twinkle-little-star}}

Now let us make our Christmas balls twinkle, as in the video. The idea is that only one color is ``active'' at a time. The balls of that color are ``on'' and balls of other color are ``off'' (white or gray, or some other color of your liking). Now our display becomes dynamic, so you need to have a game loop and with an opportunity to exit the program by pressing \emph{escape}.

For this, we need to define a list of colors (``red'', ``blue'', ``yellow'') that we can cycle through and an variable that hold the index of the currently active color (I've called it \texttt{icolor}). Every X seconds (I do it every 0.5 seconds, define this as a constant, e.g., \texttt{TWINKLE\_DURATION}), increment this index, so that the next color in the list becomes active. Note that you have an out-of-range problem: When you initialize \texttt{icolor} to 0 and increment it by 1 three times, your index is already too large (3, the length of our \texttt{colors} list is 3, so the maximal index is 2). You can either use an \texttt{if} to check for that or you can use a remainder operator \texttt{\%} (think about the remainder if you divide \emph{any} positive value by the length of the \texttt{colors} list).

Once you need to update whether balls are ``on'' or ``off'', you need to loop both through the balls and their colors in the original \texttt{BALLS\_COLOR} list (when you use a string with color name, it gets translated into an RGB value, so we cannot compare it directly). Again, you can use \href{https://docs.python.org/3/library/functions.html\#zip}{zip()} to loop simultaneously through Christmas balls and their color. If their color matches the active one, their \texttt{fillColor} should be that color. If not, their \texttt{fillColor} should be some ``neutral'' / ``off'' color (white? gray?).

To keep track of time, you will need a timer variable, use either \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} or \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{CountdownTimer}. Once the \texttt{TWINKLE\_DURATION} elapsed, update the active color, all the balls, and do not forget to reset the timer.

Put your code into \texttt{code03.py}.

\hypertarget{lets-make-some-noise}{%
\section{Let's make some noise!}\label{lets-make-some-noise}}

Let add some Christmas music! Download \href{material/Deck\%20the\%20Halls\%20B.ogg}{Deck the Halls version by Kevin MacLeod}\footnote{Deck the Halls B by Kevin MacLeod \url{http://incompetech.com}
  Creative Commons --- Attribution 4.0 International --- CC BY 4.0
  Free Download / Stream: \url{https://bit.ly/deck-the-halls-b}
  Music promoted by Audio Library \url{https://youtu.be/RzjZ-WdVeyk}}. For this, we will use \href{https://psychopy.org/api/sound.html}{sound} module of PsychoPy library that generate sounds on the fly and also play audio files in various format such as wav or ogg (but not mp3!). Unfortunately, sound it surprisingly tricky, there are many libraries that might be used by PsychoPy (as of end of 2021 PsychoPy lists four backends that it might use), and things sometimes break. Thus, if the music does not play for you, ask me and we will try to set your sound libraries up.

Using sound is very simple. First, you need to import the \texttt{Sound} class as suggested in the manual:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ psychopy.sound }\ImportTok{import}\NormalTok{ Sound}
\end{Highlighting}
\end{Shaded}

Then, you need a new object of \texttt{Sound} class supplying the file name as the first parameter (I called the variable \texttt{song}). Right before start the loop, you \texttt{.play()} the sound. Note, if you want to play the same sound again, you need to ``rewind'' it by explicitly calling its \texttt{.stop()} method. For some reason, the sound stops at the end but does not gets ``rewind'', so when you try to play it again and notices that it is already at the end and stops without playing anything.

Put your code into \texttt{code04.py}.

\hypertarget{settings-files}{%
\section{Settings file formats}\label{settings-files}}

So far, we either hard-coded specific values or defined them as constants (a better of these two approaches). However, this means that if you want to run your game with different settings, you need to modify the program itself. And if you want to have two versions of the game (two experimental conditions), you would need to have two programs with all the problems of maintaining virtually identical code in several places at once.

A better approach is to have separate files with settings, so you can keep the code constant and alter specific parameters by specifying which settings file the program should use. This is helpful even if you plan to have a single set of setting as it separates code from constants, puts the latter all in one place and makes it easier to edit and check them. There are multiple formats for settings files: XML, INI, JSON, YAML, etc. Our format of the choice for today will be JSON. However, this is a question of taste. Personally, I like YAML for subjective reasons (fewer curly brackets and quotation marks), but you are free to use any format you like. As you will see, this makes little difference for the actual Python code.

\hypertarget{xml}{%
\subsection{XML}\label{xml}}

\href{https://en.wikipedia.org/wiki/XML}{XML} --- an Extensible Markup Language --- looks similar to HTML (HyperText Markup Language). Experiments designed using PsychoPy Builder interface are stored using XML files but with \href{https://www.psychopy.org/psyexp.html}{.psyexp extension}. A settings file for our Christmas programin XML could look like this

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Balls}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Ball}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Position}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{x}\NormalTok{\textgreater{}0.1\textless{}/}\KeywordTok{x}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{y}\NormalTok{\textgreater{}0.2\textless{}/}\KeywordTok{y}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Position}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Size}\NormalTok{\textgreater{}0.01\textless{}/}\KeywordTok{Size}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Color}\NormalTok{\textgreater{}red\textless{}/}\KeywordTok{Color}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Ball}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Ball}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Position}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{x}\NormalTok{\textgreater{}0.2\textless{}/}\KeywordTok{x}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{y}\NormalTok{\textgreater{}0.1\textless{}/}\KeywordTok{y}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Position}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Size}\NormalTok{\textgreater{}0.02\textless{}/}\KeywordTok{Size}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Color}\NormalTok{\textgreater{}yellow\textless{}/}\KeywordTok{Color}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Ball}\NormalTok{\textgreater{}}
\NormalTok{  ...}
\NormalTok{\textless{}/}\KeywordTok{Balls}\NormalTok{\textgreater{}}
\NormalTok{\textless{}}\KeywordTok{Timing}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Twinkle}\OtherTok{ duration}\ErrorTok{\textgreater{}0.5\textless{}/Twinkle} \ErrorTok{duration\textgreater{}}
\ErrorTok{\textless{}/Timing\textgreater{}}
\end{Highlighting}
\end{Shaded}

The advantage of XML is that it is very flexible yet structured and you can use \href{https://docs.python.org/3/library/xml.html}{native Python interface} to work with it. However, XML is not easy for humans to read, it is overpowered for our purposes of having a simple set of unique constants and its power means that using it is fairly cumbersome (I use \texttt{\textbackslash{}} to split a single line into many lines).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ xml.dom }\ImportTok{import}\NormalTok{ minidom}
\NormalTok{settings }\OperatorTok{=}\NormalTok{ minidom.parse(}\StringTok{\textquotesingle{}settings.xml\textquotesingle{}}\NormalTok{)}
\CommentTok{\# this will give you string "0.4"}
\NormalTok{size }\OperatorTok{=}\NormalTok{ settings.getElementsByTagName(}\StringTok{"Balls"}\NormalTok{)[}\DecValTok{0}\NormalTok{]. }\OperatorTok{\textbackslash{}}
\NormalTok{                getElementsByTagName(}\StringTok{"Ball"}\NormalTok{)[}\DecValTok{0}\NormalTok{]. }\OperatorTok{\textbackslash{}}
\NormalTok{                getElementsByTagName(}\StringTok{"Size"}\NormalTok{)[}\DecValTok{0}\NormalTok{].firstChild.data}
\end{Highlighting}
\end{Shaded}

\hypertarget{ini}{%
\subsection{INI}\label{ini}}

This is a format with a structure similar to that found in MS Windows INI files.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{[Balls]}
\DataTypeTok{    x }\OtherTok{=}\StringTok{ 0.1, 0.2}
\DataTypeTok{    y }\OtherTok{=}\StringTok{ 0.2, 0.1}
\DataTypeTok{    size }\OtherTok{=}\StringTok{ 0.01, 0.02}
\DataTypeTok{    color }\OtherTok{=}\StringTok{ red, yellow}
\KeywordTok{[Timing]}
\DataTypeTok{    TwinkleDuration }\OtherTok{=}\StringTok{ }\FloatTok{0.5}
\end{Highlighting}
\end{Shaded}

As you can see it is easier to read and Python has a special \href{https://docs.python.org/3/library/configparser.html}{configparser} library to work with them. The object you get is, effectively, a dictionary with additional methods and attributes. However \texttt{ConfigParser} does not try to guess the type of data, so all values are stored as \emph{strings} and it is your job to convert them to whatever type you need, e.g., integer, list, etc.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ configparser}
\NormalTok{settings }\OperatorTok{=}\NormalTok{ configparser.ConfigParser()}
\NormalTok{settings.read(}\StringTok{\textquotesingle{}settings.ini\textquotesingle{}}\NormalTok{)}
\NormalTok{settings[}\StringTok{\textquotesingle{}Balls\textquotesingle{}}\NormalTok{][}\StringTok{\textquotesingle{}size\textquotesingle{}}\NormalTok{] }\CommentTok{\# this will give you a string \textquotesingle{}0.01, 0.02\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\hypertarget{json}{%
\subsection{JSON}\label{json}}

\href{https://en.wikipedia.org/wiki/JSON}{JSON} (JavaScript Object Notation) is a popular format to serialize data for web applications that use it to exchange data between a server and a client.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{}
  \DataTypeTok{"Balls"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"position"}\FunctionTok{:} \OtherTok{[[}\FloatTok{0.1}\OtherTok{,} \FloatTok{0.2}\OtherTok{],} \OtherTok{[}\FloatTok{0.2}\OtherTok{,} \FloatTok{0.1}\OtherTok{]]}\FunctionTok{,}
    \DataTypeTok{"size"}\FunctionTok{:} \OtherTok{[}\FloatTok{0.01}\OtherTok{,} \FloatTok{0.02}\OtherTok{]}\FunctionTok{,}
    \DataTypeTok{"color"}\FunctionTok{:} \OtherTok{[}\StringTok{"red"}\OtherTok{,} \StringTok{"yellow"}\OtherTok{]}
  \FunctionTok{\},}
  \DataTypeTok{"Timing"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"Twinkle duration"} \FunctionTok{:} \FloatTok{0.5}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

You can parse any \emph{string} in JSON format into a dictionary in Python using \href{https://docs.python.org/3/library/json.html}{json} module. Its advantage over INI files is that JSON explicitly specifies data type (i.e., strings are in quotation marks), so it converts it automatically. Note that unlike configparse, json module does not work with files directly, so you need to open it manually (ignore the \texttt{with} magic for a moment, you will learn about it in detail when we will talk about context managers).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ json}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{\textquotesingle{}settings.json\textquotesingle{}}\NormalTok{) }\ImportTok{as}\NormalTok{ json\_file:}
\NormalTok{    settings }\OperatorTok{=}\NormalTok{ json.load(json\_file)}
    
\NormalTok{settings[}\StringTok{"Balls"}\NormalTok{][}\StringTok{"size"}\NormalTok{] }\CommentTok{\# this will give a list [0.01, 0.02]}
\end{Highlighting}
\end{Shaded}

\hypertarget{yaml}{%
\subsection{YAML}\label{yaml}}

\href{https://en.wikipedia.org/wiki/YAML}{YAML} (YAML Ain't Markup Language, rhymes with camel) is very similar to JSON but its config files are more human-readable. It has fewer special symbols and curly brackets but, as in Python, you must watch the indentations as they determine the hierarchy.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{Balls}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{position}\KeywordTok{:}\AttributeTok{ }\KeywordTok{[[}\FloatTok{0.1}\KeywordTok{,}\AttributeTok{ }\FloatTok{0.2}\KeywordTok{],}\AttributeTok{ }\KeywordTok{[}\FloatTok{0.2}\KeywordTok{,}\AttributeTok{ }\FloatTok{0.1}\KeywordTok{]]}
\AttributeTok{  }\FunctionTok{size}\KeywordTok{:}\AttributeTok{ }\KeywordTok{[}\FloatTok{0.01}\KeywordTok{,}\AttributeTok{ }\FloatTok{0.02}\KeywordTok{]}
\AttributeTok{  }\FunctionTok{color}\KeywordTok{:}\AttributeTok{ }\KeywordTok{[}\StringTok{"red"}\KeywordTok{,}\AttributeTok{ }\StringTok{"yellow"}\KeywordTok{]}
\FunctionTok{Timing}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{Twinkle duration }\KeywordTok{:}\AttributeTok{ }\FloatTok{0.5}
\end{Highlighting}
\end{Shaded}

You will need to install a third-party library \href{https://pyyaml.org/}{pyyaml} to work with YAML files. You get the same dictionary as for the JSON

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ yaml}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"settings.yaml"}\NormalTok{) }\ImportTok{as}\NormalTok{ yaml\_stream:}
\NormalTok{    settings }\OperatorTok{=}\NormalTok{ yaml.load(yaml\_stream)}
    
\NormalTok{settings[}\StringTok{"Balls"}\NormalTok{][}\StringTok{"size"}\NormalTok{] }\CommentTok{\# this will give a list [0.01, 0.02]}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-settings}{%
\section{Using settings}\label{using-settings}}

Look at your \emph{code04.py} and identify constants and hard-coded values that you should put into a settings file. E.g., definitely constants that describes Christmas balls and twinkle duration but, possibly, also the size of the window, name of the Christmas tree and song files, etc. In general, I put every such value into settings even if it used only once (as with the size of the window) because then I know that \emph{all} constants are the settings file. This way there is a single, nicely organized place to check and I do not need to search through the code to figure a specific value out.

Once you transferred all your constants into the settings file (use either JSON or YAML), add the code that loads it at the very beginning and use settings dictionary in place of constants.

Put your code into \texttt{code05.py}.

\hypertarget{merry-christmas-and-a-happy-new-year}{%
\section{Merry Christmas and a Happy New Year!}\label{merry-christmas-and-a-happy-new-year}}

\hypertarget{flappy-bird}{%
\chapter{Flappy Bird}\label{flappy-bird}}

Today we will stat developing a \emph{Flappy Bird} game. You control a bird that must fly through the openings in the obstacles but your only action is to ``flap the wings'' in order to counteract the effect of gravity. This is how the game will look like at the end.

\hypertarget{chapter-concepts-7}{%
\section{Chapter concepts}\label{chapter-concepts-7}}

\begin{itemize}
\tightlist
\item
  Object-oriented programming
\item
  \texttt{@property}
\end{itemize}

We will use this game as an opportunity to learn more about object-oriented programming. You already know how to use classes, now you get to create them and see how it makes your life easier.

\hypertarget{object-oriented-programming}{%
\section{Object-oriented programming}\label{object-oriented-programming}}

The core idea is in the name: Instead of having variables/data and functions separately, you combine them in an object that has attrbutes/properties (its own variables) and methods (functions). This approach uses our natural tendency to perceive the world as a collection of interacting objects and has several advantages that I will discuss below.

\hypertarget{classes-and-objects-instances-of-classes}{%
\subsection{Classes and objects (instances of classes)}\label{classes-and-objects-instances-of-classes}}

Before we continue, I need to make an important distinction between \emph{classes} and \emph{objects}\footnote{No, it is not déjà vu, I am repeating myself to remind you about the distinction.}. A \emph{class} is a ``blue print'' that describes properties and behavior (methods) of objects of that class. This ``blue print'' is used to create an \emph{instance} of that class, which is called an \emph{object}. For example, Homo sapiens is a \emph{class} that describes species that have certain properties, such as height, and can do certain things, such as running. However, Homo sapiens as a class only has a concept of height but no specific height itself. E.g., you cannot ask ``What is height of Homo sapiens?'' only what is an average (mean, median, etc.) height of individuals of that class. Similarly, you cannot say ``Run, Homo sapiens! Run!'' as abstract concepts have trouble with real actions like that. Instead, it is Alexander Pastukhov who is an \emph{instance} of Homo sapiens class with a specific height and a specific (not particularly good) ability to run. Other instances of Homo sapiens (other people) will have different height and a different (typically better) ability to run. Thus, class describes what kind of properties and methods objects have. This means that whenever you meet a Homo sapien, you could be sure that they have height. However, individual objects have different values for various properties and so calling their methods (asking them to perform certain actions) may result in different outcomes.

Another, a more applied, example would be your use of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} \emph{class} to create multiple \emph{instances} of front side of a card in \href{memory-game}{Memory} game. Again, the \emph{class} defines properties (\texttt{image}, \texttt{pos}, \texttt{size}, etc.) and methods (e.g., method \texttt{draw()}) that individual \emph{objects} will have. You created these objects to serve as front side of cards. You set \emph{different} values for same properties (\texttt{image}, \texttt{pos}) and that ensured that when you call their method \texttt{draw()}, each card was drawn at its own location and with it own image.

\hypertarget{encapsulation}{%
\subsection{Encapsulation}\label{encapsulation}}

Putting all the data (properties) and behavior (methods) inside the class simplifies programming by ensuring that all relevant information can be found in its definition. Thus, you have a single place that should hold \emph{everything} that defines object's behavior. Contrast this with our approach in previous seminars where cards as dictionaries were separate from functions that created them. Today, you will see how encapsulating everything into classes turns this mess into a simpler and easier-to-understand code.

\hypertarget{inheritance-generalization}{%
\subsection{Inheritance / Generalization}\label{inheritance-generalization}}

In object-oriented programming, a class can be derived from some other \emph{ancestor} class and thus \emph{inherit} its properties and methods. Moreover, several classes can be derived from a single ancestor producing a mix of unique and shared functionality. This means that instead of rewriting the same code for each class, you can define a common code in an ancestor class and focus on differences or additional methods and properties in descendants.

Using the Homo sapiens example from above. Humans, chimpanzees and gorillas are all different species but we share a common ancestor. Hence, we are different in many respect, yet, you could think about all of us as ``apes'' that have common properties such as binocular trichromatic vision. In other words, if you are interested in color vision, you do not care what specific species you are looking it, as all apes are (roughly) the same in that respect. Or, you can move further down the evolution tree and think about us as ``mammals'' that, again, have common properties and behavior, such as thermoregulation and lactation. Again, if you are interested \emph{only} in whether an animal has thermoregulation, knowing that it is a mammal is enough.

Similarly, in PsychoPy various visual stimuli that we used (\href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}, \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim}, \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{Rect}) have same properties (e.g., \texttt{pos}, \texttt{size}, etc.) and methods (most notably, \texttt{draw()}). This is because they are all descendants from a common ancestor \texttt{BaseVisualStim} that defines their common properties and methods\footnote{\texttt{BaseVisualStim} does not actually define \texttt{draw()} method, only that it must be present.}. This means that you can assume that \emph{any} visual stimulus (as long as it descends from \texttt{BaseVisualStim}) will have \texttt{size}, \texttt{pos}, \texttt{ori} and can be drawn. This, in turn, means that you can have a list of various PsychoPy visual stimuli and move or draw all of them in a single loop without thinking which \emph{specific} visual stimulus you are moving or drawing. Also note that you cannot assume these same properties for \emph{sound} stimuli because they are \emph{not} descendants of \texttt{BaseVisualStim} but of \texttt{\_SoundBase} class.

There are other ways of achieving common behavior (generalization) in Python without orderly inheritance, such as ``duck typing''\footnote{Yes, it is really called ``duck typing''.} or mixins but this will be a topic of another seminar.

\hypertarget{polymorphism}{%
\subsection{Polymorphism}\label{polymorphism}}

As you've learned in the previous section, inheritance allows different descendants to share common properties and behavior, so that in certain cases you can view them as being equivalent to an ancestor. E.g., any visual stimulus (a descendant of \texttt{BaseVisualStim} class) can be drawn, so you just call its \texttt{draw()} method. However, it is clear that these different stimuli implement drawing \emph{differently}, as the \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{Rect} stimulus looks different from the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} or \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim}. This is called ``polymorphism'' and the idea is to keep the common interface (same \texttt{draw()} call) while abstracting away the actual implementation. This allows you to think about what you want an object to do (or what to do with an object), instead of thinking how exactly it is implemented.

\hypertarget{a-minimal-class-example}{%
\subsection{A minimal class example}\label{a-minimal-class-example}}

Enough of the theory, let us see how classes are implemented in Python. Here is a very simple class that has nothing but the \emph{constructor} \texttt{\_\_init\_\_()} method, which is called whenever a new object (class instance) is created, and a single attribute / property \texttt{total}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \CommentTok{"""}
\CommentTok{    Simple class that accumulates (sums up) values.}

\CommentTok{    Properties}
\CommentTok{    {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{    total : float}
\CommentTok{        Total accumulated value}
\CommentTok{    """}

    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \CommentTok{"""}
\CommentTok{        Constructor, initializes the total value to zero.}
\CommentTok{        """}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=} \DecValTok{0}
        
\CommentTok{\# here we create an object number\_sum, which is an instance of class Accumulator.}
\NormalTok{number\_sum }\OperatorTok{=}\NormalTok{ Accumulator()}
\BuiltInTok{print}\NormalTok{(number\_sum.total)}
\end{Highlighting}
\end{Shaded}

Let's go through it line by line. First line \texttt{class\ Accumulator:} shows that this is a declaration of a \texttt{class} whose name is \texttt{Accumulator}. Note that the first letter is capitalized. This is not required per se, so Python police won't be knocking on your door if you write it all in lower or upper case. However, the general recommendation is that \textbf{class} names are written using \texttt{UpperCaseCamelCase} whereas \textbf{object} (instances of the class) names are written using \texttt{lower\_case\_snake\_case}. This makes distinguishing between classes and objects (instances of classes) easier, so you should follow this convention.

The definition of the class are the remaining \emph{indented} lines. As with functions or loops, it is the indentation that defines what is inside and what is outside of the class. The only method we defined is \texttt{def\ \_\_init\_\_(self):}. This is a \emph{special} method\footnote{There are more special methods that you will learn about later, they all follow \texttt{\_\_methodname\_\_()} convention.} that is called when an object (instance of the class) is created. This allows you to initialize the object based on parameters that were passed to this function (if any). You do not call this function directly, rather it is called whenever an object is created, e.g., \texttt{number\_sum\ =\ Accumulator()} (last line). Also, it does not return any value explicitly via \texttt{return}. Instead, \texttt{self} (the very first parameter, more on it below) is returned automatically.

All class methods (apart from special cases we currently do not concern ourselves with) must have one special first parameter that is \emph{the object} itself. By convention it is called \texttt{self}\footnote{Again, you can use any name for that parameter but that will surely confuse everyone.}. It is passed to the method automatically, so whenever you write \texttt{square.draw()} (no explicit parameters written in the function call), the actual method still receives one parameter that is the \emph{reference} to the \texttt{square} variable whose method you called. Inside a method, you use this variable to refer to the object itself.
Let us go back to the constructor \texttt{\_\_init()\_\_} to see how you can use \texttt{self}. Here, we add a new \emph{persistent} attribute/property to the object and assign a value to it: \texttt{self.total\ =\ 0}. It is \emph{persistent}, because even though we created it inside the method, the mutable object is passed by reference and, therefore, we assigned it to the object itself. Now you can use this property either from inside \texttt{self.total} or from outside \texttt{number\_sum.total}. You can think of properties as being similar to field/value pairs in the dictionary we used in Memory game but for syntax: \texttt{object.property} versus \texttt{dictonary{[}"field"{]}}\footnote{This is actually how all properties and methods are stored, in a \texttt{\_\_dict\_\_} attribute, so you can write \texttt{number\_sum.\_\_dict\_\_{[}"total"{]}} to get it.}. Technically, you can create new properties in any method or even from outside (e.g., nothing prevents you from writing \texttt{number\_sum.color\ =\ "red"}). However, this makes understanding the code much harder, so the general recommendation is to create \emph{all} properties inside the constructor \texttt{\_\_init\_\_()} method, even if this means assigning \texttt{None} to them\footnote{If you use a linter, it will complain whenever it sees a property not defined in the constructor}.

\hypertarget{add-method}{%
\subsection{\texorpdfstring{\texttt{add} method}{add method}}\label{add-method}}

Let us add a method that adds 1 to the \texttt{total} property.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
\NormalTok{    ... }\CommentTok{\# I am skipping all previous code here}
    
    \KeywordTok{def}\NormalTok{ add(}\VariableTok{self}\NormalTok{):}
        \CommentTok{"""}
\CommentTok{        Add 1 to total}
\CommentTok{        """}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

It has first special argument \texttt{self} that is the object itself and we simply add 1 to its \texttt{total} property. Again, remember that \texttt{self} is passed automatically whenever you call the method, meaning that an actual call looks like \texttt{number\_sum.add()}.

Create a Jupyter notebook (you will need to submit it as part of the assignment) and copy-paste the code for \texttt{Accumulator} class, including the \texttt{.add()} method. Create \textbf{two} objects, call them \texttt{counter1} and \texttt{counter2}. Call \texttt{.add()} method twice for \texttt{counter2} and thrice for \texttt{counter1} (bonus: do it using \texttt{for} loop). What is the value of the \texttt{.total} property of each object? Check it by printing it out.

Copy-paste and test \texttt{Accumulator} class code in a Jupiter notebook.

\hypertarget{flexible-accumulator-with-a-subtract-method}{%
\subsection{\texorpdfstring{Flexible accumulator with a \texttt{subtract} method}{Flexible accumulator with a subtract method}}\label{flexible-accumulator-with-a-subtract-method}}

Now lets us create a new class that is a \emph{descendant} of the \texttt{Accumulator}. We will call it \texttt{FlexibleAccumulator} as it will allow you to also \emph{subtract} from the total count. You specify ancestors (could be more than one!) in round brackets after the class name

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ FlexibleAccumulator(Accumulator):}
    \ControlFlowTok{pass} \CommentTok{\# You must have at least one non{-}empty line, and pass means "do nothing"}
\end{Highlighting}
\end{Shaded}

Now you have a new class that is a descendant of \texttt{Accumulator} but, so far, is a perfect copy of it. Add \texttt{subtract} method to the class. It should subtract \texttt{1} from the \texttt{.total} property (don't forget to \emph{document} it!). Check that it works. Create one instance of \texttt{Accumulator} and another one of \texttt{FlexibleAccumulator} class and check that you can call \texttt{add()} on both of them but \texttt{subtract()} only for the latter.

Add \texttt{subtract} method to the \texttt{FlexibleAccumulator}
class in a Jupiter notebook. Add testing.

\hypertarget{method-arguments}{%
\section{Method arguments}\label{method-arguments}}

Now, create a new class \texttt{SuperFlexibleAccumulator} that will be able to both \texttt{add()} and \texttt{subtract()} an \emph{arbitrary} value. Think about which class it should inherit from. Redefine both \texttt{.add()} and \texttt{.subtract()} method in that new class by adding \texttt{value} argument to both method and add/subtract this value rather than \texttt{1}. Note that now you have \emph{two} arguments in each method \texttt{(self,\ value)} but when you call you only need to pass the latter (again, \texttt{self} is passed automatically). Don't forget to document \texttt{value} argument (but you do not need to document \texttt{self} as its meaning is fixed).

Create \texttt{SuperFlexibleAccumulator} class and definesuper flexible \texttt{add} and \texttt{subtract} methodsthat have \texttt{value} parameter ( in a Jupiter notebook).Test them!

\hypertarget{constructor-arguments}{%
\subsection{Constructor arguments}\label{constructor-arguments}}

Although constructor \texttt{\_\_init(...)\_\_} is special, it is still a method. Thus, you can pass arguments to it just like you did it for other methods. You pass these arguments when you create an object, so in our case, you put it inside the bracket for \texttt{counter\ =\ SuperFlexibleAccumulator(...)}.

Modify the code so that you pass the initial value that total is set to, instead of zero.

Add \texttt{initial\_value} parameter to the constructor of the \texttt{SuperFlexibleAccumulator} class in a Jupiter notebook. Test it!

\hypertarget{calling-methods-from-other-methods}{%
\subsection{Calling methods from other methods}\label{calling-methods-from-other-methods}}

You can call a function or object's method at any point of time, so, logically, you can use methods inside methods. Let's modify our code, realizing that \emph{subtracting} a value is like \emph{adding a negative} value. Modify your code, so that \texttt{.subtract()} only negates the value before passing is to \texttt{.add()} for actual processing. Thus, \texttt{total} is modified \emph{only} inside the \texttt{add()} method.

Modify \texttt{subtract()} method of \texttt{SuperFlexibleAccumulator}to utilize \texttt{add()} in a Jupiter notebook.Test it!

\hypertarget{local-variables}{%
\subsection{Local variables}\label{local-variables}}

Just like normal functions, you methods can have local variables. They are local (visible and accessible only from within the method) and are not persistent (their values do not survive between the calls). Conceptually, you separate variables that need to be persistent (retain their value the whole time object exists) as attributes/properties and temporary variables that are need only for the computation itself as local method variables. What would be value of property \texttt{.total} in this example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, initial):}
\NormalTok{        temp }\OperatorTok{=}\NormalTok{ initial }\OperatorTok{*} \DecValTok{2}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=}\NormalTok{ initial}
        
\NormalTok{counter }\OperatorTok{=}\NormalTok{ Accumulator(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

What about in this case?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ Accumulator:}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, initial):}
\NormalTok{        temp }\OperatorTok{=}\NormalTok{ initial }\OperatorTok{*} \DecValTok{2}
        \VariableTok{self}\NormalTok{.total }\OperatorTok{=}\NormalTok{ temp}
        
\NormalTok{counter }\OperatorTok{=}\NormalTok{ Accumulator(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{flappy-bird-the-humble-beginnings}{%
\section{Flappy Bird: the humble beginnings}\label{flappy-bird-the-humble-beginnings}}

We will start with a basic scaffolding for our program. Download the \href{material/Blue-Bird.png}{bird image}\footnote{Created by \href{https://openclipart.org/artist/Scout}{Madison Kingsford}.} and put it into a folder where you will store the code. Create a basic code that uses \href{settings-files}{settings file} that defines minimal setting for a window (size) and a bird (image file). Organize it hierarchically, as follows, as this will help us keep settings for different classes organized.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{}
  \DataTypeTok{"Bird"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"Image"} \FunctionTok{:} \StringTok{"Blue{-}Bird.png"}
  \FunctionTok{\},}
  \DataTypeTok{"Window"}\FunctionTok{:} \FunctionTok{\{}
    \DataTypeTok{"Size"}\FunctionTok{:} \OtherTok{[}\DecValTok{800}\OtherTok{,} \DecValTok{600}\OtherTok{]}
  \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

Create a \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{window} using this specified size and an \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} using the filename from the settings file. Add a basic game loop in which you repeatedly draw the bird (should appear right at the center of the screen) and check for a key press (\emph{escape} should exit the game).

Put your code into \texttt{code01.py}.

\hypertarget{flappy-bird-class}{%
\section{Flappy Bird class}\label{flappy-bird-class}}

Our flappy bird is, effectively, an image but we would like it to have additional behaviors, like, automatically falling down due to gravity, flying up due to flapping its wings, etc. There are several way we can do this. We can keep the image in \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} and write additional functions to handle it (the way we did previously). We could create an new class \texttt{FlappyBird} that will have the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} as its attribute. Or, we could utilize the power of inheritance and build \texttt{FlappyBird} class on top of the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}. This means less work for us, so that is the path we will follow.

Create a new file that will contain your \texttt{FlappyBird} class. Here is how it should look like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{"""Your comment on what this file contains.}
\CommentTok{"""}
\CommentTok{\# import libraries, which ones do you need?}

\KeywordTok{class}\NormalTok{ FlappyBird(visual.image.ImageStim):}
  \CommentTok{"""}
\CommentTok{  FlappyBird class based on ImageStim}
\CommentTok{  """}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, win, settings):}
    \CommentTok{"""}
\CommentTok{    Constructor.}
\CommentTok{    """}
    \BuiltInTok{super}\NormalTok{().}\FunctionTok{\_\_init\_\_}\NormalTok{(win, image}\OperatorTok{=}\NormalTok{settings[}\StringTok{"Image"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

In the code above, I defined \texttt{FlappyBird} as a descendant of the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}\footnote{Note that even though you can import \texttt{ImageStim} from \texttt{visual}, it is a better idea to specify its submodule for inheritance: \texttt{visual.image.ImageStim}. Inheritance will work for \texttt{ImageStim} even without that extra \texttt{.image} bit but won't work for some other stimuli due to so-called ``laze loading'' of classes. For these other classes, like \texttt{Rect}, you will get a very mysterious sounding error message, so it is better to always use full paths to the class when inheriting from them. You can find the full path in the ``Details'' section of documentation. E.g., the full path for \texttt{Rect} class is \href{https://psychopy.org/api/visual/rect.html\#details}{psychopy.visual.rect.Rect}}. To make the latter work, we need to initialize it properly by calling it constructor. This is what \texttt{super().\_\_init\_\_(...)} call does: Calls constructor of the ancestor class to enable all the magic that we want to reuse. Recall that \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} needs at least two parameters: a PsychoPy \href{(https://psychopy.org/api/visual/window.html\#psychopy.visual.Window)}{window} that the stimulus will belong to and an image (a filename in this case). Here, I assume that when I create a bird object (call the constructor), I pass \emph{two} parameters (again, \texttt{self} comes ``for free'', so you do not pass it explicitly but assume that it is the \emph{first} argument that you get): the {[}window{]}((\url{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}) that we created plus a dictionary with settings for the bird (there will be more settings, so it would be practical to pass the whole dictionary instead of passing one parameter at a time).

Copy paste that code (plus add appropriate imports and comments) and use \texttt{FlappyBird} class instead of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}. Note that \texttt{FlappyBird} inherits \emph{all} its functionality from \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}, so, apart from how you create it, you can use it in exactly the same way. Meaning, you do not need to modify anything else in your code (told you, it would save us time and effort!).

Put \texttt{FlappyBird} class code into a separate file.
Use it instead of \texttt{ImageStim} in \texttt{code02.py}.

\hypertarget{a-properly-sized-bird}{%
\section{A properly-sized bird}\label{a-properly-sized-bird}}

Our bird is very cute but is way too large. Add a new setting for it (I suggest calling is \texttt{Size} and setting it to 0.1) and then use it inside the constructor adding \texttt{size=...} to \texttt{super().\_\_init\_\_} call. Do you need to change anything in the main code?

Add bird size setting.
Use it in \texttt{FlappyBird} class constructor.

\hypertarget{flappy-bird-is-falling-down-my-dear-lady}{%
\section{Flappy Bird is falling down (my dear lady)}\label{flappy-bird-is-falling-down-my-dear-lady}}

Before our bird flies, it needs to learn how to fall down. Falling down is just a change of bird's vertical position based on bird's vertical speed. We already have a property for the (horizontal and) vertical position: \texttt{self.pos}, a tuple with \texttt{(x,\ y)} position of the center of the image. But we do need an additional new attribute that would encode bird's vertical speed. Create it in the constructor (if you forgot how to do it, take a look above on how we create the \texttt{total} attribute for \texttt{Accumulator} class) and call it \texttt{vspeed}. Also, create a new setting (I would call it \texttt{"Initial\ vertical\ speed"}) and set it to \texttt{-0.01}, use this setting in the constructor to initialize \texttt{vspeed}.

Now we also need a method that would update bird's position based on its (current) speed. Create this method below the constructor (does it need any parameters beyond compulsory \texttt{self}?). It should simply compute \(y_{new} = y + vspeed\) and assign \(y_{new}\) back to \texttt{pos} attribute (note that you cannot assign only y coordinate, you have to pass the tuple \texttt{(x,\ y)} reusing original \texttt{x} value from \texttt{pos}). Do not forget to document the new method!

Now you need to call the \texttt{update()} on each frame before drawing the bird. This should make your bird fall of the screen! (Experiment with \texttt{"Initial\ vertical\ speed"} setting to make it fall faster or slower or even upwards!)

Update \texttt{FlappyBird} class.
Use \texttt{update} method in \texttt{code03.py}.

\hypertarget{timing-the-fall}{%
\section{Timing the fall}\label{timing-the-fall}}

Currently, the speed of our bird's fall is measured in \texttt{norm\ units\ /\ frame}. This works but these are not the most convenient units to think in. Plus, it relies on PsychoPy (and the rest of our code) to ensure that time between individual frames is exactly the same. This is \emph{mostly} the case and an occasionally slow bird is not a big problem for a game. However, that might be a problem for an actual experiment that requires precise timing of movement. Thus, we need to think about vertical speed in units of \texttt{norm\ units\ /\ second} and measure time between calls of \texttt{update()} method ourselves.

Create a new \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} attribute that will count the time elapsed since it last reset (I would call it \texttt{frame\_timer}). Modify the \texttt{update()} method to compute \(y_{new} = y + vspeed * T_{elapsed}\), where \(T_{elapsed}\) is the time elapsed between frames. Do not forget to reset the timer! (What will happen if you do forget?)

Now set your \texttt{"Initial\ vertical\ speed"} to some reasonable value (e.g., 0.5) and check that the time it takes for the bird to fall of the screen looks reasonable (for 0.5 norm units / second it should be off the screen in two seconds).

Update \texttt{FlappyBird} class with a timer.

\hypertarget{it-is-all-newtons-fault}{%
\section{It is all Newton's fault}\label{it-is-all-newtons-fault}}

Now let us add gravity, so that the speed of falling would be constantly changing. Create a new setting and call it \texttt{"Gravity"}. Set it to \texttt{-0.5} (units are \texttt{norm\ units\ per\ second\ squared}) but experiment with different values later on. Acceleration due to gravity changes vertical speed just like speed itself changes the vertical position. Update your \texttt{update} method to change the speed based on acceleration given the elapsed time. What do you need to update first, the speed or the location? Also, think about how you will store the acceleration: It is in settings parameter that exists only in the constructor. You can either store it in a new attribute or store all settings in an attribute for later use.

Update \texttt{FlappyBird} class with acceleration due to gravity.

\hypertarget{flap-bird-flap}{%
\section{Flap bird, flap!}\label{flap-bird-flap}}

Let us add ability of the bird to ``flap'' in order to stay in the air. First, create a new setting \texttt{Flap\ speed} and set it to \texttt{0.4} (as usual, feel free to experiment!). Add a new method \texttt{.flap(self)} and inside simply set \texttt{vspeed} to \texttt{Flap\ speed}. Thus, a single flap sets the bird flying up with \texttt{Flap\ speed} speed which, however, will be constantly reduced by the acceleration due to \texttt{Gravity} so the bird will eventually start falling down again.

In the main code, check for \texttt{"escape"} and \texttt{"space"} keys. If the latter is pressed, call \texttt{.flap()} method of the bird. Check that you can keep the on the screen by timing the space button presses or can make it fly upwards off the screen.

Add \texttt{flap} method to \texttt{FlappyBird} class.
Use it in \texttt{code04.py} whenever player presses \emph{space}.

\hypertarget{stay-off-the-ground}{%
\section{Stay off the ground}\label{stay-off-the-ground}}

In our game, the player can lose either if they hit an obstacle (we do not have any yet) or if the bird drops below the ground level, i.e., the bottom edge of the window. Create a new method \texttt{is\_airborne()} that will return \texttt{True} if \texttt{y} position of the bird is above \texttt{-1} (note, you do not need an explicit \texttt{if} for this, nor do you need to write \texttt{True} or \texttt{False} anywhere, think how this can be done without these).

In the main loop add the check for \texttt{bird.is\_airborne()} condition so that it continues until player presses \texttt{"escape"} or the bird hits the ground.

Add \texttt{is\_airborne} method to \texttt{FlappyBird} class.
Use it in \texttt{code05.py} as an additional conditionfor the game loop.

\hypertarget{computed-attribute-property}{%
\section{\texorpdfstring{Computed attribute \texttt{@property}}{Computed attribute @property}}\label{computed-attribute-property}}

As was explained the in ``Object-oriented programming'' section above, properties describe state of an object, whereas methods describe what an object can do or what you do to an object. Our \texttt{is\_airborne()} method breaks this logic: It describes the \emph{state} of the bird but we \emph{call} it (use it) as a method. What we have here is a \emph{computed} property that is inferred from other properties of an object. In our case, we infer property \texttt{is\_airborne} from \texttt{y}. We could, of course, make \texttt{is\_airborne} into a real property by defining it in the constructor and then updating it inside \texttt{update()} method. However, we will instead use a cool feature (called \href{https://www.python.org/dev/peps/pep-0318/}{decorators}) to turn a method into a read-only property. The only thing you need to do is to add \texttt{@property} decorator right above the \texttt{def\ is\_airborne(self):} line and drop brackets when using it in the main loop (so just \texttt{bird.is\_airborne} instead of \texttt{bird.is\_airborne()}).

\texttt{@property} tells Python that the method right below \textbf{will} (must!) return a value and that outside world should see it not as a method but as a \emph{property}. You can use it to make properties read-only, so that they could not be (easily) changed from outside or to create properties that are computed on-the-fly as in our example.

Note that difference is not so much of practical implementation (changes we made to the code were minimal) but of a conceptual nature: Object's states should be properties not methods. In our small example this may look like an overkill but in a moderately complex project even small conceptual blurring of lines could make it harder to understand the code.

Turn \texttt{is\_airborne} into a property.
Use it as property in \texttt{code06.py}.

\hypertarget{an-opening-in-an-obstacle}{%
\section{An opening in an obstacle}\label{an-opening-in-an-obstacle}}

We aim of the game is for the bird to fly avoiding obstacles. An obstacle consist of two rectangle, one that protrudes from above and another one from below. The opening between them gives the bird an opportunity to fly through. So let us begin by writing a code (in the Jupyter notebook) that would generate a random opening, characterized by \texttt{y\_bottom} and \texttt{y\_top} based on four parameters:

\begin{itemize}
\tightlist
\item
  \texttt{lower\_margin} : the lower margin relative to the bottom of the screen, i.e., the \texttt{y\_bottom} cannot be closer to -1 than that.
\item
  \texttt{upper\_margin} : the upper margin relative to the top of the screen, i.e., the \texttt{y\_top} cannot be closer to 1 than that.
\item
  \texttt{min\_size} : the minimal size of the opening, i.e., minimal distance between \texttt{y\_top} and \texttt{y\_bottom}.
\item
  \texttt{max\_size} : the maximal size of the opening, i.e., maximal distance between \texttt{y\_top} and \texttt{y\_bottom}.
\end{itemize}

Write a code that assume certain values for each parameter (e.g., \texttt{lower\_margin\ =\ 0.2}, \texttt{upper\_margin\ =\ 0.2}, \texttt{min\_size\ =\ 0.2}, \texttt{max\_size\ =\ 0.4}) and generates a random pair \texttt{(y\_bottom,\ y\_top)} that satisfies the conditions.

Write a random opening code in a Jupiter notebook.

\hypertarget{an-obstacle}{%
\section{An obstacle}\label{an-obstacle}}

Now let us create an \texttt{Obstacle} class (put it into a separate file). It will consist of two rectangles, one protruding from the top and the other one from the bottom, with a random opening in between. At the moment you need six settings to describe an \texttt{Obstacle}: The four parameters that define a random opening plus a width of rectangles and their color. Describe them as a separate group in the settings files (probably under \texttt{"Obstacles"}) and pass them to the constructor of the \texttt{Obstacle} class.

In the constructor, generate a random opening (you have the code for this already) and create the two rectangles both \texttt{width} wide, one going from the top till \texttt{y\_top}, another one from the bottom till \texttt{y\_bottom}. Place both horizontally at the right edge of the window but so you could see them. Decide on how you will store the two rectangles, you can put them into two different attributes (e.g., \texttt{upper\_rect} and \texttt{lower\_rect}) or have them in a list. I would suggest the latter approach, as it will simplify your future code. Think about which parameters you need for the \texttt{\_\_init\_\_()} constructor function.

You also will need a \texttt{draw()} method that simply draws both rectangles. Implement the class in a separate file, then create and draw a single obstacle in the main code to check that it looks right.

Create \texttt{Obstacle} class in a separate file.
Use it in \texttt{code07.py}.

\hypertarget{a-moving-obstacle}{%
\section{A moving obstacle}\label{a-moving-obstacle}}

Conceptually, our bird fly towards an obstacle but instead we will induce perception of its motion by moving obstacles from right to left. Define a new \texttt{speed} setting for an \texttt{Obstacle} class, it should be in \texttt{norm\ units\ per\ second} and create an \texttt{update} method that would change horizontal position of both rectangles based on the amount of time that passed between the calls. This is similar to how we updated bird's position based on its speed, so follow the same logic and think about which additional attributes you require and how you store and use any relevant information.

Call \texttt{update()} at the same place that you update bird's location in the main loop and check that the obstacle is moving from right to left.

Add \texttt{update} method to \texttt{Obstacle} class.
Use it in \texttt{code08.py}.

\hypertarget{hitting-the-wall}{%
\section{Hitting the wall}\label{hitting-the-wall}}

At the moment, our bird is flying through the obstacle like it is not there. But it is! Luckily for us, PsychoPy makes implementing this very easy, as it can check whether two stimuli overlap using \href{https://psychopy.org/api/visual/shapestim.html\#psychopy.visual.ShapeStim.overlaps}{overlaps()} method of one of them (and the second stimulus is passed as an argument).

Thus, to check whether the bird hit the wall, we just need to create a method (let us call it \texttt{check\_if\_hit}) in an \texttt{Obstacle} class that will take a bird object and check whether it \href{https://psychopy.org/api/visual/shapestim.html\#psychopy.visual.ShapeStim.overlaps}{overlaps()} with one of the rectangles. Remember, our \texttt{FlappyBird} is a descendant of the \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}, so we can pass it to the \href{https://psychopy.org/api/visual/shapestim.html\#psychopy.visual.ShapeStim.overlaps}{overlaps()} method directly (advantage of using the inheritance!)

In the main game loop, add the check for the bird \emph{not} hitting the obstacle to the main condition (so now you should have three things to check for).
Test your code by flying the bird into the wall. Also, by flying your bird through the opening. Note that if our settings make it too tricky, modify them to make the opening larger.

Add \texttt{check\_if\_hit} method to \texttt{Obstacle} class.
Use it in \texttt{code09.py}.

\hypertarget{an-obstacle-manager}{%
\section{An obstacle manager}\label{an-obstacle-manager}}

A game with a single obstacle is no fun but before we add more, we need a class that will manage them for us. Let us call it \texttt{ObstaclesManager}. For the moment, it will simply wrap up all functionality that we implemented in the main script. In the constructor, it should create a \emph{list} attribute for obstacle objects and add a first one, it should also implement methods \texttt{draw()}, \texttt{update()}, and \texttt{check\_if\_hit()} that draws, updates, and checks for an overlap with a bird for \emph{all} obstacles on the list. For the moment we will still have just one of them in the list but implementing things in the loop means it will be easier to add more. Create the class and then use it in the main script.

There should be no actual changes of how the game plays, just the code refactoring. However, it helps us to hide the management part from the main script (making it easier to understand) and, if you did everything correctly, the code should ``just work'' once you replace \texttt{Obstacle} with \texttt{ObstaclesManager} object.

Create \texttt{ObstaclesManager} class.
Use it in \texttt{code10.py}.

\hypertarget{loads-of-obstacles}{%
\section{Loads of obstacles}\label{loads-of-obstacles}}

Now we are ready to add more obstacles. You need to update the \texttt{update} method of the \texttt{ObstaclesManager} so that it adds a new obstacle to the list after a random time interval. Define a new setting \texttt{Spawn\ time}, a list of two values that define a minimal and maximal time between spawns, and create a \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{CountdownTimer} (or a \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock}, remember they differ only in whether time is subtracted or added) attributed. Whenever the timer is up, add a new obstacle to the list, generate a new delay, and set the timer again. Note that now you need settings and a Window in the \texttt{update} because they are required for creating a new obstacle. Think how you can store them for later use in the constructor.

Do you need to change anything in the main script? Check that more obstacles appear over time!

Update \texttt{update} of the \texttt{ObstaclesManager} class.

\hypertarget{removing-redundant-obstacles}{%
\section{Removing redundant obstacles}\label{removing-redundant-obstacles}}

Once the obstacle is past the left edge of the screen (its x-axis position is less than \texttt{-1}) we need to remove it from the list. Otherwise, we will waste a lot of time and memory keeping track and drawing obstacles that are neither relevant, nor visible. Think about how you would implement this before reading further.

First, we need to compute the horizontal position of an obstacle. You can deduce it from \texttt{pos} attribute of one of the rectangles and implement this use of attribute (\texttt{pos} of \texttt{Obstacle}) of an attribute (\texttt{obstacles} of \texttt{ObstaclesManager}) directly. However, working with attributes of attributes makes code harder to read and to maintain. Instead, add a new computed property \texttt{x} to \texttt{Obstacle} class that would return a single number (horizontal position) using \texttt{@property} decorator we used for the bird's \texttt{is\_airborne} dynamic attribute.

Update the \texttt{update} method of the \texttt{ObstaclesManager} to check the position the \emph{first} obstacle in the list. If it less than -1, simply \href{https://docs.python.org/3.1/tutorial/datastructures.html}{pop} it from the list. Why the first one? Because any other obstacle in the list was added later and, therefore, must be further to the right. Why \emph{only} the first one? If we assume both a reasonable motion speed and a reasonable spawn delay, it is very unlikely that more than one obstacles reaches the left edge at the same time.

Note that for safety reasons, you must first check that the \texttt{obstacles} attribute is not empty! Hint, when used in a conditional statement directly, empty list evaluates to \texttt{False}. Debug the code to make sure that obstacles are indeed removed. You can either use a different cut-off point (e.g., -0.25) to see that easier or put a break point at the line that pops the redundant obstacle (better still, do both!)

Update \texttt{update} of the \texttt{ObstaclesManager} class.

\hypertarget{keeping-the-score}{%
\section{Keeping the score}\label{keeping-the-score}}

It is hard to brag about your bird-flying skills, if you do not how many obstacles did you fly through. Let us add the score! First, create a \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} (call it \texttt{score\_text}) and put it somewhere one the screen, e.g., a top-left or top-right corner. Initialize its text to \texttt{"0"}. Draw it in the main loop. Make sure it works before you continue.

To keep the score, we need to count the number of obstacles that the bird clears on every frame and add it to the total score. As with the removal of redundant obstacles, it will be either zero or one obstacle that crossed the middle of the screen. But in this case, it is not the leftmost that we have to check but the \emph{leftmost} among those that did not yet cross the mid-line. There are different way you can approach this, so think how you would approach this before reading on. And if you came up with a different plan, by all means -- implement it!

My way of doing this is to introduce a new attribute \texttt{scored\ =\ False} and a method \texttt{score()} to the \texttt{Obstacle} class. In the \texttt{score()} method, if the object crossed the \texttt{0} line \emph{and} has not been scored, it marked as \texttt{scored} and the method returns \texttt{1}. Otherwise, the object was either already scored or did not cross the mid-line yet, so it returns \texttt{0}. Next, I added a \texttt{score()} method to the \texttt{ObstaclesManager} that simply computes the total score (sum of) scores of all obstacles in the list. In the main script this score is added to a \texttt{score} variable that, in turn, is used to update \texttt{score\_text}.

Update your code anduse it in \texttt{code11.py}.

\hypertarget{a-foundation}{%
\section{A foundation}\label{a-foundation}}

This is just a foundation of a game, so feel free to add to it. Animated bird? Difficulty levels? Different kinds of obstacles? High-score table?

\hypertarget{seminar-02-06}{%
\chapter{Guitar Hero: staircase and iterator functions}\label{seminar-02-06}}

\hypertarget{getting-the-difficulty-just-right}{%
\section{Getting the difficulty just right}\label{getting-the-difficulty-just-right}}

In game design, one of the hardest things to get right is difficulty. Make your game too easy and it will be boring. Make it too hard and only hardcore fans will play and only for \href{https://www.imdb.com/title/tt4975856/}{an achievement}. Thus, you would like to make your game hard enough to push a player to the limit but not much harder than that, so not to frustrate them. One way to solve this conundrum is to create different preset difficulty levels. An alternative way is to make a game that adapts its difficulty to the player.

The same is true for psychophysical experiments. You want to test ability of your participants to perform a certain task at their limit for one simple reason: At this \emph{threshold} point influence of any additional factor, whether positive or negative, is most pronounced. For example, use an unusual stimulus configuration or increase attentional load and performance will probably drop. Allow to preallocate attention via cuing or use a prime that is congruent with a target and performance is likely to improve. Of course, these manipulations will have the same overall effect also when the task is particularly easy or maddeningly hard but it will much more difficult to \emph{measure} this effect. It is one thing if performance drops from 75\% to 65\% than if it goes from 98\% to 95\% or from 53\% to 52\%\footnote{Here, I assume that 50\% is chance level performance.} or vice versa. The silliest thing you can do is to \emph{hope} that performance will allow you too see the effect of the factors that you manipulated. In things like these, knowledge and careful design is definitely superior to hope.

Thus, you want performance of your participants to be approximately in the middle between the ceiling (100\% performance, fastest response times, super easy) and the floor (chance level performance, slowest response times, super hard or even impossible). But how do you know where this magic point for a \emph{particular} person is? Particularly, if the task is novel so you have little information to guide you\footnote{It is the usual paradox that in order to optimally measure a threshold condition for a particular task, you should measure at or around the threshold. But if you already know where to measure, you don't need to measure.}. The solution is to adjust the difficulty on-the-fly based on participant's responses. For example, if you have a two-alternatives-forced-choice task, you can use a two-up-one-down staircase (difficulty increases after two correct responses and decreases after one mistake) that targets 70.7\% performance threshold. There are different methods and even different ways to use the same core method (e.g., does the step stays constant or changes, what is the run termination criteria, etc.), so it is always a good idea to refresh your memory and read about \href{https://doi.org/10.3758/BF03194543}{adaptive procedures} when designing your next experiment.

In our game, we will use a very simple 3-up-1-down staircase: get the three responses correct on a row and things get faster, make a mistake and the game slows down. We'll see how fast you can go! First, you will implement it by hand and then we will use its \href{https://psychopy.org/api/data.html\#stairhandler}{PsychoPy implementation}.

\hypertarget{guitar-hero}{%
\section{Guitar Hero}\label{guitar-hero}}

Today, we will program Guitar Hero game. In the original game, you must play notes on a guitar-shaped controller pressing buttons at the right time, just like when you actually play music on a guitar. On the one hand, it is a straightforward and repetitive motor task. On the other hand, take a fast and complicated music piece and it'll take many minutes or even hours of practice to get it right. It is a lot of fun, as music cues and primes your responses. The same idea of music-synchronized-actions was used in \emph{Raymon Legends} music levels where jumps and hits are timed to drums or bass. It is a bizarrely cool dance-like sequence and a very satisfying experience, also when watching pros to do it (I happened to have couple in my household).

We will program this game (sans Guitar and Hero) and you can see it in the video below. The player must press a correct key (\emph{left}, \emph{down}, or \emph{right}) whenever the target crosses the line. Pressing it to early or too late counts as a mistake. Of course, the faster the targets go, the harder it is to respond on time and with a correct key. As I wrote above, we will use the 3-up-1-down staircase procedure to control for that.

As per usual, we will take gradual approach:

\begin{itemize}
\tightlist
\item
  Boilerplate code
\item
  Create a class for individual moving targets
\item
  Create a timed-response task class that will create them (using cool generators), dispose of them, check the response, and adjust staircase.
\item
  Add bells-and-whistles like score and time limited runs.
\end{itemize}

\hypertarget{boilerplate}{%
\section{Boilerplate}\label{boilerplate}}

Create our usual boilerplate code in \emph{code01.py}:

\begin{itemize}
\tightlist
\item
  Create file with basic settings (e.g., window size, I've picked 640×480 but choose whatever looks good on your screen) to which you can add later on.
\item
  Import what is needed from PsychoPy.
\item
  Create a window.
\item
  Create our usual main game loop with \texttt{gamover} variable, flipping the window, and checking for \emph{escape} button press.
\end{itemize}

Put your boilerplate code into \emph{code01.py}.

\hypertarget{target-and-timedresponsetask-classes}{%
\section{Target and TimedResponseTask classes}\label{target-and-timedresponsetask-classes}}

Our main work horse will be \texttt{TimedResponseTask} class. It will spawn a new random \texttt{Target} at random intervals (which will depend on speed), pass speed information to moving targets, and remove targets, once they disappear below the screen. The \texttt{Target} class will use \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{visual.Rect}
\footnote{Inheriting from \texttt{visual.Rect} would've make things simpler but, at least in PsychoPy 2021.1.4, it does not work due to so technical glitch.} with some extra bells and whistles to make it appear at the right location, move at the right speed, change its line color (indicating a correct response), compute whether it is already off the screen, etc. We will start with a single target first.

\hypertarget{target-class-static}{%
\section{Target class: static}\label{target-class-static}}

First, create a \texttt{Target} class: a colored rectangle in one of the three positions that starts at the top of the window and moves down at a specific speed. Its constructor should take PsychoPy window as a parameter (you will need it to create the rectangle as an attribute), position index (\texttt{ipos}, from 0 to 2), speed (\texttt{speed}, in \texttt{"norm"} units \emph{per second}), and common settings (\texttt{settings}, a dictionary with target-specific settings from our settings file) . The only thing we need to do right now in the constructor is to create a color rectangle (see below) and store both \texttt{ipos} and \texttt{speed} as attributes for later use. In addition, define a \texttt{score} attribute and set it to \texttt{None}. This will hold the score the participant got for this target and \texttt{None} means that it has not been responded upon yet.

The second parameter --- position index --- determines the horizontal position of the target and its color (to make targets more fun and distinct). For my code, I have decided to make rectangle 0.4 norm units wide and 0.1 norm units high. The leftmost \emph{red} rectangle (for \texttt{ipos} 0), is centered at -0.5, the middle \emph{green} one is dead center, and the rightmost \emph{blue} rectangle is centered at 0.5. I've defined all these in my \texttt{settings.json} file under \texttt{Target} group. Think about how you can compute both color and position for a target from \texttt{ipos} and \texttt{settings} without using if-else statements. Also, think about the y-position of the rectangle, so it appears right at the top of the window.

The second method you need is \texttt{draw()} which simply draws the rectangle\footnote{Again, inheriting from \texttt{visual.Rect()} would have taken care of this for you.}. Test it by creating a target at one of the position (or three targets at all three positions) and drawing them in the main loop. You should get nice looking but static rectangle(s).

Put updated code in \texttt{code02.py} and create the class \texttt{Target} in a separate file.

\hypertarget{target-class-moving}{%
\section{Target class: moving}\label{target-class-moving}}

Our targets fall down at speed defined by their \texttt{speed} attribute. Later on, we will change that attribute dynamically to speed up or slow down their fall.

For the actual falling down, implement a new method, call it \texttt{fall()}, that will update target's position on every frame. The speed is in \texttt{norm\ units\ per\ second}, thus, to compute the change in vertical position you also need to know the how much time \emph{in seconds} has elapsed since last position update. The simplest way to do this is by using a \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} class. You create it as an attribute in the constructor and then, in the \texttt{fall()} method you use its current time to compute and apply a change in vertical position of the rectangle. Don't forget to reset the clock after that!

Include \texttt{fall()} method call in the main loop and see how the target falls. Experiment with falling speed!

Put updated code in \texttt{code03.py} and update the class \texttt{Target}.

\hypertarget{iteratorgenerator-functions}{%
\section{Iterator/Generator functions}\label{iteratorgenerator-functions}}

In the next section, we will create a \texttt{TimedResponseTask} class that will generate targets at a random location and after a random interval. We can, of course, do it directly in the class but where's fun in that?! Instead, we will use this as an opportunity to learn about iterator/generator functions. An iterator is a \emph{function} that uses \texttt{yield} instead of \texttt{return} statement to, well, \emph{yield} a value. It \emph{yields} it, because the function itself \emph{returns} an iterator object that you can iterate over in a for loop or via \texttt{next()} function. Importantly, \texttt{yield} ``freezes'' execution of the function and the next time you call the function \emph{it continues from that point} rather than from the start of the function. Once you reach the end of the function, it automatically raises \texttt{StopIteration()} exception, so you don't need to worry about how to communicate that you ran out of items. It may sound confusing but it is really simple. Here an example to illustrate this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ iterator\_fun():}
    \ControlFlowTok{yield} \DecValTok{3}
    \ControlFlowTok{yield} \DecValTok{1}
    \ControlFlowTok{yield} \StringTok{"wow!"}
  
\CommentTok{\# function returns an iterator, not a value!}
\BuiltInTok{print}\NormalTok{(iterator\_fun())}

\CommentTok{\# iterating via for loop}
\CommentTok{\#\textgreater{} \textless{}generator object iterator\_fun at 0x0000018E2F7A7370\textgreater{}}
\ControlFlowTok{for}\NormalTok{ elem }\KeywordTok{in}\NormalTok{ iterator\_fun():}
    \BuiltInTok{print}\NormalTok{(elem)}
    
\CommentTok{\# iterating via next(), note you use an iterator object }
\CommentTok{\# that function returned, not the function itself!}
\CommentTok{\#\textgreater{} 3}
\CommentTok{\#\textgreater{} 1}
\CommentTok{\#\textgreater{} wow!}
\NormalTok{an\_iterator }\OperatorTok{=}\NormalTok{ iterator\_fun()  }

\CommentTok{\# now you can use an\_iterator to get a next item from it}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(an\_iterator))}
\CommentTok{\#\textgreater{} 3}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(an\_iterator))}
\CommentTok{\#\textgreater{} 1}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(an\_iterator))}
\CommentTok{\#\textgreater{} wow!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# next call will raise an exception StopIteration(), so I do not run it here.}
\BuiltInTok{print}\NormalTok{(}\BuiltInTok{next}\NormalTok{(iterator\_var))}
\end{Highlighting}
\end{Shaded}

This format makes writing iterators very easy, just \texttt{yield} whatever you want in an order you want and Python will take care of the rest. You can also \texttt{yield} in a loop, inside an if-else statement, etc. Look at the code below and figure out what will be printed out before running it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ iterator\_fun():}
  \ControlFlowTok{for}\NormalTok{ e }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{4}\NormalTok{):}
    \ControlFlowTok{if}\NormalTok{ e }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1}\NormalTok{:}
      \ControlFlowTok{yield}\NormalTok{ e}

\ControlFlowTok{for}\NormalTok{ item }\KeywordTok{in}\NormalTok{ iterator\_fun():}
  \BuiltInTok{print}\NormalTok{(item)}
\end{Highlighting}
\end{Shaded}

For our \texttt{TimedResponseTask} class, we will need two \emph{generators}. They are \emph{generators} rather than \emph{iterators} because both will be endless. One that generates a random delay until the next target and one that generates a random target position (0, 1, or 2). Implement both in a separate file (I called it \emph{generators.py}).

The \texttt{time\_to\_next\_target\_generator()} function should take a tuple of two float values, which define shortest and longest allowed delays, as a parameter and \emph{yield} a \href{https://docs.python.org/3/library/random.html\#random.uniform}{random number} within this range in an \emph{endless} loop. We need the endless loop (\texttt{while\ True:} will do) because we do not know how many values we will need, so we just generate as many as needed.

The \texttt{next\_target\_generator()} will be a bit more interesting. It can just return a \href{https://docs.python.org/3/library/random.html\#random.choice}{random.choice} from 0, 1, and 2 but where is fun in that? Instead, we will make it a bit more complicated to ensure that all three targets appear equal number of times within \emph{3N} trials, where \emph{N} will be a parameter of the generator function. This would ensure random, reasonably unpredictable but balanced targets in the short run. Remember, in the long run random choice will always give us a balanced uniform distribution but there is not such guarantee for the shorter runs of a few trials. First, you should create a list where each target appears N times (think how you can do it using \href{https://docs.python.org/3/library/functions.html\#func-range}{range()}, \href{https://docs.python.org/3/library/functions.html\#func-list}{list()} and \href{https://docs.python.org/3/library/stdtypes.html\#common-sequence-operations}{*}). Then, create an endless loop (again, we don't know how many values we will need) in which you 1) shuffle elements of the list, 2) yield one element at a time via for loop. Once you run out of elements, you shuffle them again and yield one by one again. Then repeat. And again, and again. Endless loop!

I would suggest creating and testing both function in a Jupyter notebook first and then putting them in a separate file (e.g., \emph{generators.py}). Be careful if you decide to use a for loop instead of \texttt{next()} for testing. Remember, both a generators and will never run out of items to yield for a for loop!

Put both generators into \emph{generators.py}.

\hypertarget{timedresponsetask-class}{%
\section{TimedResponseTask class}\label{timedresponsetask-class}}

Now we are ready to create the \texttt{TimedResponseTask} class. For our first take, it will create targets at a random location (\texttt{next\_target\_generator()}) after a random interval (\texttt{time\_to\_next\_target\_generator()}) plus take care of moving and drawing all of them. More bells and whistles (disposing of targets that went past the screen, changing the speed, checking response validity, etc.) will come later.

\textbf{For the constructor}, we definitely need PsychoPy window as a parameter, because we need it every time we create a new target. In addition, we need to pass a dictionary with settings for the task (initial speed, a tuple with range for time intervals between targets for \texttt{time\_to\_next\_target\_generator()}, and number of target repetitions for the \texttt{next\_target\_generator()}) and a dictionary with settings for the \texttt{Target} class (we need it every time we create a new target). We will use these parameters beyond the constructor, so save them as attributes. Plus, create an attribute \texttt{targets} and initialize it to an empty list (we will store \texttt{Target} objects in it), and create attributes for both generator objects using the appropriate parameters. Also create a \texttt{speed\_factor} attribute and set it to 1. We will use it later to control both the speed of motion and how frequently the targets are generated. The higher is the factor, the faster targets move and the shorter is the interval to the target and vice versa. Finally, we need a \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{Clock} that will count the time to the moment when we need to generate a new target (\texttt{new\_target\_timer}) and an attribute that will hold that time (\texttt{time\_till\_next\_target}). Initialize the latter to the \texttt{next()} item from time-to-next-target generator (remember, you need to use the attribute, which is a generator object that function returned, not the function itself).

Now we need to add three methods \texttt{draw}, \texttt{update}, and \texttt{add\_next\_target}. The first one is easy, it simply draws all \texttt{targets} in a for loop. The second is also easy, it makes all targets \texttt{fall} plus, after the loop, it should call \texttt{add\_next\_target} method. The \texttt{add\_next\_target} method should check whether the elapsed time for \texttt{new\_target\_timer} \textbf{times the \texttt{speed\_factor}} (as the speed increases, the time to the next target goes faster) has exceeded the \texttt{time\_till\_next\_target.}If that is indeed the case, create a new random target (get the \texttt{next()} position from the position generator and remember to pass \texttt{speed} \emph{times} \texttt{speed\_factor}!), add it to the list of targets, reset the timer and get new \texttt{time\_till\_next\_target} using \texttt{next()} item from the time generator.

In the main file, create \texttt{TimedResponsTask} object (use a name you like) and call its \texttt{draw} and \texttt{update} methods in the main loop. You should see targets appearing at random and falling down consistently.

Put updated code in \emph{code04.py} and create the class \texttt{TimedResponseTask}.

\hypertarget{disposing-of-targets}{%
\section{Disposing of targets}\label{disposing-of-targets}}

Currently, our targets keep falling down even when they are below the screen. This will not affect the performance \emph{immediately} but it will be taxing both memory and CPU, so we should dispose of them. In the \texttt{Target} class, create a new read-only (computed) \texttt{@property} called \texttt{is\_below\_the\_screen} that returns \texttt{True} if the upper edge of the target is below the lower edge of the screen (\texttt{False} otherwise, of course and you definitely do not need if-else!).

Next, in the \texttt{update} method of \texttt{TimedResponseTask}, add a second loop (or modify the existing loop) where you delete any object that \texttt{is\_below\_the\_screen}.

For debugging, run the main code, wait until at least one target falls below the screen, put a break point and check \texttt{targets} attribute. Its length should match the number of visible targets, not of the total generated targets.

Update classes \texttt{Target} and \texttt{TimedResponseTask}.

\hypertarget{finishing-line}{%
\section{Finishing line}\label{finishing-line}}

Add a new visual attribute to the \texttt{TimedResponseTask} that is a horizontal \href{https://psychopy.org/api/visual/line.html\#psychopy.visual.Line}{line}. The task of the player will be to press a corresponding key whenever a target crosses (overlaps with) the line. For now, create it as an attribute in the constructor (pick the vertical location you like) and draw it inside the \texttt{draw()} method.

Update class \texttt{TimedResponseTask}.

\hypertarget{response}{%
\section{Response}\label{response}}

Now the real fun begins! We will allow a player to press keys and check whether a corresponding target is on the line. For this, we need new methods for both \texttt{Target} and \texttt{TimedResponseTask} classes. For the \texttt{Target}, implement a new method class \texttt{overlaps()} that will take a vertical position (of the finishing line) as the only float number parameter. In the method, first you check that the \texttt{score} attribute is \texttt{None}. If it \emph{not} \texttt{None} that means that the player already responded on to the target and they are not allowed to respond to it twice. If it is \texttt{None}, compute a score using the following formula:
\[score = int \left(10 - 10 \cdot \frac{|y_{target} - y_{line}|}{h_{target} / 2} \right)\]
where \(y_{target}\) is the vertical center of the target, \(y_{line}\) is the vertical position of the line (you get it as a function parameter), \(h_{target}\) is height of the target, \(||\) means absolute value (use \href{https://docs.python.org/3/library/math.html\#math.fabs}{fabs} function from \emph{math} library for that), and \texttt{10} is an arbitrary scaling factor (you can use any integer). Study the formula and you will see that score is 10 if the target's center is right on the line but decreases linearly with any displacement. Once the target is off the line, the score becomes negative. We convert it to \texttt{int}, because we want simple scores (floats look messy for this). Compute the score and store in a \emph{temporary local variable}. If the value is \emph{positive}, that means success, so you should store this value permanently in the \texttt{score} attribute, change line color of the rectangle to white (to show the player that they got it right), and return \texttt{True} (yes, target does overlap with the line!). For all other outcomes, you return \texttt{False}. This means that either the response was already made or the target does not overlap with the line.

In the \texttt{TimerResponseTask} class, we need a new method \texttt{check()} that will take position of the target based on the key press (so if a player pressed \emph{left} key, the position will 0, \emph{down} is 1, and \emph{right} is 2). Loop over targets and if a target's position (\texttt{ipos} attribute) matches the position of the key press (parameter of the function) \emph{and} target overlaps with the line (the \texttt{overlaps()} method returns \texttt{True}), return the \texttt{score} attribute of that target. Note that the condition order is important here! You need to check for the overlap \emph{only} if target position matches the key. If you ran out of targets to check that means that the player pressed a wrong key or at the wrong time, so you should return \texttt{0} (means ``mistake'').

In the main loop, add \texttt{"left"}, \texttt{"down"}, and \texttt{"right"} to the key list of \href{https://psychopy.org/api/event.html\#psychopy.event.getKeys}{getKeys()} call. Then, if any of these three keys are pressed, translate that into a position, respectively, 0, 1, and 2 (think how you can do it without if-else via a dictionary), and call the new \texttt{check} method of the \texttt{TimedResponseClass}. Test the code, targets' edges should turn white, if you time your key press correctly!

Put updated code in \emph{code05.py}, update \texttt{Target} and \texttt{TimedResponseTask} classes.

\hypertarget{score}{%
\section{Score}\label{score}}

Playing is more fun when you can see how well you are doing. Let us add a simple score indicator that is updated with response score. You already know how you can do it via \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} stimulus but you also already know how you can inherit from a base class and extend its functionality. This is what we will do here, as the class will record and draw the score (that part is covered by the inheritance).

Create a new class (I have called it \texttt{ScoreText}) that inherits from \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim}. In the constructor, you need to create an integer attribute that will hold current \texttt{score} and initialize it 0. Plus, call ancestor's constructor via \texttt{super().\_\_init\_\_(...)} to initialize and place the text stimulus (I've picked top left corner). Think about parameters that the constructor and ancestor's constructor need.

Next, we need to update the score (both its numeric form \emph{and} the text that we draw) every time participant presses a key. We could implement the code \emph{outside} of the class but that is a fairly bad idea, as it puts class-related code elsewhere. We could also implement a ``normal'' method, e.g., \texttt{add()} that will take care of that. Instead, we will implement a \emph{special} method \href{https://docs.python.org/3/reference/datamodel.html\#object.__iadd__}{\textbf{iadd}} that allows to ``add to'' the object. It takes a single parameter (in addition to the compulsory \texttt{self}, of course), performs ``adding to the self'' operation (whatever that means with respect to your object, can be mathematical addition for an attribute, concatenation of the string, adding to the list, etc.), and \textbf{returns back the reference to itself}, i.e., returns \texttt{self} not a value of any attribute! Here's how it works:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ AddIt():}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
        \VariableTok{self}\NormalTok{.number }\OperatorTok{=} \DecValTok{0}
        
    \KeywordTok{def} \FunctionTok{\_\_iadd\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, addendum):}
        \VariableTok{self}\NormalTok{.number }\OperatorTok{+=}\NormalTok{ addendum}
        \ControlFlowTok{return} \VariableTok{self} \CommentTok{\# important!!!}


\NormalTok{adder }\OperatorTok{=}\NormalTok{ AddIt()}
\BuiltInTok{print}\NormalTok{(adder.number)}
\CommentTok{\#\textgreater{} 0}
\NormalTok{adder }\OperatorTok{+=} \DecValTok{10}
\BuiltInTok{print}\NormalTok{(adder.number)}
\CommentTok{\#\textgreater{} 10}
\end{Highlighting}
\end{Shaded}

Implement that special method for your class, so we can do \texttt{score\_stim\ +=\ \ timed\_task.check(...)}. Remember, you have to update both numeric \emph{and} visual representations of the score in that method! Add the score to the main code.

Put updated code in \texttt{code06.py}, create \texttt{ScoreText} class.

\hypertarget{staircase}{%
\section{Staircase}\label{staircase}}

We will implement the staircase as part of the \texttt{TimerResponseTask} class, so it can speed up and slow down itself. For this, we will need an attribute that counts number of \emph{consecutive} correct responses (I, typically, call it \texttt{correct\_in\_a\_row} or something like that). Create and initialize it to zero in the constructor.

Next, create a new method \texttt{staircase()} that will take a single parameter (beyond \texttt{self}) on whether the response was \texttt{correct} or not. If it was, increment \texttt{correct\_in\_a\_row} by one and check whether it reached 3. If it did, increase the \texttt{speed\_factor} by \emph{multiplying} it by some chosen factor (I've picked 1.3) and resetting \texttt{correct\_in\_a\_row} to 0. This is equivalent to using a logarithmic step as our \texttt{speed\_factor} is adjusted as a fraction of its magnitude. Alternatively, if the response was not correct, \emph{divide} \texttt{speed\_factor} by the same number (e.g., 1.3, so slowing things down) and again, reset \texttt{correct\_in\_a\_row} to 0. After that, loop over all targets and update their speed based on \texttt{speed} and \texttt{speed\_factor} attributes.

You need to call this method inside the \texttt{check} method, think then and how.

Update \texttt{TimedTaskResponse} class.

\hypertarget{limiting-time}{%
\section{Limiting time}\label{limiting-time}}

Let us add a competitive edge by limiting the run time to 20 seconds (you can pick your own duration, of course, and you definitely want to be a setting). Create an additional outer loop, so that the game can be played many times over. Once the round is over, show the latest state (redrawing all game objects) plus the ``Round over'' sign and wait for the player to press either \emph{escape} (then you exit the game) or \emph{space} (to start the next round). Remember to recreate all game objects anew for the next round (or create a \texttt{reset} method for all of them).

Put updated code in \texttt{code07.py}.

\hypertarget{using-psychopys-stairhandler}{%
\section{Using PsychoPy's StairHandler}\label{using-psychopys-stairhandler}}

Now that you know how to program a very basic staircase, let us use its much more flexible implementation by PsychoPy via \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} class. We will use so as to replicate the staircase that we already implemented. However, it is capable of much more and PsychoPy has implementation for other adaptive methods, such as parametric \href{https://psychopy.org/api/data.html\#psychopy.data.PsiHandler}{Psi} or \href{https://psychopy.org/api/data.html\#questhandler}{Quest} approaches. I strongly recommend consulting the literature to decide which method is best suited for your experiment and then relying on PsychoPy's implementation in your code.

We will need to modify our \texttt{TimedResponseTask}, so let us create its twin \texttt{TimedResponseTask2} (or \texttt{TimedResponseTaskPsychoPy}, if you find that more intuitive). Simply copy-paste the entire code, modify the name, import and use it in your \emph{code08.py} code. Make sure everything works just as before (because you did not do anything beyond making a carbon copy).

Now let us make use of the \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} in \texttt{TimedResponseTask2}. Drop \texttt{correct\_on\_a\_row} attribute and create a \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} as \texttt{stairhandler} attribute instead. You need to specify \texttt{startVal} which is the initial value for the \texttt{speed\_factor}, thus use whatever value you had previously. \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} uses \texttt{nUp=1} and \texttt{nDown=3} by default. This matches our custom staircase, so theoretically you can use defaults by omitting these parameters. However, for the sake of code's readability, do specify these explicitly. Our steps were logarithmic, so use \texttt{stepType="log"} and a single fixed \texttt{stepSizes=-0.1}. The magnitude of \texttt{-0.1} correspond roughly to the step that we used in the custom staircase and we need the negative sign because \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} \emph{increases} the staircase level following an incorrect response. In our case, we want an exact opposite, \emph{decreasing} \texttt{speed\_factor} tp slow targets down. Hence, the negative sign that turn increase into a decrease. Finally, \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} will terminate after it reaches either desired number of trials (\texttt{nTrial}) or reversals (\texttt{nReversals}, changes from correct to incorrect responses or vice versa). These are the settings that would typically determine length of a single block/run in the real experiment. However, we limited our rounds by \emph{time}, so we only need to make sure that the \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} does not run out of trials before the run is over. Thus, specify some very large number (e.g., 1000) for both these parameters.

Once you created \texttt{stairhandler} attribute, it is ready for use via \texttt{next(self.stairhandler)}. Call it the first time in the constructor and assign the value it returns to \texttt{speed\_factor} attribute (should be whatever \texttt{startVal} you assigned to it but do put a breakpoint and double-check!)

Next, we need to modify our \texttt{staicase()} method making it much simpler. First, remove the \texttt{if\ correct:\ ...\ else:\ ...} code but leave targets' speed adjustment code intact (we still need it!). Then, let \texttt{stairhandler} adjust itself via \href{https://psychopy.org/api/data.html\#psychopy.data.StairHandler.addResponse}{addResponse()} method using an information on whether the response was correct (you already have a parameter with exactly that information). Finally, get the next \texttt{speed\_factor} exactly the same way as in the constructor. Done!

Put updated code in \texttt{code08.py} using \texttt{TimedResponseTask2}.

Your program should run very much like before but now you have many more opportunities to make it more flexible at little cost for yourself (look at \href{https://psychopy.org/api/data.html\#stairhandler}{StairHandler} settings) and to log it via one of \texttt{saveAs} methods.Let us do the latter, save staircase logs via \href{https://psychopy.org/api/data.html\#psychopy.data.StairHandler.saveAsText}{saveAsText()} after a run is over. Figure out a way to generate a unique filename for each run, so that the logs will not be overwritten.

Save staircase logs in \texttt{code09.py}.

\hypertarget{this-is-just-a-start}{%
\section{This is just a start!}\label{this-is-just-a-start}}

As per usual, think about how you can extend the game. A clock showing the remaining time is definitely missing. Auditory feedback would be nice. More positions? Random colors to confuse a player?

\hypertarget{the-snake}{%
\chapter{The Snake}\label{the-snake}}

This chapter marks the beginning of the second semester in the course, therefore we will use our first game to refresh your knowledge of Python acquired previously. We will use classes (and their instances, objects), lists, conditional statements, loops, and external setting files to program a classic game of Snake. Consults previous chapters for any information you need to complete the game.

\hypertarget{snake-game-an-overview}{%
\section{Snake game: an overview}\label{snake-game-an-overview}}

Today, we will program a good old classic: the snake game! The story is simple: you control a snake trying to eat as many apples as you can. Every time you consume an apple, snake's length increases. However, if you hit the wall or bite yourself, the game is over (or you lose one of your lives and game is over once you run out of lives).

Here is how the final product will look like.

As before, we will program the game step by step, starting with an empty gray PsychoPy window. Here is the general outline of how we will proceed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create boilerplate code to initialize PsychoPy.
\item
  Figure out how to place a square. We need this because our snake is made of square segments and lives on a rectangular grid made of squares.
\item
  Create a single segment stationary snake\footnote{Not very exciting, I know. But one has to start somewhere!}.
\item
  Make the snake move assuming a rectangular grid.
\item
  Implement ``died by hitting a wall''.
\item
  Add apples.
  7, Make the snake grow when it eats an apple.
\item
  Add check for biting itself (and dying).
\item
  Add bells-and-whistles to make game look awesome.
\end{enumerate}

As you can see, each new step builds on the previous one. Because of that do not proceed to the next step until the current one works and you fully(!) understand what each line of code does. Any leftover uncertainty will linger, grow and complicate your life disproportionately!

\hypertarget{minimal-boilerplate}{%
\section{Minimal boilerplate}\label{minimal-boilerplate}}

We need the \protect\hyperlink{psychopy-basics}{usual boilerplate} code to get us going:

\begin{itemize}
\tightlist
\item
  Create a PsychoPy window (hardcode its size, as we will compute it from settings later on).
\item
  Wait for any key press.
\item
  Close the window.
\end{itemize}

Put your code into \emph{code01.py}.

Do not forget to put the multiline comment at the top of the file, describing what we will be doing.

\hypertarget{fancy-boilerplate}{%
\section{Fancy boilerplate}\label{fancy-boilerplate}}

In the game, our snake will be composed of square segments and move on a grid made out of squares. Thus, it would be much easier to define our window size based on the size of the grid (in squares) and that of individual squares (in pixels). This way we can figure out window's height as

\[window~height~[in~pixels] = window~height~[in~squares] \times square~size~[in~pixels]\]

Note that the latter parameter determines how the game looks, double the size of the square in pixels and that will double both width and height of the window.

Now, let us think about the \emph{units} that we will use in our game. Recall that PsychoPy has \protect\hyperlink{psychopy-units}{five different units} for size and position. So, which units should we pick to make it easier to draw squares? Reread section on \protect\hyperlink{psychopy-units}{units} and think which units you would pick before continuing.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

What is your decision? My suggestion would be \texttt{"norm"} units as they make sizing squares easy, as long as we use a suitable aspect ratio for the window itself. Good news is that the formula above automatically ensures the correct aspect ratio (think why this is the case).

Before we start coding the window size computation, create a \protect\hyperlink{settings-files}{settings file} using the format of your choice that contains \texttt{grid\ size\ {[}in\ squares{]}} (with a list of two values or you could define it as \texttt{grid\ width\ {[}in\ squares{]}} plus \texttt{grid\ height\ {[}in\ squares{]}}) and \texttt{square\ size\ {[}in\ pixels{]}}\footnote{I always add units in square brackets as a reminder to my(future)self. One can deduce units from code itself but documenting them explicitly makes your life much easier.}. I would suggest to start with a 30 × 20 grid as it should give us enough space to try things out but you can always increase the resolution of the game later. As for the square size, 20 pixels should be enough (but decide based on your screen resolution).

Add the code for loading the file into \texttt{settings} variable and then use the settings to compute the window's size. Test that it works correctly by doubling (or halving) the size of the grid or of the square size.

Put your code into \emph{code02.py}.

\hypertarget{fancier-boilerplate}{%
\section{Fancier boilerplate}\label{fancier-boilerplate}}

The code for computing window size belongs to the business logic of setting up a window and, therefore, should be part of a window class code. Therefore, let us define a new \texttt{GridWindow} class that will inherit from PsychoPy \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{Window} class but modify the constructor to perform a window size computation. The new \texttt{\_\_init\_\_()} method should take grid size and square size as parameters, compute an actual size of the window in pixels, and call the \texttt{\_\_init\_\_()} method of the \emph{parent} \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{Window} class to finish the setup (if you forgot how to call parent's methods, take a look at how we implemented \protect\hyperlink{flappy-bird-class}{Flappy Bird class} by inheriting from \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}). You already have all the code you need but in the main script, so the only thing you are doing is tidying things up by moving it into the constructor where it belongs and adjusting it for use of parameter and parent methods.

Put your \texttt{GridWindow} class into a separate file (\texttt{gridwindow.py}?).

Modify the code and save main script into \emph{code03.py}.

\hypertarget{adding-a-square}{%
\section{Adding a square}\label{adding-a-square}}

As I already wrote, our game will be made of squares. Snake is made of squares. Grid it lives on is made of squares. An apple is a square\footnote{We will use a bitmap to make it look like an actual apple but it will need to be a square bitmap, so at the end the apple will still be square}. Which means we need to know the size of that square in the units of the window and we need to know where within the window each square should go based on its coordinates on the grid.

Computing the size of the square in units of window size is easy, so let us start with. If you used \texttt{"norm"} units for the PsychoPy window, we know that both its width and its height go from -1 (bottom) to 1 (top). We also know that we have to fit in \texttt{settings{[}"grid\ width\ {[}in\ squares{]}"{]}} squares horizontally and\texttt{settings{[}"grid\ height\ {[}in\ squares{]}"{]}} squares vertically (If you encoded grid size as a list of \texttt{{[}width,\ height{]}} then \texttt{settings{[}"grid\ size\ {[}in\ squares{]}"{]}{[}0{]}} and \texttt{settings{[}"grid\ size\ {[}in\ squares{]}"{]}{[}1{]}}). Compute the square width and height in the window units in the constructor method of the \texttt{GridWindow} and store it for later use as a tuple in \texttt{square\_size} attribute. Also, store the grid size in an attribute (e.g., \texttt{grid\_size}) as it will be useful for snake and apple classes later. Once you implemented the code, use \protect\hyperlink{debugging}{debugging} to check that numbers make sense. E.g., if your grid is 20 squares tall then each square should be \(0.1\) \texttt{"norm"} units tall.

Next, let us create a method that maps a position on the grid to a position in the window. This way, we can think about position of the snake or apples in terms of the grid but draw them in window coordinates. Create a new method \texttt{grid\_to\_win()} in the \texttt{GridWindow} class that takes a single parameter with a tuple of integers \texttt{(x\_index,\ y\_index)} with grid position (I called this argument \texttt{ipos}, here and in all other places, I am not counting the compulsory \texttt{self} parameter) and returns a tuple of floats \texttt{(x\_pos,\ y\_pos)} with the coordinates of the \emph{center} of the square in \emph{window} coordinates. Use \protect\hyperlink{list-comprehension}{list comprehension} to simplify the code.

Take a look at the drawing below to see the geometry of the computation. The red text shows location of red points in \emph{window norm} units, whereas the black font shows location of a square in \emph{grid index} units. Note that you need to compute where the \emph{center}(!) of the square should go.

\begin{figure}
\includegraphics[width=16.49in]{images/snake-grid} \caption{Grid versus window coordinates}\label{fig:unnamed-chunk-2}
\end{figure}

Remember to document the method following \href{https://numpydoc.readthedocs.io/en/latest/format.html}{NumPy docstring format}.

Now, test this method by creating a \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{square} (you now get its size from the \texttt{GridWindow} attribute(s) that you created) in the main script and placing it at different locations on the grid. Run the code several times, using different grid indexes or adding several squares to check that it works as intended. I.e., for a 30×20 grid, a grid coordinate \texttt{0×0} should place a square at the bottom-left corner, whereas \texttt{14×9} should put it almost at the center.

Put your code into \emph{code04.py}.

\hypertarget{a-snake-segment}{%
\section{A snake segment}\label{a-snake-segment}}

Let us think about how can we represent a snake. It consist of one or more segments. The first one is its head, while the last one is its tail\footnote{A single segment snake is a special case, as its head is also its tail!}. Thus, we can think about a snake as a \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list} of individual segments.

Consider an individual segment. We need to 1) keep track of its location in \emph{grid} coordinate system and 2) have its visual representation --- a square, just like the one you create during the previous exercise --- positioned in \emph{window} coordinate system. Good news is, you already have a method of the \texttt{GridWindow} class that maps the former on the latter, so as long as you know where the segment is on the grid, placing its square within the window is easy. Thus, each segment has two pieces of information associated with it and we could represent it as a \href{https://docs.python.org/3/tutorial/datastructures.html\#dictionaries}{dictionary} with two keys (\texttt{"pos"} (tuple of x and y in grid coordinates) and \texttt{"visuals"} (the square)) or, better still, as a class of it own.

Let us create a \texttt{SnakeSegment} class. Its constructor \texttt{\_\_init\_\_()} methods should take three parameters: 1) a PsychoPy {[}Window{]} object, 2) segment coordinates on the grid, 3) segment color. Save the grid coordinates into the \texttt{ipos} attribute (we need to keep track of it when the snake will start moving around) and reuse the code from the previous exercise when created a square. Store that square in \texttt{visuals} attribute and add a \texttt{draw()} method that simply calls the \texttt{draw()} method of the square\footnote{It would be much simpler to inherit from \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{Rect} class directly but it does not work (raises an error), at least for the version 2021.1.4 that I use.}.

Test the class by creating and drawing a snake segment in the main script. Define snake segment color in settings, create it inside a separate section \texttt{"snake"} as it will add more parameters later on.

Put your \texttt{SnakeSegment} class into a separate file (\emph{snaking.py}).

Modify the code and save main script into \emph{code05.py}.

\hypertarget{the-snake-1}{%
\section{The snake}\label{the-snake-1}}

As already noted, a snake is just a list with snake segments. Create a new class \texttt{Snake}. Its constructor should take just two parameters: a PsychoPy window object and a dictionary with settings (a \texttt{"snake"} section of our \texttt{settings} variable in the main script). In the constructor, create a single segment and put it into a \emph{list} attribute \texttt{segments}. We will have just one attribute for now but using a list already helps us in the future. Place that only segment roughly at the center of the grid. Use \texttt{grid\_size} attribute of the \texttt{GridWindow} to compute it (you will need to use a floor division \href{https://docs.python.org/3/library/operator.html\#mapping-operators-to-functions}{\texttt{\textbackslash{}\textbackslash{}}} for that). You should also store the window in an attribute for a later use, as we need it every time we create a new segment.

In addition, implement a \texttt{draw()} method that draws all \texttt{segments} in a loop. Test your code by creating and drawing a snake in the main script.

Put your \texttt{Snake} class into a separate file (\emph{snaking.py}).

Modify the code and save main script into \emph{code06.py}.

\hypertarget{get-a-move-on}{%
\section{Get a move on!}\label{get-a-move-on}}

Now we need to understand how we will move the snake given that it consist of many segments. Assume that we have a five segment snake that moves up, as in the picture below (segments are color coded to make it easier to see who goes where).

\includegraphics[width=14.36in]{images/snake-movement}

Technically, we need to move each segment to a new position. The very first ``head'' segment moves to the position above the snake. The second segment moves to where the head was before. The third moves into the previous position of the forth one, etc. We \emph{can} implement movement like that but instead we will utilize the fact that, unless colored as in the figure above, all segments look identical. Look at the uniformly colored snake below. We can ``move'' it by adding a new segment at a new location (growing a new head at the bitey end of the snake, marked as red) and clipping off the last tail segment (marked by the cross), so that the previously penultimate segment becomes the tail. The rest can stay where they are, saving us a lot of hustle when the snake is long!

\includegraphics[width=14.36in]{images/snake-movement-2}

In the program, we \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list.insert(index, value)}\footnote{We could also have used \href{https://docs.python.org/3/library/collections.html\#collections.deque}{dqueue} class from \emph{collections} library instead of the \texttt{list}. It is, essentially, a list that allows appending and popping from the left as well.} the new head segment at index 0 and we remove the tail via \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{list.pop()}.

To keep things neat and tidy, we will implement two methods: \texttt{grow()} and \texttt{trim()}. Why not combine both actions into a single function? Strategic thinking! Once we add apples to the game, the snake will grow after consuming them by \emph{not} shedding its tail. Thus, separating these two functions now will simplify our lives later on\footnote{To be honest, I have initially implemented it as a single \texttt{move()} function , wrote things up up to eating apples, realized the problem, returned and rewrote the notes. So, admittedly, it is a hindsight kind of strategic thinking.}.

The \texttt{grow()} method should take just a single tuple parameter \texttt{dxy} with a direction of snake's movement. I.e., it will be \texttt{(-1,\ 0)} for leftward moving snake, \texttt{(1,\ 0)} for right moving, \texttt{(0,\ -1)} for up, and \texttt{(0,\ 1)} for down. Inside the method, you compute the coordinates for the new head segment based on the position of the current head (the very first element of the snake) and the direction of motion (\texttt{dxy}), create a new snake segment at that location, and insert it before all other elements.

The \texttt{trim()} method is even simpler as its just pops the last segment (trims the tail).

To test these functions, create a snake and call its \texttt{grow()} method a few times using the same or different directions. Check visually that it works, i.e., that there are correct number of segment (initial head + as many segments as \texttt{grow()} method calls) and that the snake was growing in a correct direction. Combine \texttt{grow()} and \texttt{trim()} calls to visually check the snake as well.

Update \texttt{Snake} class adding \texttt{grow()} and \texttt{trim()} methods.

Test it in \emph{code07.py}.

\hypertarget{the-game-loop}{%
\section{The game loop}\label{the-game-loop}}

Add a main game loop using a \texttt{user\_abort} variable, so that it runs for as long as the \texttt{user\_abort} is \texttt{False}. Inside the loop, draw the snake and check for keys without pausing the game. If a player pressed \texttt{"escape"}, change \texttt{user\_abort} to \texttt{True} (the player decided to quit the game). If a player pressed \texttt{"space"} key, grow the snake in the direction of your liking and trim it. Thus, every time you press a \emph{space} key, the snake should move one square in the direction of your choice. Test the code!

Add main loop in \emph{code08.py}.

\hypertarget{self-motion}{%
\section{Self-motion}\label{self-motion}}

Our snake should move by itself. For this, we can call \texttt{grow()} and \texttt{trim()} methods on every iteration of the main game loop, not just when a player presses \emph{space}. However, by default, when you call \texttt{win.flip()} it will synchronize your loop with the refresh rate of the screen (typically, 60 Hz). This means that we would call these methods 60 times per second or, to put it differently, the snake will move 60 squares per second. This is waaaay too fast, given that our original grid size was just 30×20 squares. To appreciate just how fast this is, remove \texttt{if\ key\ was\ space:...} conditional statement, and call grow/trim snake methods on every iteration and see the snake fly off the screen.

Instead, we should decide on snake's speed, e.g., 4 squares per second\footnote{Note that speed does not need to be an integer number of squares per second. It can move at 1.5 squares per second, so 3 squares every two seconds.}, and define it as a new parameter in settings. In the \texttt{Snake} class constructor, use this parameter to compute a new attribute \texttt{step\_duration} that expresses the time needed to elapse before moving to a new square (i.e., interval between calls of grow/trim methods in seconds)\footnote{Do it in the constructor, always define all attributes in the constructor, even if they are set to \texttt{None}.}. Why two variables that express the same information (interval is just an inverse of speed)? We could define \texttt{step\_duration} directly in the settings but for a human it makes it harder to understand just how fast the movement will be. At least for me, a speed of \texttt{4\ squares\ per\ second} is easier to comprehend than \texttt{0.25\ second\ per\ square}. Thus, in cases like these, I prefer to have two variables, one human-oriented (in settings) and one computer-oriented (in the actual implementation, computed via a unit conversion). Remember, it is not just about writing a working code, it is about writing a code that is easy for a human to understand.

Also in the constructor, add a new \texttt{movement\_clock} attribute creating either a \href{https://www.psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock} or a \href{https://www.psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{countdown timer} object\footnote{Remember, they work the same they, it is just a question of whether you start from zero and check whether time is over \texttt{step\_duration} (\href{https://www.psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock}) or you start at \texttt{step\_duration} and check whether the time ran out/is already negative (\href{https://www.psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{timer}).} Then add a \texttt{reset\_clock()} method and a \texttt{can\_move} computed \protect\hyperlink{computed-attribute-property}{property}. The former should reset the clock or the countdown timer (whatever you have picked). The latter should return \texttt{True}, if the timer ran out and the snake can move to the next square (in this case you need to reset the timer!), or \texttt{False} if that is not the case. In the main script, call \texttt{reset\_clock()} method before the main loop and inside of the main loop call \texttt{grow()} and \texttt{trim()} methods \emph{only} if the snake \texttt{can\_move}.

Test your code by setting different snake speed.

Update \texttt{Snake} class adding timer attributes and methods.

Test it in \emph{code09.py}.

\hypertarget{describing-direction-using-words}{%
\section{Describing direction using words}\label{describing-direction-using-words}}

In our current design, we described direction as a tuple \texttt{(dx,\ dy)}. Let us change it, so that it is described using words \texttt{"up"}, \texttt{"down"}, \texttt{"left"}, and \texttt{"right"}. This is not strictly necessary but will make our lives somewhat easier later on when we add steering controls. More importantly, it will serve a didactic purpose as well, showing how you can use dictionaries to translate values from one representation to another.

Thus, in the main script, let us create a new string variable \texttt{direction} and set it to \texttt{"up"} (or any other direction you like). We will keep the \texttt{grow()} method as is and will translate individual strings to pairs of \texttt{(dx,\ dy)} values in the main script itself. E.g., \texttt{"up"} should correspond to \texttt{(0,\ -1)}, \texttt{"right"} to \texttt{(1,\ 0)}, etc.

We can implement this translation via if-elif conditional statements:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ direction }\OperatorTok{==} \StringTok{"up"}\NormalTok{:}
\NormalTok{  dxy }\OperatorTok{=}\NormalTok{ (}\DecValTok{0}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{)}
\ControlFlowTok{elif}\NormalTok{ direction }\OperatorTok{==} \StringTok{"right"}\NormalTok{:}
\NormalTok{  dxy }\OperatorTok{=}\NormalTok{ (}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{  ...}
\end{Highlighting}
\end{Shaded}

However, this approach introduces a lot of repetitive code and does not scale particularly well. Instead, we can use a \protect\hyperlink{dictionaries}{dictionary} (let us call it \texttt{DIRECTION\_TO\_DXY} as it is another constant) with \texttt{"up"}, \texttt{"right"}, etc. string as keys and tuples \texttt{(0,\ -1)}, \texttt{(1,\ 0)}, etc. as values. This way, we can use current value of the \texttt{direction} variable as a key to get the \texttt{(dx,\ dy)} pair from \texttt{DIRECTION\_TO\_DXY} dictionary. Do this translation directly in the \texttt{grow()} method call rather than creating a temporary variable as in the if-elif examples above. Test the translation by changing \texttt{direction} and checking that the snake moves accordingly.

Use \texttt{direction} and \texttt{DIRECTION\_TO\_DXY} in \emph{code10.py}.

\hypertarget{it-is-all-about-control}{%
\section{It is all about control}\label{it-is-all-about-control}}

Playing the game would be more fun, if we could steer the snake! If the player presses \emph{right arrow} key, the snake should turn \emph{clockwise}. Conversely, the \emph{left arrow} key, should turn the snake \emph{counterclockwise}. We need to figure out two things. First, how to determine a new direction of motion given the current one and the key that was pressed. Second, we must decide when and how to change the value of \texttt{direction} variable. Let us tackle these problems one at a time.

Determining the new direction of motion is fairly straightforward. If current is \texttt{"up"} and key was \emph{right} (\emph{clockwise} rotation), the new direction should be \texttt{"right"}. If current is \texttt{"down"} and key was \emph{left}, the new direction is again \texttt{"right"} (\emph{counterclockwise} rotation), etc. You could implement it as a bunch of \texttt{if-elif} statements or, better still, use the dictionary look up approach we implemented in the previous exercise. Here, you need a nested dictionary (dictionary inside a dictionary) \texttt{NEW\_DIRECTION{[}key{]}{[}direction{]}}. The first level has two keys \texttt{"left"} and \texttt{"right"} (so, effectively, counterclockwise and clockwise rotation) that selects which translation should be used and the second level is the dictionary that translates current direction into the new direction of motion. E.g., if current direction is \texttt{"down"} and key was \texttt{"right"}, \texttt{NEW\_DIRECTION{[}"right"{]}{[}"down"{]}} should be \texttt{"left"} (rotating clockwise from \texttt{"down"} gets us to \texttt{"left"}). You know how define a simple dictionary. Good news, defining nested dictionaries follows the same rules, so should be straightforward.

Now let us think about when and how should we change a value of \texttt{direction} variable. The simplest approach would be to change it as soon as the player presses the key. However, because our snake does not move on every frame this could lead to some odd behavior. Imagine that our game is on ``easy'' mode, so that the snake moves very slowly (one square per second). In this case, the player could easily press \emph{left} twice during that second, which would make a snake move \emph{backwards}, because its direction was changed by 180°. Snakes, at least our snake, cannot do this. Thus, we need a temporary variable, let us call it \texttt{new\_direction}, which we will set every time the player presses the key but whose value will be transferred to \texttt{direction} only when it is time to move the snake (when the snake can move). We will compute it from the current \texttt{direction} and the key pressed. This way, even when the player presses \emph{left} key several times, the snake would still turn only once because we compute the each turn using the same original \texttt{direction} value and not the changed \texttt{new\_direction} variable. This also means that players can ``change their mind'', as the last key press before the snake moves will determine the direction of motion.

Add \texttt{NEW\_DIRECTION} and implement steering in \emph{code11.py}.

\hypertarget{turning-the-harder-way}{%
\section{Turning the hard(er) way}\label{turning-the-harder-way}}

Let us implement the same ``figure out new direction'' code in a more complicated way. The purpose of the exercise is to challenge you, show you new methods of the list, and to demonstrate how you can think about a change of the direction as moving through the list. Implement it as a function called \texttt{compute\_new\_direction()}, which will take two parameters (current direction and pressed key) and will return the new direction of rotation. You can put it above the main script or, better still, put it into a separate \emph{utilities.py} file. However, in cases like these, I find it useful to play with the code in a Jupyter notebook before turning it into a function, so you could try this approach instead of debugging.

Here is the idea. Imagine that you have a list \texttt{{[}"left",\ "up",\ "right",\ "down"{]}}. For this list, rotation clockwise would correspond to moving through the list to the right (assuming that you jump to the beginning once you move past the last item). Conversely, rotation counterclockwise corresponds to moving to the left (again, assuming that you jump to the end of the list, once you went past the first item). As you see, rotation is expressed as a very intuitive ``motion through the list''.

For the actual implementation, first, define a local variable as a list in the order I've described. Next, you need to identify the location of the current direction within the list using \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{index()} method. Then, you need to figure out whether you increase or decrease that index (to move to the right or to the left), based on \texttt{pressed\_key} parameter (you can use dictionary approach or a conditional assignment here). Finally, you need to control for range, so that index of \texttt{-1} becomes \texttt{3} (you went too far to the left) and index of \texttt{4} should become \texttt{0}. The most elegant way to do this, is using \texttt{\%} \href{https://python-reference.readthedocs.io/en/latest/docs/operators/modulus.html}{modulus} operation. Hint, \texttt{4\ \%\ 4} is \texttt{0}. What about \texttt{1\ \%\ 4}, \texttt{0\ \%\ 4}, or even \texttt{-1\ \%\ 4}? Check it in a Jupyter notebook to get an idea of what I am hinting at. And, of course, do not use \texttt{4} for division, use the \href{https://docs.python.org/3/library/functions.html\#len}{length} of the list, as it determines the range of values.

Create `compute\_new\_direction() in \emph{utilities.py}.

Use it instead of a dictionary look-up in \emph{code12.py}.

\hypertarget{hitting-the-wall-1}{%
\section{Hitting the wall}\label{hitting-the-wall-1}}

We can control the snake but, at the moment, you can steer it off the screen or make it go through itself. Let us fix the former!

Add a new computed \protect\hyperlink{computed-attribute-property}{property} \texttt{hit\_the\_wall} to the \texttt{Snake} class. The method should check whether the head of the snake (which segment is it?) is still within the grid that we defined (how do you check for that?). It should return \texttt{True}, if the head of the snake is outside of the grid limits (so, it is true that the snake hit the wall) or \texttt{False}, if it is still inside.

Test it by adding a new condition inside the main game loop. Check whether the snake \texttt{hit\_the\_wall} and, if that is the case, the game should be over. Think about the optimal place where to check for this. You could do it on every iteration but there is a more logical place for it in main loop. Where is it?

Test that the game quits after you successfully steered the snake into the wall.

Add \texttt{hit\_the\_wall} property to the \texttt{Snake} class.

Use it in \emph{code13.py}.

\hypertarget{is-this-the-snake}{%
\section{Is this the snake?}\label{is-this-the-snake}}

In the next section, we will be adding apples to the game. The catch is that these apples should appear at a location that is \emph{not} occupied by the snake. Otherwise, we would generate apples directly into snake's stomach. Practical for the snake but defeats the purpose of the game. To rephrase this problem, we need a method that checks whether a particular grid location is occupied by the snake.

Add a new method \texttt{is\_inside()} that takes a tuple with a grid location as a parameter and returns a logical value whether that grid location is occupied by the snake (i.e., by one of its segments). Document the function! Test the method via debugging. Calling it immediately after creating the snake with a location of the head (the only segment) or with a different location. Store a return value into a temporary variable and put a breakpoint at an appropriate place to check its value (or use a debug console).

Add \texttt{is\_inside()} method to the \texttt{Snake} class.

Test it in \emph{code14.py}.

\hypertarget{an-inedible-apple}{%
\section{An inedible apple}\label{an-inedible-apple}}

Let us add that highly desirable fruit: the apple! We will use \href{material/apple.png}{an apple bitmap}\footnote{Created by \href{https://openclipart.org/artist/cyanidecupcake}{Jess Wiechler}.}, so we will create a new class as a descendant of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} class. Its constructor should take \texttt{GridWindow} and \texttt{Snake} as parameters. In the constructor, you need to find a \href{https://docs.python.org/3/library/random.html\#random.randrange}{random} grid location that is not occupied by snake, store it in an \texttt{ipos} attribute and call the parent's constructor to initialize the image with an appropriate size and location (again, check \protect\hyperlink{flappy-bird-class}{Flappy Bird class} or \texttt{GridWindow} class, if you forgot how to do this).

The only tricky part is finding the unoccupied location. There are many different strategies for doing this. The simplest one is to generate a potential location \href{https://docs.python.org/3/library/random.html\#random.randrange}{at random}, check whether it is occupied by a snake (\texttt{is\_inside()}?) and keep doing it until you find an unoccupied one.

In the main script, create an apple and draw it in the main loop. For a moment, the snake cannot eat it and will pass through it but we will fix this shortly.

Create \texttt{Apple} class in \emph{apples.py}.

Use the apple in \emph{code15.py}.

\hypertarget{eating-an-apple}{%
\section{Eating an apple}\label{eating-an-apple}}

Apples exist for snakes to eat them! Let us add this functionality. The general idea is very simple. If the \emph{head} of the snake moves on to the grid location with an apple, you should not trim its tail. See how useful it was to split growing and trimming into two separate functions? Told you, strategic thinking!

You need to add a conditional statement that if the snake's head \emph{is} on the apple, you should not trim the tail but create a new apple. What should you do, if there is no apple at that location?

Make snake eat apples in \emph{code16.py}.

\hypertarget{eating-yourself}{%
\section{Eating yourself}\label{eating-yourself}}

Once our snake grows beyond four segments, it has an opportunity to bite itself\footnote{Why at least five? Draw it on the grid and figure out whether it can eat itself with just four segments.}. For this, we need to check that, \emph{after} the snake moved, its head is \emph{not} at the same location as one of the segments of its body. Create a new property \texttt{bit\_itself} that returns \texttt{True} or \texttt{False} based on whether that is the case. The property is very similar but not identical to \texttt{is\_inside()} method you implemented earlier. What is the critical difference and why cannot you simply reuse that function?

Once you implemented \texttt{bit\_itself}, you should check for that it does lead to the end of the game.

Implement \texttt{bit\_itself} property.

Use it in \emph{code17.py}.

\hypertarget{bells-and-whistles-score}{%
\section{Bells and whistles: score}\label{bells-and-whistles-score}}

Now that we have a fully functional game, we can start adding non-essential but nice-to-have features to it. The first one will be the score. Create a new class \texttt{Score} that inherits from \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} and has an extra attribute \texttt{score} (initialized to \(0\) in the constructor) and a method \texttt{plus\_one()} that should increase the score by one and update the \texttt{text} attribute. As with an apple, initialize the \href{https://psychopy.org/api/visual/textstim.html\#psychopy.visual.TextStim}{TextStim} part by calling parent's \texttt{\_\_init\_\_()} method using appropriate parameters. I decided to put it at the top of the window and it reads \textbf{Score: XXX} but you are free to do it as you feel fit.

In the main script, create a \texttt{Score} object, draw it when appropriate and increase the score every time the snake eats an apple.

Create \texttt{Score} class in \emph{scoring.py}.

Use it in \emph{code18.py}.

\hypertarget{bells-and-whistles-three-lives}{%
\section{Bells and whistles: three lives}\label{bells-and-whistles-three-lives}}

Let us give the player three attempts to achieve the top score. They have three lives, every time the snake dies, the game \emph{but not the score} resets: A single segment snake appears at the center and a new random apple appears elsewhere (where should you put the code to create them?). Once the snake dies three times, the game is over. Think how you can implement this three repetitions.

The score should be cumulative, so at the beginning of round two it should be equal to the final score of round one. Think how you can achieve this. \emph{Another important point}: now you have two nested loop, one is for the game, one is for the round. When the snake dies, the round is over and, if you run out of lives, the game as well. When the player presses \emph{escape} both round \textbf{and} the game are over. Think about how you can implement it.

Put your updated code into \emph{code19.py}.

\hypertarget{bells-and-whistles-press-space-to-start-the-round}{%
\section{Bells and whistles: press space to start the round}\label{bells-and-whistles-press-space-to-start-the-round}}

At the moment, our round starts immediately. It would be friendlier, if the player would start it themselves. Before each round, draw \emph{all} visuals (snake, apple, score) plus a text ``Press SPACE to start'' and wait until either a \emph{space} or \emph{escape} key is pressed. In the former case, the trial should start. In the latter case, the player should exit the game.

Put your updated code into \emph{code20.py}.

\hypertarget{bells-and-whistles-showing-remaining-lives}{%
\section{Bells and whistles: showing remaining lives}\label{bells-and-whistles-showing-remaining-lives}}

Let us not just repeat the game three times but show the player how many lives they still have. Download the \href{material/heart.png}{heart.png}\footnote{This image was downloaded from \href{https://openclipart.org/}{openclipart.org} and was created by \href{https://openclipart.org/artist/cliparteles}{cliparteles}} and use it show remaining lives at the top-left corner of the screen: three hearts in round one, two hearts in round two, and just a single heart in round three. You will need to use (ImageStim){[}\url{https://www.psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{]} for this. Think about the size of images and their location. Hint: I created a list of heart images using list comprehension and drawing hearts definitely requires a for loop.

Put your updated code into \emph{code21.py}.

\hypertarget{bells-and-whistles-difficulty}{%
\section{Bells and whistles: difficulty}\label{bells-and-whistles-difficulty}}

At the moment, the difficulty of the game, the speed with which the snake moves, is fixed and the player has no way of choosing it. Let us create dialog that appears \emph{before} we create the window and start the game that will allow the player to choose between \emph{easy}, \emph{normal}, and \emph{difficult}\footnote{Or, if you played Doom, between \emph{I'm Too Young To Die}, \emph{Hey, Not Too Rough}, \emph{Hurt Me Plenty}, \emph{Ultra-Violence}, and \emph{Nightmare}.}. I leave it up to you to decide which snake speeds correspond to each difficulty. You can have more than three options, if you want. However, they definitely should be define in settings file.

To create and run the dialog, use \href{https://www.psychopy.org/api/gui.html\#dlg}{Dlg} class from
\href{https://www.psychopy.org/api/gui.html}{giu} module of PsychoPy. Your challenge for today is to figure out how to use it based on the manual alone. Take a look at the example and experiment with in a separate file or a Jupyter notebook.

Put your updated code into \emph{code22.py}.

\hypertarget{bells-and-whistles-blinking-game-over-message}{%
\section{Bells and whistles: blinking ``game over'' message}\label{bells-and-whistles-blinking-game-over-message}}

Once the game is over (but not when a player pressed \emph{escape} key), show a blinking ``Game Over'' message \emph{superimposed} over the final static game screen. Thus, you need to draw all the game objects and messages (but without moving the snake) plus you show a text message that is on for 0.5 second and off for 0.5 seconds until the player presses \emph{Space} button. Hint: it should be a separate loop after the main game loop over rounds, logical variables and clocks/timers have definitely something to do with it.

Put your updated code into \emph{code23.py}.

\hypertarget{bells-and-whistles-sounds}{%
\section{Bells and whistles: sounds}\label{bells-and-whistles-sounds}}

Download \href{material/game-over-arcade.wav}{game-over-arcade.wav}\footnote{Downloaded from \href{https://freesound.org/}{freesound.org} and created by \href{https://freesound.org/people/myfox14/}{myfox14}} and \href{material/8-bit-game-over-sound.wav}{8-bit-game-over-sound.wav}\footnote{Also downloaded from \href{https://freesound.org/}{freesound.org} and created by \href{https://freesound.org/people/EVRetro/}{EVRetro}}. Use the former whenever the snake dies and use the latter when the player runs out of lives. Note, no sound should be played if the player pressed \emph{escape}.

You will need to use \texttt{Sound} class from \href{https://psychopy.org/api/sound/playback.html}{sound} module of PsychoPy. Important: use \texttt{Sound} class not a library-specific implementation such as \texttt{PTBSound} or \texttt{SoundDevice} classes. The PsychoPy will figure out which backend is the best (available at all) for you.

Put your updated code into \emph{code24.py}.

\hypertarget{the-sky-is-the-limit}{%
\section{The sky is the limit}\label{the-sky-is-the-limit}}

Good job! Lots of coding but now you have a cool retro game!

\hypertarget{moon-lander}{%
\chapter{Moon lander}\label{moon-lander}}

Today we will create a moon lander game. You job is simple: land your ship on the pad but do not crash it! Here is a brief video of my implementation of the game

Here is the general outline of how we will proceed:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a basic PsychoPy window and main experimental loop.
\item
  Outsource the boilerplate to a context manager
\item
  Define a basic \texttt{MoonLander} class with a static image and add its drawing to the main loop.
\item
  Randomize position of the lander.
\item
  Add gravity pull.
\item
  Add vertical thruster that counter-act gravity.
\item
  Add horizontal thrusters, so you can maneuver around.
\item
  Define \texttt{LandingPad} class.
\item
  Implement landing / crashing checks.
\item
  Add more runs.
\item
  Limit the fuel.
\end{enumerate}

But first you will learn about context management and exceptions.

\hypertarget{boilerplate-1}{%
\section{Boilerplate}\label{boilerplate-1}}

As per usual, we will start with our usual boilerplate code. Create settings file that, for now, defines only the size of the window. Create \texttt{code01.py} with the usual boilerplate for loading settings, opening the window (its size determined by the settings), a main game loop (you can add a text message to make it look less plain) with a check for an \emph{``escape''} button to exit the loop, and closing the window at the end. I am being so specific because next you will learn how to hide this boilerplate in a context manager.

Put your code into \emph{code01.py}.

\hypertarget{context-manager}{%
\section{Context manager}\label{context-manager}}

On the one hand, context management is a frequently used feature in Python, particularly for file operations (you used it when loading settings from a JSON or YAML file). On the other hand, its full power that relies on a custom class implementation is rarely used. However, it can be very useful whenever the context of your programs is the same or very similar, as in case of the PsychoPy games that we programmed or typical PsychoPy experiments. In both cases, there is a fairly fixed structure of the program:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Initialization

  \begin{itemize}
  \tightlist
  \item
    get experimental settings by reading them from an \protect\hyperlink{settings-files}{external file}
  \item
    create PsychoPy window, logger for experimental results, mouse (if required)
  \item
    initialize special devices such as response box, eye tracker, etc.
  \end{itemize}
\item
  Actual experiment
\item
  Saving and cleaning up

  \begin{itemize}
  \tightlist
  \item
    save data logs
  \item
    if required, close connection to special devices such as response boxes, eye tracker, etc.
  \item
    close PsychoPy window
  \end{itemize}
\end{enumerate}

If you look at your code, you will realized that steps 1 and 3 remain pretty much the same throughout all the games that we programmed. Thus, we will create a context manager class that you can always reuse and which will hide away the boilerplate code.

Here is a reminded of how a context manager is used when working with files. First, how it works \emph{without} a context manager: 1) you open a file and assign the object to a variable, 2) you work with it, 3) you close it. The latter is important to ensure that information was fully written into it and that you do not lock for file.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{file} \OperatorTok{=} \BuiltInTok{open}\NormalTok{(}\StringTok{"somefile.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{)}
\CommentTok{\# ... do something with the file, such as reading the entire file into a single variable}
\NormalTok{data }\OperatorTok{=} \BuiltInTok{file}\NormalTok{.read()}
\NormalTok{close(}\BuiltInTok{file}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A better way is to use a context manager via a \texttt{with\ ...\ as\ ...} statement (again, this should look familiar by now):

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{"somefile.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \BuiltInTok{file}\NormalTok{.read()}
\end{Highlighting}
\end{Shaded}

Note that now the \texttt{file.read()} is inside of the \texttt{with} block and there is no \texttt{file.close()} call. The latter is evoked automatically, once you run all the code inside the \texttt{with} block and exit it. Although for this example the difference is minimal --- a different way to assign a value to a variable and explicit versus implicit file closing --- the second variant takes care of cleaning up, ensures that you do not forget about it, and allows you to concentrate on the important bits.

Here's how it works behind the scenes. A context manager is a class that implements two special methods \texttt{\_\_enter\_\_} and \texttt{\_\_exit\_\_}{[}Spoiler alert! This approach is called \href{duck-typing}{duck typing} and we will learn more about in the next game{]}. The former creates and returns a context, which is whatever attribute or value you require, wheres the latter performs cleaning up that is necessary before exiting the context. Here is how we would implement a limited file context manager by ourselves:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ FileManager():}
    \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, filename, mode):}
        \CommentTok{"""}
\CommentTok{        Stores the settings for use in \_\_enter\_\_}
\CommentTok{        }
\CommentTok{        Parameters}
\CommentTok{        {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{        filename : str}
\CommentTok{        mode : str}
\CommentTok{        """}
        \VariableTok{self}\NormalTok{.}\BuiltInTok{file} \OperatorTok{=} \VariableTok{None}
        \VariableTok{self}\NormalTok{.filename }\OperatorTok{=}\NormalTok{ filename}
        \VariableTok{self}\NormalTok{.mode }\OperatorTok{=}\NormalTok{ mode}
        
    \KeywordTok{def} \FunctionTok{\_\_enter\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
      \CommentTok{""" }
\CommentTok{      What we need to do to create context:}
\CommentTok{        * Open the file and returns the object.}
\CommentTok{      }
\CommentTok{      Returns}
\CommentTok{      {-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
\CommentTok{      File object}
\CommentTok{      """}
      \VariableTok{self}\NormalTok{.}\BuiltInTok{file} \OperatorTok{=} \BuiltInTok{open}\NormalTok{(}\VariableTok{self}\NormalTok{.filename, }\VariableTok{self}\NormalTok{.mode)}
      \ControlFlowTok{return} \VariableTok{self}\NormalTok{.}\BuiltInTok{file}
      
    \KeywordTok{def} \FunctionTok{\_\_exit\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, exc\_type, exc\_value, traceback):}
      \CommentTok{"""}
\CommentTok{      What we need to do before destroying the context:}
\CommentTok{        * Close the file before we exit the context.}
\CommentTok{      """}
\NormalTok{      close(}\VariableTok{self}\NormalTok{.}\BuiltInTok{file}\NormalTok{)}
      
\CommentTok{\# and now we use it!}
\ControlFlowTok{with}\NormalTok{ FileManager(}\StringTok{"somefile.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \BuiltInTok{file}\NormalTok{.read()}
\end{Highlighting}
\end{Shaded}

Note that \texttt{\_\_exit\_\_} method has extra parameters \texttt{exc\_type}, \texttt{exc\_value}, and \texttt{traceback}. They will be relevant for exception handling later on but you can ignore them for now.

Now is your turn! Create a \texttt{GameContext} class (in a separate file, of course) that will load settings (filename should be passed to the constructor), create a PsychoPy Window object of a given size upon entering the context, and \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window.close}{close} when the code exists the context. For now, you will need one attribute to store settings (call it \texttt{settings}) and one attribute for PsychoPy Window itself (use \texttt{win} as an attribute name). There will be a small but important difference relative to \texttt{FileManager} class in the example above. Here, we have two objects (attributes) that we would like to use inside the context: \texttt{settings} and \texttt{win}. We could return both as a tuple but this approach does not scale well. Instead, the \textbf{enter} should return the reference to the context object itself (reminder, reference to the current object is always in the \texttt{self} parameter of a method). This way you can always access either attribute via \texttt{context.settings} or \texttt{context.win}.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with}\NormalTok{ GameContext(}\StringTok{"settings.yaml"}\NormalTok{) }\ImportTok{as}\NormalTok{ context:}
  \CommentTok{\# your usual code inside but}
  \CommentTok{\# PsychoPy window is context.win}
\NormalTok{  context.win.flip()}
\end{Highlighting}
\end{Shaded}

Create \texttt{GameContext} class and use it in \emph{code02.py}.

As you can see, the repetitive part is now hidden in the context class making it easier to concentrate on the main code. But the context manager has another ace up its sleeve: it makes handling exceptions (a.k.a. errors) and safe exiting much simpler.

\hypertarget{exceptions}{%
\section{Exceptions}\label{exceptions}}

When you are running an actual experiment, one of the worries that you have is ``what happens to the data I have already logged if the program crashes with an error''? Not collecting a full measurement is bad but not keeping at least partial log is even worse, as you can still use it for analysis or as a guidance for future adjustments. Python, as other languages, has special mechanisms to handle \href{https://docs.python.org/3/tutorial/errors.html}{exceptions} that arise during the code execution.

Whenever an error occurs at a run time, it \href{https://docs.python.org/3/reference/simple_stmts.html\#the-raise-statement}{raises} an exception: it creates an object of \href{https://docs.python.org/3/library/exceptions.html\#concrete-exceptions}{a special class} that contains information describing the problem. For example, a \href{https://docs.python.org/3/library/exceptions.html\#ZeroDivisionError}{ZeroDivisionError} is raised whenever you try to divide by zero, e.g., \texttt{1\ /\ 0} (you can try this in a Jupyter notebook). A \href{https://docs.python.org/3/library/exceptions.html\#KeyError}{KeyError} is raised, if you using a dictionary with a wrong key, the code below will raise it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a\_dict }\OperatorTok{=}\NormalTok{ \{}\StringTok{"a\_key"}\NormalTok{ : }\DecValTok{1}\NormalTok{\}}
\NormalTok{a\_dict[}\StringTok{"b\_key"}\NormalTok{]}
\CommentTok{\#\textgreater{} Error in eval(expr, p): KeyError: \textquotesingle{}b\_key\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Similarly, an \href{https://docs.python.org/3/library/exceptions.html\#IndexError}{IndexError} is raised, if you try to use an invalid index for a list, a \href{https://docs.python.org/3/library/exceptions.html\#NameError}{NameError}, if you are trying to access variable that does not exist, \href{https://docs.python.org/3/library/exceptions.html\#AttributeError}{AttributeError} when an object does not have an attribute you are trying to use, etc.

In Python, you use \texttt{try:\ ...\ except:...finally:} operators to anticipate and handle exceptions:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
    \CommentTok{\# some code that might generate a runtime error}
\ControlFlowTok{except}\NormalTok{:  }
    \CommentTok{\# code that is executed if something bad happens}
\ControlFlowTok{finally}\NormalTok{:}
    \CommentTok{\# code that is executed both with and without exception}
    
\CommentTok{\# code that is executed ONLY if there were no exceptions or if an exception was handled}
\end{Highlighting}
\end{Shaded}

In the simplest case, you need just the first two operators: \texttt{try} and \texttt{except}. Create a Jupyter notebook (that you will submit as part of the assignment) and write the code that generates a division-by-zero error but is handled via \texttt{try...except...}. In the \texttt{except} simply print out a message, so that you know that it was executed. Create another cell, copy the code and now check that the exception handling code is \emph{not} executed, if the error is not generated (i.e., divide by some non-zero number).

Put exception handling code is cell of a Jupyter notebook.

Using \texttt{except:} catches \emph{all} exceptions. However, this is considered a bad style (too general) and a linter will complain. Instead, you can be more specific and handle exceptions based on their class.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
    \CommentTok{\# some code that might generate a runtime error}
\ControlFlowTok{except} \PreprocessorTok{KeyError} \ImportTok{as}\NormalTok{ key\_error:}
    \CommentTok{\# code that is executed only if KeyError exception was raised }
    \CommentTok{\# with exception information stored in the key\_error object}
\ControlFlowTok{except} \PreprocessorTok{ZeroDivisionError} \ImportTok{as}\NormalTok{ zero\_division\_error:  }
    \CommentTok{\# code that is executed only if ZeroDivisionError exception was raised}
    \CommentTok{\# with exception information stored in the zero\_division\_error object}
\ControlFlowTok{except}\NormalTok{:}
    \CommentTok{\# code that is executed if any OTHER exception is raised.}
\end{Highlighting}
\end{Shaded}

Implement handling for \texttt{KeyError} and \texttt{ZeroDivisionError}, they should print out different messages to check that it works. Test it by generating these runtime errors with your code.

Put specific exception handling code is cell of a Jupyter notebook.

So far, you generated exception by causing runtime errors code but you can raise these exceptions yourself via \href{https://docs.python.org/3/reference/simple_stmts.html\#the-raise-statement}{raise} operator. For example, instead of dividing by zero, you can \texttt{raise\ ZeroDivisionError()}\footnote{Confusingly, if you do not pass any additional parameters, you can also create the object \emph{without} round brackets: \texttt{raise\ ZeroDivisionError}. I find this mightily confusing but this is fairly common, so drop brackets if it feels more natural.}. Use it with you previous code, instead of an actual division by zero. Try raising other exceptions and see how your code handles them. Also check what happens if you have the first two specific exception handlers but no general \texttt{except:} and raise an \href{https://docs.python.org/3/library/exceptions.html\#NameError}{NameError}?

Use \texttt{raise} to test exception handling in a Jupyter notebook.

So far I have talked about exceptions as a way to alert about runtime errors. However, they can be used in a more general way to control the execution flow. We will use that side of exception in the next section when dealing with context.

\hypertarget{exception-within-context}{%
\section{Exception within context}\label{exception-within-context}}

\texttt{try..except...} operators provide a general mechanism for exceptions handling but what happens if an exception is raised inside a context? You can, of course, put a \texttt{try...except...} in the code itself, something you should do, if you are planning to handling \emph{specific} exceptions. However, if an exception occurs in the code inside the context, Python will first \emph{exit} the context, i.e., call the \texttt{\_\_exit\_\_} method, before handling it explicitly. Moreover, it will kindly put the exception information into the parameters \texttt{exc\_type} (a class of the exception) and \texttt{exc\_value} (an object of that class). This way, you can perform a proper clean-up (save data, close window, etc.) and then either handle an exception or leave it alone, so that it propagates further and can be handled by other pieces of your code (or it will stop the execution, if you do not handle it explicitly).

Here, we will use this mechanism not only for safe clean-up but also to make aborting an experiment (or a game) easy. In previous games with many rounds, you had nested loops that made aborting a game via \emph{escape} key press awkward. You had to check it in the inner loop and then differentiate between a normal end-of-round and a used abort in the outside loop. We can make our life much easier via a combination of a context manager and a custom exception.

First, create a custom \texttt{GameAbort} class, which is a descendant of the \texttt{Exception} class. You do not need any code in it, even a constructor does not need to be redefined, so use \href{https://docs.python.org/3/reference/simple_stmts.html\#the-pass-statement}{pass} statement for its body (you do need to have at least one line of code in the class). Next, you \texttt{raise\ GameAbort()}, if the player pressed \emph{escape} key (do not forget to import \texttt{GameAbort} class, so you can use it in the main script). Finally, in the \textbf{exit} method of the \texttt{GameContext} manager, you should check whether \texttt{exc\_type\ is\ GameAbort} (\texttt{exc\_type} will be \texttt{None}, if no exception occurred) and, \textbf{very important(!)}, \texttt{return\ True} in that case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ GameContext:}
\NormalTok{    ...}
    \KeywordTok{def} \FunctionTok{\_\_exit\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{, exc\_type, exc\_value, traceback):}
\NormalTok{        ...}
        \ControlFlowTok{if}\NormalTok{ exc\_type }\KeywordTok{is}\NormalTok{ GameAbort:}
            \ControlFlowTok{return} \VariableTok{True}
  
\end{Highlighting}
\end{Shaded}

That last bit \texttt{return\ True} informs Python that you handled the exception and all is good (not need to propagate it further). However, note that your \emph{return} \texttt{True} meaning that any other code that handles the exit from a context must be \emph{before} that statement. Now, you can safely abort your experiment from any code location, inside nested loops, functions, etc. In all cases, the exception will be propagated until the \texttt{\_\_exit\_\_} method, doing away with awkward extra checks.

Create \texttt{GameAbort} exception class,update \texttt{GameContext} class to handle it,use this in an updated main script in \emph{code03.py}.

\hypertarget{create-moonlander-class}{%
\section{Create MoonLander class}\label{create-moonlander-class}}

In \emph{moonlander.py}, create a new \texttt{MoonLander} class. It should have an \href{https://psychopy.org/api/visual/imagestim.html}{ImageStim} attribute (I will assume it is called \texttt{image}) that will contain the visuals of the ship created using \href{material/ufo.png}{ufo.png} image. However, instead of hardcoding the filename, create a new group \texttt{"Lander"} in the settings file and add a new setting \texttt{"ship\ image\ :\ ufo.png"} (assuming you use YAML). Pass Lander-specific settings to the constructor and save them in an attribute (we will have more of them later).

Note that we do not want to inherit from the \href{https://psychopy.org/api/visual/imagestim.html}{ImageStim} directly, as we will have more visuals elements later on. Also, implement \texttt{draw()} method that should draw all visual elements of the lander (we have one for now, of course).

Create an instance of \texttt{MoonLander} class in the main script and draw it in the main game loop. You should see a static picture of the ship at the center of the screen.

Create \texttt{MoonLander} class and use it in the main game loop.
Put updated code into \emph{code04.py}.

\hypertarget{randomize-landers-position}{%
\section{Randomize lander's position}\label{randomize-landers-position}}

Implement a new method \texttt{reset()} that resets the lander for the next round. At the moment, the only thing it should do is to randomize position of the image. Use a range of -0.5..0.5 horizontally and 0.8..0.9 vertically (I assume that we are using \texttt{"norm"} units). Call it in the constructor and test it in the main loop by calling it every time you press \emph{space} button (that should make the ship jump).

Add \texttt{reset()} method to \texttt{MoonLander} class and use it in the main game loop.
Put updated code into \emph{code05.py}.

\hypertarget{flying-but-only-down}{%
\section{Flying (but only down)}\label{flying-but-only-down}}

For the lander to fly, we must adjust its position or, more specifically, the position of its image (\texttt{self.image.pos}) based on its speed. But before that, speed itself must be adjusted based on the forces from gravity and thrusters that act upon the lander. Accordingly, we need

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A new setting that defines acceleration due to the gravitational force. Define in the settings file, call it \texttt{gravity\ {[}norm/sec\^{}2{]}} (so, it is an acceleration in distance units of \texttt{"norm"} rather than in meters of the real world) and set to \texttt{0.0001}\footnote{The constant itself does not mean anything, I adjusted it to be reasonable for the image and window size that we are using.}
\item
  A new attribute \texttt{speed} that will contain horizontal and vertical velocity in norm units per second. Initialize to \texttt{{[}0,\ 0{]}} in the \texttt{reset()} but also assign some value (e.g., also \texttt{{[}0,\ 0{]}}) as linters do not like to see attributes that were never mentioned in the constructor.
\item
  A new attribute with a PsychoPy \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock} that will measure the time elapsed since the last position adjustment (this way we can compute our speed and acceleration ``per second''). Do not forget to reset it in \texttt{reset()}.
\end{enumerate}

Now, implement a method that will update lander position (call it, unimaginatively, \texttt{update()}). Inside, figure out the time elapsed since the last call (or since the last \texttt{reset()}) and do not forget to restart the clock. Once you know how much time has elapsed, you can adjust, first, speed based on acceleration (only vertical speed based on gravity for now, we will worry about the horizontal component once we implement thrusters) and, then, position based on speed. Call it in the main loop and watch your lander fall out of the sky. Once it is off the screen, press space and see it go again. Play with the \texttt{gravity} setting to adjust the speed of falling to your liking.

Update \texttt{MoonLander} class for the effect of gravity.
Use it in the main loop of \emph{code06.py}.

\hypertarget{vertical-thurster}{%
\section{Vertical thurster}\label{vertical-thurster}}

PsychoPy allows you to get key presses or, using \href{https://www.psychopy.org/api/hardware/keyboard.html}{hardware.keyboard} to get both press and release time. Unfortunately, you get both only \emph{after} the key was released. In our game, the thursters must be active for as long as the player presses the key. Thus, we need to know whether a key is \emph{currently} pressed, not that it was pressed and released at some time in the past. For this, we will use \emph{pyglet} library (a backend used by PsychoPy) directly. First, in your \emph{moonlander.py} add \texttt{import\ pyglet} and then include the following code inside the constructor of the class.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# setting up keyboard monitoring}
\VariableTok{self}\NormalTok{.key }\OperatorTok{=}\NormalTok{ pyglet.window.key}
\VariableTok{self}\NormalTok{.keyboard }\OperatorTok{=} \VariableTok{self}\NormalTok{.key.KeyStateHandler()}
\NormalTok{win.winHandle.push\_handlers(}\VariableTok{self}\NormalTok{.keyboard)}
\end{Highlighting}
\end{Shaded}

This installs a ``handler'' that monitors the state of the keyboard. Now, you can read out the state of, say, \emph{down arrow} key as\texttt{self.keyboard{[}self.key.DOWN{]}} (\texttt{True} if pressed, \texttt{False} otherwise). We will use \texttt{DOWN} for the vertical thruster and \texttt{LEFT} and \texttt{RIGHT} for the horizontal ones.

Define a \texttt{vertical\ accelartion\ {[}norm/sec\^{}2{]}} to be twice the gravity (but you can use some other number, of course) and update the \texttt{update()}\footnote{Pun intended.}, so that the total vertical acceleration is \(vertical acceleration + gravity\) if the the user is pressing \emph{down} key (use \texttt{self.keyboard} and \texttt{self.key} to figure that out) but \(gravity\) alone, if not.

Test that the vertical thruster works (do you need to update the main code?)!

Update \texttt{MoonLander} class with a vertical thruster.

\hypertarget{horizontal-thursters}{%
\section{Horizontal thursters}\label{horizontal-thursters}}

Now implement the same logic, computing acceleration, speed, and position but for horizontal thrusters (define \texttt{horizontal\ acceleration\ {[}norm/sec\^{}2{]}} setting and decide on its value yourself). Remember, the \emph{right} thruster pushes the lander to the \emph{left} and vice versa! Think about what you should do if both \emph{left} and \emph{right} keys are pressed at the same time. Test it by flying around!

Add horizontal thrusters to \texttt{MoonLander}.

\hypertarget{landing-pad-visuals}{%
\section{Landing pad: visuals}\label{landing-pad-visuals}}

The purpose of the game is to land on a landing pad. A landing pad is just a rectangle with some additional methods and properties. So it stands to reason to make it a descendant of the \texttt{visual.Rect} class, unfortunately, for some technical reason I have not figured out yet, this does not work for shape classes like \texttt{Rect} or \texttt{Circle}.

Create a new file \emph{landing\_pad.py} and a new class \texttt{LandingPad}. In the constructor, create a rectangle and store it in attribute (you pick the name). It should be \texttt{0.5} units wide and located at the bottom of the window but at a \href{https://docs.python.org/3/library/random.html}{random} position within the window horizontally. Pick the fill and line colors that you like. The only other method the class needs is \texttt{draw()}.

In the main code, create an object of class \texttt{LandingPad} and draw it in the main loop, along with the lander itself.

Create \texttt{LandingPad} class.
Use it in \emph{code07.py}.

\hypertarget{computing-edges-of-game-objects}{%
\section{Computing edges of game objects}\label{computing-edges-of-game-objects}}

The aim of the game is a soft touchdown on a landing pad. For this, we need to know where the \emph{top} of the landing pad is, as well as where the \emph{bottom} of the lander is and where \emph{left} and \emph{right} limits of each object are. Let us think about \emph{bottom} of the lander first, as the rest are very similar.

We do not have information about it \emph{directly}. We have the vertical position of the lander in \texttt{self.image.pos{[}1{]}} (I assume here that the visuals attribute is called \texttt{image}) and its height in \texttt{self.image.size{[}1{]}}. From this, it is easy to compute the bottom edge (but remember that position is about the \emph{center} of the rectangle). Accordingly, you could create a \protect\hyperlink{computed-attribute-property}{computed property} \texttt{bottom}. Create computed attributes for \texttt{bottom}, \texttt{left}, and \texttt{right} of the lander class and for \texttt{top}, \texttt{left}, and \texttt{right} of the landing pad.

Implement computed properties for \texttt{MoonLander} and \texttt{LandingPad} classes.

\hypertarget{landing}{%
\section{Landing}\label{landing}}

We should check for landing whenever the bottom edge of the lander is at or below the top edge of the landing pad. A successful landing must satisfy several conditions:

\begin{itemize}
\tightlist
\item
  The lander must be within the limits of the lander pad horizontally.
\item
  The vertical speed must be zero or negative (otherwise, the lander flies up) but below a certain threshold that we will define as \texttt{vertical\ speed\ threshold\ {[}norm/sec{]}}. I set it to \texttt{0.05}.
\item
  The absolute horizontal speed must be below a certain threshold, also defined as \texttt{horizontal\ speed\ threshold\ {[}norm/sec{]}\ :\ 0.05}.
\end{itemize}

If \emph{any} of these three conditions are false, the lander has crashed. Either way, the game is over, so you should record the outcome (whether the landing was successful) and exit the main game loop. After the loop, inform the player about the outcome. Draw all game objects plus the message about the outcome (e.g., ``You did it!'' / ``Oh, no!'' or something else) and wait for a space key press.

The condition above will be quite long, so fitting it into a single line will make it hard to read. In Python, you can split the line by putting \texttt{\textbackslash{}} at the end of it. So a multiline if statement will look as follows:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ lander\_is\_within\_horizontal\_limits }\KeywordTok{and} \OperatorTok{\textbackslash{}}
\NormalTok{   lander\_vertical\_speed\_is\_good }\KeywordTok{and} \OperatorTok{\textbackslash{}}
\NormalTok{   lander\_horizontal\_speed\_is\_good:}
\NormalTok{   ...}
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  ...}
\end{Highlighting}
\end{Shaded}

Implement landing checks in \emph{code08.py}.

\hypertarget{more-rounds}{%
\section{More rounds}\label{more-rounds}}

Extend the game to have more than one round after the player either landed or crashed. Remember to reset the position of the lander before each new round. You can also add a \texttt{reset()} method to the landing pad as well, randomizing it horizontal position.

Add \texttt{reset()} method to the \texttt{LandingPad} class.
Add more rounds in \emph{code09.py}.

\hypertarget{limited-fuel}{%
\section{Limited fuel}\label{limited-fuel}}

Let us add a fuel limit to make things more interesting, so that thrursters would work \emph{only} if there is any fuel left. For this, define a new setting \texttt{full\ tank} (I've picked it to be \texttt{100} but you can have more) and add a new attribute \texttt{fuel} to the \texttt{Lander} class (remember that you need to explicitly define all attributes in the constructor). The \texttt{fuel} level should be set to \texttt{full\ tank} whenever you reset the lander.

Every use of a thruster should reduce this by 1 and thrusters should work \emph{only} if there is fuel. You need to take care of this in the \texttt{update()} method. Think about how you would do it for both vertical and horizontal thrusters.

We also need to tell the player how much the fuel is left. I've implemented it as a bar gauge but you can implement it as text stimulus as well. Create the appropriate visual attribute in the constructor of the \texttt{Lander} class. Remember to update it every time the level of the fuel changes and to draw it whenever you draw the lander itself. As a nice touch, you can change the color to indicate how much of the fuel is left. I've used \emph{green} for more than 2/3, \emph{yellow} for more than 1/3, and \emph{red} if less than that.

Add fuel and fuel gauge to \texttt{Lander} class.

\hypertarget{add-to-it}{%
\section{Add to it!}\label{add-to-it}}

We already have a functioning game but you can add so much more to it: visuals for the thrusters, sounds, background, etc. Experiment at will!

\hypertarget{space-invaders}{%
\chapter{Space invaders: mixins and duck typing}\label{space-invaders}}

Today we will program a classic Space Invaders game with a twist. We will be using object-oriented programming but you will learn about \emph{mixins} and \emph{duck typing}. Previously, you have learned how to ensure generalization --- common behavior for different classes --- via inheritance. E.g., when all visual stimuli inherit from the save \texttt{BaseVisualStim} class, you can be sure that they all have \texttt{size}, \texttt{ori}, and \texttt{pos} properties and that you can \texttt{draw()} them. However, this approach may not be best suited for cases when the same class must implement several different behaviours. One solution is to use \emph{multiple inheritance}, so that a class is a descendant of several classes and, thus, get behavior from many of them. This is the canonical way of ensuring generalization but you can achieve same means differently.

\hypertarget{mixins}{%
\section{Mixins}\label{mixins}}

One way to infuse a \emph{common} behavior into \emph{different} classes is via a mixin classes. These are classes that only define a single \emph{behavior} (i.e., a method) and nothing else. No constructor and, typically, no attributes. Thus, they are too limited to be used on their own but can be inherited from (mixed into the proper class) enabling that single behavior in the descendant.

Think about all creatures that can fly: insects, birds, bats, astronauts, etc. They do have a common ancestor but that common ancestor did not have the ability to fly. Instead, each line evolved that ability independently and all have evolutionary ``cousins'' that cannot fly. When programming, you can follow the same pattern of creating a common ancestor for flying and non-flying insects, then implementing ability to fly in the former. Do the same for birds, bats, astronauts, etc. If your implementation must be very detailed and creature-specific, this might be unavoidable. However, if your ability to ``fly'' is very abstract and, therefore, the same for all creatures in question, you will end up writing the same code for every insect, bird, bat class. An easy copy-paste, of course, but that means you get multiple places with identical implementation, so when you need to change it, you will have to make sure that you do it in all the places (and you gonna miss some, I always do). Alternative? Mixins! You create a class \texttt{FlightAbility} that implements that common abstract ``flying'' and, then, you inherit from that class whenever you need a flying someone. Mix a non-flying bird with the \texttt{FlightAbility} and it can fly! Mix it with an insect: Flying insect! You may also mix in more than one ability. Again, start with a bird that just walks around (a chicken). Add a mixin \texttt{FlightAbility} and you get a flying bird (a pigeon). Take the walking bird again and mix in \texttt{SwimAbility} and you get a swimming bird (a penguin). Mix in \emph{both} and you get a bird that can both fly and swim (a swan)!

You may not need mixins frequently but they are a powerful way of creating an isolated behavior that different classes might need without enforcing strict inheritance structure. PsychoPy is big on mixins. For example, it has \texttt{ColorMixin} that could be mixed-in to a visual class that needs to work with color, so it implements all the repetitive\footnote{boilerplate} code for translating an arbitrary color representation (string, hexadecimal code, RGB triplet, HSL triplet, single grayscale value, etc.) into the internal RGB color value. It also has \texttt{TextureMixin} for classes that use textures for drawing objects. In our \emph{Space Invaders} game, we will use a Mixin class to mix in a ``boom sound when exploded'' behavior, common to both aliens and the player's ship.

\hypertarget{duck-typing}{%
\section{Duck typing}\label{duck-typing}}

Alternatively, you might need your object to behave in a certain way but having a proper class hierarchy is an overkill because this is only one class and you might want some but not all the functionality. The idea is to use ``duck typing'', which comes from saying ``If it walks like a duck, and it quacks like a duck, then it must be a duck.'' In other words, if the only things you care about are walking and quacking, do you need it to be an actual duck\footnote{A man is hailing a taxi on a sidewalk. A car stops next to him. The guy looks at it and says ``But where is the taxi sign on the roof?''. The driver replies: ``Do you need a taxi sign on the roof or a ride?''}? Will a goose that can walk and quack the same way do? Will a \emph{dog} that can walk and quack like a duck do? Obviously, the correct answer is ``it depends'' but in a lot of situations you are interested in a common behavior rather than in a common ancestor.

Duck typing is a popular method in Python. For example, \texttt{len(object)} is a canonical way to compute length of an object. That object could be a string \texttt{len("four")}, or a list \texttt{len({[}1,\ 2,\ 3,\ 4{]})}, a tuple \texttt{len(tuple(1,\ 4,\ 2))}, a dictionary \texttt{len(\{"A":\ 1,\ "B":\ 5\})}, etc. The idea is that as long as a class has a concept of length (number of elements, number of characters, etc.), you should be able compute its length via \texttt{len()}. This is achieved by adding a \emph{special method} to the class \texttt{\_\_len\_\_(self)} that must return an integer. This is called a ``hook method'', as it is never called directly but is ``hooked'' to the \texttt{len()} function call. Thus, whenever you write \texttt{len(object)}, it is actually translated into \texttt{object.\_\_len()\_\_}\footnote{Why not implement it as a method \texttt{object.len()} or, even better, as a read-only property \texttt{object.len}? Read \href{https://mail.python.org/pipermail/python-3000/2006-November/004643.html}{here} for the justification.}.

Another popular duck typing application is an implementation of an iterator: an object that yields one item at a time, so you can do lazy computation\footnote{Lazy computation means that you compute or get only what is necessary right now, rather than computing or getting all items in one go.} or loop over them. You already know how to implement an \protect\hyperlink{iteratorgenerator-functions}{iterator as a function} but it also be defined as a class with two special methods: \texttt{\_\_iter\_\_(self)} and \texttt{\_\_next\_\_(self)}. The former is called when iteration starts and it should perform a necessary initialization (e.g., setting internal counter to 0, shuffling elements, etc.) and must return an \emph{iterator object} (typically, a reference to itself). The \texttt{\_\_next()\_\_} method is called whenever the next item is needed: if you use iterator in the \texttt{for} loop, it is called automatically or you can call it yourself via \texttt{next(iterator\_object)}. \texttt{\_\_next()\_\_} must return the next item or \href{https://docs.python.org/3/reference/simple_stmts.html\#the-raise-statement}{raise} a \href{https://docs.python.org/3/library/exceptions.html\#StopIteration}{StopIteration} \protect\hyperlink{exceptions}{exception}, signalling that it ran out of items.

Note that an iterator does not require an implementation of the \texttt{\_\_len()\_\_} method! How come? If you have items you can iterate over, doesn't it make sense to also know how many (length of an object)? Not necessarily! First, if you use an iterator in a \texttt{for} loop and you just want to iterate over all of the items until you run out of them (which is signaled by the \href{https://docs.python.org/3/library/exceptions.html\#StopIteration}{StopIteration} exception). Thus, their total number and, hence, \texttt{len()} method is of little interest. Accordingly, why implement a function that you do not need\footnote{Of course, if you \emph{do} need it, you should implement it. The point is that quite often you do not.}? Second, what if your iterator is endless (in that case, it is called a \emph{generator})? E.g., every time \texttt{\_\_next\_\_()} is called it returns one random item or a random number. This way, it will never run out of items, so the question of ``what is its length'' is meaningless unless you take ``infinity'' as an answer. This lack of need for \texttt{\_\_len\_\_()} for iterators is the spirit of duck typing: implement only the methods you need for your duck, ignore the rest.

Below, you will practice duck typing by implementing both \texttt{\_\_len()\_\_} and two special iterator methods as part of our \texttt{AlienArmada} class.

\hypertarget{which-one-to-use}{%
\section{Which one to use?}\label{which-one-to-use}}

Now you know \emph{three} methods to produce common behavior: proper inheritance, mixins, and duck typing. Which one should you use? Depends on what you need. If you have many classes and you can have a well defined inheritance tree, use it. However, if you have some specific behavior that you need in some classes that is hard to fit with the inheritance tree, use mixins. If you have a single class that needs very specific functionality, such as an iterator: use duck typing. Using any one of them does not preclude you using others, but be moderate, using too many different paradigms will be confusing for you and a reader.

\hypertarget{space-invaders-1}{%
\section{Space Invaders}\label{space-invaders-1}}

We will program a simple version of the game with a gradually descending alien armada. Your task is to capture all aliens by firing a teleport beam before one of them rams your ship or gets away. Below, you can see my version of the game.

As per usual, the plan is to move slowly in small steps to keep complexity of changes low. Here are the steps:

\begin{itemize}
\tightlist
\item
  Start with our usual PsychoPy boilerplate hidden in a context manager.
\item
  Add a \texttt{Spaceship} and use mouse to move it along the bottom of the screen.
\item
  Create an \texttt{Alien} and then the whole \texttt{AlienArmada}.
\item
  Add \texttt{Laser}, then a \texttt{LaserGun}, so that the player can fire many laser shots by pressing left mouse key.
\item
  Add check for hitting aliens with the laser and teleporting them off the screen.
\item
  Use mixin to add teleport sound.
\item
  Use cool iterators to cycle through lasers and aliens.
\item
  Make alien armada move.
\item
  Check for end-of-game.
\end{itemize}

Before we start, grab images that we will use for the game \href{material/space-invaders.zip}{space-invaders.zip}, created specifically for our seminar by Andrej Pastukhov, who said you absolutely must look at this link: \href{https://youtu.be/dQw4w9WgXcQ}{Wie die Pixelarts meines Sohnes Andrej entstanden sind}\footnote{No worries, it is safe. He says, you should understand. But I have no idea because, evidently, I am a dinosaur out of touch with modern trends.}.

\hypertarget{boilerplate-2}{%
\section{Boilerplate}\label{boilerplate-2}}

Create our usual boilerplate with an external settings file via a context manager with \texttt{GameAbort} exception handling. You can reuse the code from our last game but I strongly suggest checking that you understand every step. My suggestion for the window size is 640×480 because the sprites are 32×32 but chose whatever looks good on your screen.

Create \texttt{GameContext} and \texttt{GameAbort} classes.
Put your boilerplate code into \emph{code01.py}.

\hypertarget{the-spaceship}{%
\section{The spaceship}\label{the-spaceship}}

Create a new file for \texttt{Spaceship} class. It is remarkably boring as it just an image that moves left-right on a horizontal line. Thus, we will create it as a descendant of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} class. The only method that you need to define right now is the constructor \texttt{\_\_init\_\_()}. It should take \href{https://psychopy.org/api/visual/window.html\#psychopy.visual.Window}{Window} and image filename (should be stored in settings) as parameters (plus the compulsory \texttt{self}, of course) and call \texttt{super().\_\_init\_\_(...)} to initialize itself via the inherited constuctor. Apart from the two parameters you have, you also need to specify the initial position of the ship via \texttt{pos}. The ship should be somewhere just above the lower edge of the window. For me, vertical position of -0.9 worked quite nicely.

In the main code, create an object and draw it in the main loop.

Create \texttt{Spaceship} class in a separate file.
Use it in \emph{code02.py}.

\hypertarget{the-spaceship-moves}{%
\section{The spaceship moves}\label{the-spaceship-moves}}

Now, let us use the \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{mouse} to control the horizontal position of the ship and, later on, left button to shoot. First, initialize the mouse in the context manager, so that it is one its attributes (then you can use it as \texttt{ctx.mouse}). Then, in the main loop, use \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPos}{getPos()} method to get the position of the mouse and use the \emph{horizontal} component to alter the position of the ship. Note that you \emph{cannot} assign just a horizontal or vertical components to the position via \texttt{.pos{[}0{]}\ =\ ...}. In my PsychoPy 2021.1.4 it does not generate an error but does not change the actual position either. Thus, you need to assign a tuple of \texttt{(new\ horizontal\ component,\ original\ vertical\ component)} (the ship should stay at the same vertical position throughout the game). Test moving your spaceship around. You can make mouse invisible (see \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{documentation}) to make it more immersive.

Add mouse to \texttt{GameContext}
Use mouse to move ship in \emph{code03.py}.

\hypertarget{an-alien-appears}{%
\section{An alien appears}\label{an-alien-appears}}

Before we create an alien armada, let us create a single alien. The class will be very basic, which is why, we will put both \texttt{Alien} and \texttt{AlienArmada} into the same file (so, think about its filename). The class itself is similar to the \texttt{Spaceship}. The only differences are that it should take (and pass) \texttt{pos} parameter (unlike the spaceship that always appears at the same location) and that the image should be \href{https://docs.python.org/3/library/random.html\#random.choice}{randomly picked} from a tuple of filenames (\emph{alien-1.png} and \emph{alien-2.png}, the names should be defined in the settings in an ``aliens'' group of settings). For testing, place a few aliens at arbitrary locations on the screen to check that an alien image is randomly picked. Do not forget to draw them in the main loop.

Create an \texttt{Alien} class
Use them in \emph{code04.py}.

\hypertarget{using-names-to-indicate-access-restrictions}{%
\section{Using names to indicate access restrictions}\label{using-names-to-indicate-access-restrictions}}

Before we create an alien armada, we need to make a quick detour to talk about \href{https://peps.python.org/pep-0008}{naming conventions} for attributes and names of classes. Unlike most other languages, Python does not have private attributes or methods, i.e., attributes or methods accessible only from inside the object. If you come from Java or C\#/C++, a thought that you can call \emph{any} method and modify \emph{any} attribute from outside should give you chills, as it becomes impossible to predict object's behavior. Python ``solves'' the access problem via a ``gentlemen's agreement'' that methods and attributes whose names start either with \texttt{\_\_} or \texttt{\_} should be \emph{considered} private. In other words, you should not use them directly. In case of \texttt{\_\_}, you are also prevented from doing it in a straightforward way, as the name is \href{https://peps.python.org/pep-0008/\#descriptive-naming-styles}{mangled}. In the example below, you cannot access the \texttt{\_\_color} attribute directly:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ ExampleClass:}
  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \VariableTok{self}\NormalTok{.\_\_color }\OperatorTok{=} \StringTok{"red"}

\NormalTok{example }\OperatorTok{=}\NormalTok{ ExampleClass()}

\CommentTok{\# raises AttributeError}
\BuiltInTok{print}\NormalTok{(example.\_\_color)}
\CommentTok{\#\textgreater{} Error in eval(expr, p): AttributeError: \textquotesingle{}ExampleClass\textquotesingle{} object has no attribute \textquotesingle{}\_\_color\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

But as Python does not have truly private attributes, you can still access it via its mangled name\texttt{object.\_\textless{}ClassName\textgreater{}\textless{}hidden\ attribute\ name\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{example.\_ExampleClass\_\_color}
\CommentTok{\#\textgreater{} \textquotesingle{}red\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

However, this is a last resort sort of thing that you should use only if you absolutely must access that attribute or method and, hopefully, know what you doing.

As noted above, you can also come across attributes with a \emph{single} leading underscore in the name, e.g.~\texttt{\_color}. This is a weak ``internal use'' indicator, so they are fully visible. However, the leading underscore does \emph{hint} that this attribute or method should be \emph{considered} private. So, if you see an attribute like \texttt{\_color}, you should pretend that you know not of its existence and, therefore, you never read or modify it directly. Of course, this is only an \emph{agreement}, so you can always ignore it and work with that attribute directly\footnote{On a side note of doing crazy things that you should not: You can replace a class method without inheritance with your own at run time, this is called a \href{https://en.wikipedia.org/wiki/Monkey_patch}{monkey patch}!}. However, this almost certainly will break the code in unexpected and hard-to-trace ways.

\hypertarget{an-alien-armada-appears}{%
\section{An alien armada appears}\label{an-alien-armada-appears}}

One alien is neither scary, nor challenging enough. We want more! For this, we will create an \texttt{AlienArmada} class with a twist. It will be responsible for creating a grid of aliens, moving them around (our chance to learn about special setter methods), allowing outside processes to iterate over them (iterator duck typing), and reporting the number of remaining aliens (length duck typing). As usual, we will do this one step at a time.

Start by creating an \texttt{AlienArmada} class, below the \texttt{Alien} class. Our initial version will the following methods

\begin{itemize}
\tightlist
\item
  a compulsory constructor,
\item
  \texttt{spawn()} that creates and places individual aliens,
\item
  \texttt{draw()} that draws aliens,
\end{itemize}

and attributes

\begin{itemize}
\tightlist
\item
  \texttt{win} a PsychoPy window,
\item
  \texttt{\_\_pos} that is a tuple with the position of the armada center within the window,
\item
  \texttt{aliens} which is a list with alien objects.
\end{itemize}

You must also expand your settings. By now you should already have an \texttt{Aliens} settings section with alien images' filenames. To define the armada, we need also need to add

\begin{itemize}
\tightlist
\item
  \texttt{"Initial\ position"}: center of the armada, I've picked \texttt{{[}0,\ 0.5{]}} but you can always optimize it later on.
\item
  \texttt{"Grid\ size"}: number of aliens horizontally and vertically, I've used `{[}7, 3{]}.
\item
  \texttt{"Grid\ step\ {[}norm{]}"}: distance between aliens in ``norm'' units, I've picked 0.2.
\end{itemize}

\emph{Constructor}: we will create and place aliens in a separate method \texttt{spawn()}, so our constructor will be very simple. As far as parameters are concerned, you need to pass a \href{https://psychopy.org/api/visual/index.html}{Window} for creating \texttt{Alien} objects and a dictionary with armada-specific settings. Store both of them as attributes for later use, initialize \texttt{\_\_pos} to the \texttt{"Initial\ position"}, initialize \texttt{aliens} to an empty list and \texttt{spawn()} them (again, all attributes must be initialized in the constructor, even if to an empty list or \texttt{None}).

In the \texttt{spawn()} create aliens on a grid based on your \texttt{"Grid\ size"} and \texttt{"Grid\ step\ {[}norm{]}"} settings, so they are centered at \texttt{AlienArmada}'s position (\texttt{\_\_pos}). All aliens go to \texttt{aliens} attribute, of course. Remember that they need a list of file names for visuals but you have it covered as you have them in the settings. It should look like this:

\begin{center}\includegraphics[width=8.89in]{images/alien-armada} \end{center}

Create the \texttt{AlienArmada} class.
Use it in \emph{code05.py}.

\hypertarget{a-laser-shot-appears}{%
\section{A laser shot appears}\label{a-laser-shot-appears}}

Now we need to create \texttt{Laser} class (in a separate file). Eventually, when a player presses left mouse button, the laser should appear at the location just above the ship and fly up with a certain speed. As per usual, all parameters for laser (and \texttt{LaserCannon}) should be stored in the settings file under a separate section (e.g., \texttt{laser}). For the moment, we only need to specify \texttt{speed\ {[}norm/sec{]}} (laser shot speed in norm units per second, I've picked 1 norm / second, so it takes 2 seconds for the shot to fly across the screen)) and, optionally, filename of the laser bitmap (but that could be also hardcoded, as we have only one image).

Let us take care of the first step: creating a laser shot just above the sheep. Create \texttt{Laser} class as a descendant of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} (just like our \texttt{Spaceship} and \texttt{Alien} classes). It should take \texttt{win}, \texttt{pos}, and \texttt{speed} as arguments and call the ancestor constructor. The \texttt{pos} argument is the position of the ship (that fired it) but the laser must appear \emph{above} it, so you need to adjust \texttt{pos{[}1{]}} for that (hint, you can get window height from \texttt{win.size{[}1{]}} and you know that sprites are 32 pixels high). The \texttt{speed} is in \emph{norm units per second} from the settings. You need to save the \texttt{speed} value in an attribute for later use.

For testing, create a laser object right after you create the ship itself and draw it in the main loop. It won't move but you will be able to see whether you've got the height right.

Create the \texttt{Laser} class.
Use in \emph{code06.py}.

\hypertarget{the-laser-shot-flies}{%
\section{The laser shot flies}\label{the-laser-shot-flies}}

Let us add \texttt{fly()} method to the laser. It will be very simple, every time it is called the laser should move upwards. As in a Moonlander game, we need a \href{https://psychopy.org/api/clock.html\#psychopy.clock.Clock}{clock} to measure the time elapsed between the updates, so create it as an attribute in the constructor. In the \texttt{fly()} method, you need to figure out the time elapsed since the last call or since the shot was created (don't forget to reset the timer after that) and move the shot based on its \texttt{speed} and elapsed time.

Remember to call \texttt{fly()} method in the main loop and see how the laser flies up and off the screen.

Add \texttt{fly()} method to \texttt{Laser} class.
Use it in \emph{code07.py}.

\hypertarget{we-want-more-lasers}{%
\section{We want more lasers!}\label{we-want-more-lasers}}

Now we will create a \texttt{LaserGun} class that will take care of individual laser shots. It will 1) create a new \texttt{Laser} object whenever we \texttt{fire()} from it, 2) ensure that it does not overheat by allowing only one shot every N seconds (another parameter to be defined in the settings file, let's say 0.3 s), 3) call \texttt{draw()} and \texttt{fly()} methods for all laser shots. We will create the class \texttt{LaserGun} in the same file as the \texttt{Laser}.

In the constructor, pass PsychoPy window variable and a dictionary with laser gun specific settings (these should include the \texttt{speed} that you specified earlier and the cool down period in seconds) and store both in attributes for later use. Initialize \texttt{lasershots} attribute with empty list, and create a cool down \href{https://psychopy.org/api/clock.html\#psychopy.clock.CountdownTimer}{timer}.

The \texttt{fire()} method should take position of the ship as a single parameter. If enough time passed since the last shot (check the cool down timer for that), create a new \texttt{Laser} at the supplied position, add it to the \texttt{lasershots} list, and reset the cool down timer. In \texttt{draw()}/\texttt{fly()} simply draw/fly all \texttt{lasershots}.

For testing, use \texttt{LaserGun} in place of the \texttt{Laser}. Both have same \texttt{draw()} and \texttt{fly()} methods that you should be calling already. In the main loop, check if left mouse button is \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPressed}{pressed}. If it is, \texttt{fire()} the laser gun, passing current position of the ship to it.

Create \texttt{LaserGun} class.
Test it in \emph{code08.py}.

\hypertarget{too-many-lasers}{%
\section{Too many lasers!}\label{too-many-lasers}}

We do not need our lasers once they fly of the screen, so we should remove them. First, we need to know which \texttt{Laser} shot has \texttt{expired}``: is off the screen (this section) or hit its target (the next section). For this, modify the \texttt{Laser} class by adding an \texttt{expired} attribute that is set initially to \texttt{False} (the shot is good). In addition, write a new method \texttt{check\_screen\_limits()} that would set \texttt{expired\ =\ True} if the shot is above the upper edge of the window but leaves \texttt{expired} as is (unmodified!) otherwise (the shot could be within the screen and get \texttt{expired} because it hit an alien).

Next, add a \texttt{cleanup()} method to the \texttt{LaserGun} class that will call \texttt{check\_screen\_limits()} for all shots and then remove all \texttt{expired} ones. This is both simple and tricky! Conceptually simple: you loop over \texttt{lasershots} and delete any object that is \texttt{expired}. The easy way is to do it via \protect\hyperlink{list-comprehension}{list comprehension} (deleting objects by not including them in the updated list) but for didactic reasons we will use \href{https://docs.python.org/3/tutorial/datastructures.html\#the-del-statement}{del} instead. If you have a list and you want to delete a second element, you write

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1, 3, 4, 5]}
\end{Highlighting}
\end{Shaded}

However, there is a catch. Imagine that you want to delete second and forth elements, so that the result should be \texttt{{[}1,\ 3,\ 5{]}}. If you just delete second and then forth elements, you won't get what you want:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{3}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1, 3, 4]}
\end{Highlighting}
\end{Shaded}

Do you see why? Solution: start deleting from the end, this way indexes of earlier elements won't be affected:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{3}\NormalTok{]}
\KeywordTok{del}\NormalTok{ x[}\DecValTok{1}\NormalTok{]}
\BuiltInTok{print}\NormalTok{(x)}
\CommentTok{\#\textgreater{} [1, 3, 5]}
\end{Highlighting}
\end{Shaded}

Note that you must use \texttt{del\ list{[}index{]}} format, so you need to use indexing in the for loop of the \texttt{cleanup()} method:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ ishot }\KeywordTok{in}\NormalTok{ backwards}\OperatorTok{{-}}\NormalTok{index}\OperatorTok{{-}}\NormalTok{built}\OperatorTok{{-}}\NormalTok{via}\OperatorTok{{-}}\NormalTok{the}\OperatorTok{{-}}\BuiltInTok{range}\OperatorTok{{-}}\NormalTok{function:}
\NormalTok{  check }\ControlFlowTok{if}\NormalTok{ lasershot has left the screen}
  \ControlFlowTok{if} \VariableTok{self}\NormalTok{.lasershots[ishot] needs to be deleted:}
\NormalTok{    delete that }\VariableTok{self}\NormalTok{.lasershots[ishot]}
\end{Highlighting}
\end{Shaded}

Add \texttt{cleanup()} call to the main loop right after the \texttt{fly()} to automatically delete expired shots. Once you fired a few shots and they are all off the screen, put a breakpoint and check that the \texttt{.lasershots} is empty (your \texttt{cleanup()} works as it should).

Add \texttt{expired} property to \texttt{Laser}.
Add \texttt{cleanup()} method to \texttt{LaserShot}.
Use \texttt{cleanup()} in \emph{code09.py}.

\hypertarget{i-am-hit-i-am-hit}{%
\section{I am hit! I am hit!}\label{i-am-hit-i-am-hit}}

Now we need to check whether a lasershot hit an alien. In that case, all the relevant aliens and shots must be removed. Removing lasershots is easy: We just set them as \texttt{expired} and \texttt{cleanup()} does the rest. Clearly, we need the same mechanism for the aliens.

Add \texttt{hit} attribute to the \texttt{Alien} class and initialize to \texttt{False} (an alien is not initially hit). In \texttt{AlienArmada} class, implement a \texttt{cleanup()} method, analogous to one in \texttt{LaserGun} that will delete any alien that is \texttt{hit}. Add the call to it in the main loop at the same location as for the \texttt{LaserGun}. You can test it by setting \texttt{hit} to \texttt{True} for one of the aliens and it should be missing.

Now for the actual check. You should loop over all aliens and laser shots attributes of \texttt{AlienArmada} and \texttt{LaserGun} checking \emph{every pair} on whether they \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim.overlaps}{overlap}. If they do, set laser shot to \texttt{expired} and the alien as \texttt{hit}. Do this check \emph{before} the clean up but \emph{after} the laser shots fly.

Test it!

Update \texttt{Alien} and \texttt{AlienArmada} classes
Check for laser shots hitting aliens
in \emph{code10.py}, .

\hypertarget{duck-typiing-iterators}{%
\section{Duck typiing iterators}\label{duck-typiing-iterators}}

In the precious exercise, you used \texttt{aliens} and \texttt{lasershots} attributes directly in the loop. However, let us inject some coolness into our code and turn \texttt{AlienArmada} and \texttt{LaserGun} classes into iterators. Recall that you need to implement two special methods for this: \texttt{\_\_iter\_\_(self)} and \texttt{\_\_next\_\_(self)\_\_}. The first one, initializes the loop, the second one yields the next item. The actual implementation is very simple. You need to create a new attribute that will be used to track which item you need to yield, call it \texttt{iter} and initialize it to \texttt{None} in the constructor.

In the \texttt{\_\_iter\_\_(self)}, initialize the counter to \texttt{0} and return \texttt{self}: a returning the reference to the iterator, which is the object itself\footnote{You can cheat and return the reference to the list attribute itself and it'll do the rest but do not do it for didactic purposes.}. In the \texttt{\_\_next\_\_(self)}, check if \texttt{iter} is within the (\texttt{aliens} or \texttt{lasershots}) list length. If it is not (i.e., you ran out aliens/shots to iterate over), \texttt{raise\ StopIteration}. If it is, increase the iteration counter and return the element it was indexing \emph{before} that: Think about why you need to return \texttt{self.aliens{[}self.iter\ -\ 1{]}} rather than \texttt{self.aliens{[}self.iter{]}} or how you can use a different starting value and range check to avoid this.

Do this for both classes and use them in for loops directly, i.e.~looping over \texttt{aliens} and \texttt{laser} instead of \texttt{aliens.aliens} and \texttt{laser.lasershots}.

Test it! It should work as before, of course, but with cooler duck typing inside!

Turn \texttt{LaserGun} and \texttt{AlienArmada} into iterators.
Use them as iterators in \emph{code11.py}.

\hypertarget{gotem-all}{%
\section{Got'em all!}\label{gotem-all}}

Now, implement \texttt{\_\_len\_\_()} method for \texttt{AlienArmada} class that returns the number of remaining aliens. In the main loop, use it via \texttt{len()} function to check whether you won: no aliens left, the game is over. Use \texttt{len()} with the object, not with its \texttt{aliens} list attribute!

Add \texttt{\_\_len\_\_()} special method to \texttt{AlienArmada} class.
Use it to check whether all aliens are hit
in \emph{code12.py}.

\hypertarget{ping}{%
\section{Ping!}\label{ping}}

Now let us use a \texttt{HitSoundMixin} class that defines a single \texttt{hit()} method (no constructor!) that plays the \emph{teleport.wav} sound\footnote{Created by Sergenious and obtained from \href{https://freesound.org/people/Sergenious/sounds/55853/}{freesound.org}} from \href{material/space-invaders.zip}{materials}. It can be a single line method when you both create and play the sound in one go, no temporary variable or an attribute are required. When you use it as an ancestor for the \texttt{Alien} class, it has that \texttt{hit()} method. Call it when you set \emph{hit} to \texttt{True}.

Create \texttt{HitSoundMixin} class.
Mix it into the \texttt{Alien} class.
Use it in \emph{code11.py}.

\hypertarget{getter-setter}{%
\section{Virtual attributes via getters and setters}\label{getter-setter}}

Our next detour is to learn how you can create a private attribute (within \protect\hyperlink{access-restrictions}{the limits of Python}, of course). Recall that we have a \texttt{\_\_pos} attribute of an \texttt{AlienArmada} class that defines its location. The catch is that changing the position of the armada means changing position of all the aliens that constitute the armada. This means that we need write a method that receive a new position for the armada and updates both the \texttt{\_\_pos} attribute and positions of individual aliens. And that is exactly what getter/setter methods are for. They are declared via special \emph{decorators}\footnote{These are functions that ``decorate'' you function and are called \emph{before} your function is called. They are like gatekeepers or face control, so they can alter whether or how your function is executed.}: \texttt{@property} and \texttt{@\textless{}name\textgreater{}.setter}. You already know the former one that we used to compute a value on-the-fly. But it also be used to get a value of a ``private'' attribute, which is why it is called a ``getter'' method. The latter decorator, is for a ``setter'' method that \emph{sets} a new value to a private attribute. The idea of using them together is to isolate an actual attribute value from the outside influence. It is particularly helpful, if you need to control whether a new value of an attribute is a valid one, needs to converted, additional processing, etc. For example, \texttt{color} attribute of the rectangle stimulus uses this approach, which is why it can take RGB triplets, hexadecimal codes, or plain color names as a value and set the color correctly.

Here is a sketch of how it could work for a virtual attribute for \texttt{color}. One typically creates an \emph{internal} attribute with almost the same name, e.g., \texttt{\_color} or \texttt{\_\_color}. The value is stored and read from that internal attribute by getter and setter methods:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{ ExampleClass:}

  \KeywordTok{def} \FunctionTok{\_\_init\_\_}\NormalTok{(}\VariableTok{self}\NormalTok{):}
    \VariableTok{self}\NormalTok{.\_\_color }\OperatorTok{=} \StringTok{"red"}

  \AttributeTok{@property}
  \KeywordTok{def}\NormalTok{ color(}\VariableTok{self}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    This is a getter method for virtual color}
\CommentTok{    attribute.}
\CommentTok{    """}
    \CommentTok{\# Here, we simply return the value. But we could }
    \CommentTok{\# compute it from some other attribute(s) instead.}
    \ControlFlowTok{return} \VariableTok{self}\NormalTok{.\_\_color}
    
  \AttributeTok{@color.setter} \CommentTok{\# not the most elegant syntax, IMHO}
  \KeywordTok{def}\NormalTok{ color(}\VariableTok{self}\NormalTok{, newvalue):}
    \CommentTok{"""}
\CommentTok{    Note that the setter name has THE SAME name as the getter!}
\CommentTok{    It sets a new value and does not return anything.}
\CommentTok{    """}
  
    \CommentTok{\# Here, you can have checks, conversion, }
    \CommentTok{\# additional changes to other attributes, etc.}
    \VariableTok{self}\NormalTok{.\_\_color }\OperatorTok{=}\NormalTok{ newvalue}
    
    
\NormalTok{example }\OperatorTok{=}\NormalTok{ ExampleClass()}

\CommentTok{\# get the value, note the lack of () after color}
\BuiltInTok{print}\NormalTok{(example.color)}

\CommentTok{\# set the value}
\NormalTok{example.color }\OperatorTok{=} \StringTok{"blue"}
\end{Highlighting}
\end{Shaded}

Note that there is no \emph{actual} attribute \texttt{color}\footnote{Just like there is no physical phenomenon called ``color''!}, yet, our code works as if it exists.

There is another twist to the story. If you only define the getter \texttt{@property} method but no setter method, your hidden property is read-only\footnote{Note that you cannot have write-only property, you must have either getter alone or both.}!

\hypertarget{the-alien-armada-jumps}{%
\section{The alien armada jumps}\label{the-alien-armada-jumps}}

Currently, our aliens are sitting ducks. No fun! They need to get a move on. But before we can move alien armada around, we need to be able to change its position. So let us write getter/setter methods for it. To start with, define a getter, as it only needs to return the value of the hidden position attribute.

Now to more complicated and, hence, fun bit! Remember, we need to move \emph{all} individual aliens relative to the center of the armada. For this,

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  compute the \emph{change} in its position based on current and new value,
\item
  use it to alter position of individual aliens based on their current position,
\item
  store the new position in the private attribute.
\end{enumerate}

Test it by making armada jump to a random location every time you press \emph{space} button. The armada should keep its formation!

Implement getter/setter methods for \texttt{\_\_pos} in \texttt{AlienArmada}.
Test it in \emph{code12.py}.

\hypertarget{the-alien-armada-moves}{%
\section{The alien armada moves}\label{the-alien-armada-moves}}

Our alien armada will move downwards along a sine trajectory:

\[x = x_{max} \cdot sin(2 \pi f \cdot (y-y_{origin})) \]
where \(x_{max}\) is maximal deviation of the \emph{center} of the armada from the middle of the screen (I've set it to \(0.25\)), the \(f\) is the frequency, i.e., how fast is horizontal movement (I've set it to \(3\) but you can see how much slower it would be for \(1\) in the plot below), \(y\) is the current vertical coordinate of the armada and \(y_{origin}\) is the initial one (\(0.5\) in my case). As with all other parameters, these should be part of the settings file plus \texttt{vertcal\ speed\ {[}norm/sec{]}} that defines how fast the armada will fly down (I would set it to 0.1, so it takes 15 seconds to fly down).

\includegraphics{14-space-invaders-duck-typing_files/figure-latex/unnamed-chunk-8-1.pdf}

For the armada to fly, we need to add a timer (in the constructor) and define a \texttt{fly()} method that

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  computes the times since the armada creation
\item
  computes current vertical position based on the starting location, elapsed time (from the timer), vertical speed defined in settings
\item
  computes current horizontal position given the formula above and the relevant settings
\item
  updates current position via a simple \texttt{self.pos\ =\ (new\_x,\ new\_y)} (the setter method will take care of the rest)
\end{enumerate}

In the main loop, call \texttt{fly()} when you call it for laser gun.

Add \texttt{fly()} method to \texttt{AlienArmada} class.
Use it in \emph{code13.py}.

\hypertarget{the-alien-armada-wins-crash}{%
\section{The alien armada wins: crash!}\label{the-alien-armada-wins-crash}}

So far, the player always wins. Let us make it more dangerous! They will lose if either an alien crashes into the spaceship or if the armada goes past the ship. Implement the former the same way as you checked whether laser shot hit an alien: loop over aliens and see if they overlap with the spaceship (game over if they do). Implement and test.

Implement crash-into-ship in \emph{code14.py}.

\hypertarget{the-alien-armada-wins-missed-them}{%
\section{The alien armada wins: missed them!}\label{the-alien-armada-wins-missed-them}}

The second way to lose the game, is if at least one alien got past the ship. For this, we need to check the position of the \emph{lowest} alien and if it is lower than that of the spaceship, the game is over. You can do it in the same loop you are checking for the hit but, for didactic reasons, let us practice \texttt{@proprety} a bit more. Implement a new computed (read-only) property \texttt{lowest\_y} of the \texttt{AlienArmada} class that will return the y-coordinate of the lowest alien in the armada. You need to loop over individual aliens to find the lowest y and return it. There are different ways to do it, come up with one yourself! In the main code, add the check and make sure the game is over, if aliens got past the player.

Add \texttt{lowest\_y} computed property to \texttt{AlienArmada} class.
Use it in \emph{code15.py}.

\hypertarget{mixin-teleport}{%
\section{Mixin teleport}\label{mixin-teleport}}

Mix in the teleport sound method to the \texttt{Spaceship} and play it if alien crashed into it.

Mix in teleport to \texttt{Spaceship} class.
Use it in \emph{code16.py}.

\hypertarget{game-over-message}{%
\section{Game over message}\label{game-over-message}}

Create a blinking game over message that will reflect the outcome. Something like this but use your imagination:

\begin{itemize}
\tightlist
\item
  ``Congrats!'', if the player won.
\item
  ``Crash! Boom! Bang!'', if the player was hit.
\item
  ``They got away!'', if the armada got past the player.
\end{itemize}

One way to simplify you life is to rename \texttt{gameover} variable into the \texttt{gamestate} variable. Initially, it could be \texttt{"playing"}, so your loop repeats \texttt{while\ gamestate\ ==\ "playing"}. Then, you can set it based on the type of the event (\texttt{"victory"} when player wins, \texttt{"hit"} when they were hit by the armada, \texttt{"missed"} if aliens got away) and use it after the main loop to determine which message to show. Better still, use dictionary for this instead of if-else. Or ``cheat'' and store the message in the variable itself.

Put your updated code into \emph{code17.py}.

\hypertarget{we-want-more}{%
\section{We want more!}\label{we-want-more}}

You have a solid game but it can be improved in many ways. Score? Difficulty? More levels? Aliens shooting back at you? Anything is possible!

\hypertarget{game-of-life-numpy}{%
\chapter{Game of life (NumPy)}\label{game-of-life-numpy}}

Today you will be programming the \href{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}{Game of Life} created by the British mathematician John Horton Conway. This is not really a game but rather a simulation where you set initial conditions up and observe how the population evolves. The rules, \href{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}{as described on Wikipedia}, are very simple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Any live cell with two or three live neighbors survives.
\item
  Any dead cell with three live neighbors becomes a live cell.
\item
  All other live cells die in the next generation. Similarly, all other dead cells stay dead.
\end{enumerate}

Despite rules simplicity they produce remarkable evolution of a cell culture and give rise to many dynamic or static configurations. Here is an example simulation with a random starting state.

\hypertarget{implementing-the-rules}{%
\section{Implementing the rules}\label{implementing-the-rules}}

To program the game, you need to count live neighbors for every cell and use the rules above to decide whether it will be alive or dead on the \emph{next} iteration. The latter bit is important, you need to evaluate all cells at their current state, you cannot change their status during that period. Accordingly, on each iteration you need to a create \emph{new} cell culture and then overwrite the original one.

Our cells will live in a rectangular world, so you need to count number of neighbors in the 8 cells around it, as shown in the left hand-side image below (index / location of the dot in question is assumed to be \emph{i, j}).

\begin{center}\includegraphics[width=1\linewidth]{images/game-of-life-grid} \end{center}

However, things become slightly trickier, if a cell lies on the border of the world, as depicted on the right hand-side. The same rules for living or dying still apply but when counting neighbors you need to make sure that we do not try to access cells \emph{outside} of the world (marked in red). If we mess up our indexing, at best we will get an error, at worst we will access wrong elements. E.g., when our index is negative, Python will not issue a mistake but will simply count elements \emph{from the end}.

\hypertarget{numpy}{%
\section{NumPy}\label{numpy}}

Our cells live on a 2D grid which we can implement it as a list of lists. We will start with this implementation but you will see that using a matrix (a 2D array) is more natural. It also gives us opportunity to learn about \href{https://numpy.org/}{NumPy} that provides a powerful and fast implementation of multidimensional arrays and numerous mathematical tools. It is one of the core non-standard (i.e., not included into the base Python distribution) libraries that is so prominent that you are expected to use it via its alias rather than by its full name:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

I will not try to properly cover NumPy here, it is simply too vast. Rather, the purpose is to make you aware of opportunities that NumPy provides. The material below will contain just the bare minimum that we need for the game. I suggest that you read the \href{https://numpy.org/doc/stable/user/quickstart.html}{quickstart guide to NumPy} before continuing and you should be ready to consult \href{https://numpy.org/doc/stable/user/absolute_beginners.html}{the absolute basics for beginners} whenever you have questions about manipulating arrays.

\hypertarget{boilerplate-3}{%
\section{Boilerplate}\label{boilerplate-3}}

Implement usual PsychoPy boilerplate with a external settings and context manager. The context manager should initialize PsychoPy window and a mouse, whic we will use it later to draw or erase individual cells. The size of the window that we need depends on the grid size that cells live at and the size of the individual cells. Define all three parameters - \texttt{grid\ width\ {[}cells{]}}, \texttt{grid\ height\ {[}cells{]}}, and \texttt{cell\ size\ {[}pix{]}} - in the settings file and compute window size on the fly. I've picked a 30 by 30 grid with each cell measuring 10 pixels (both widht and height, as cells are square).

Create \texttt{GameContext} and \texttt{GameAbort} classes.
Put your boilerplate code into \emph{code01.py}.

\hypertarget{visualizing-an-array}{%
\section{Visualizing an array}\label{visualizing-an-array}}

We will use a 2D Numpy array to encode our cells: \(1\) will mean a living cell and \(0\) will mean an empty space. But before we create the array, we need to think about how we will visualize it. There are at least three ways you can do it in PsychoPy. First, you can create a \href{https://psychopy.org/api/visual/rect.html\#psychopy.visual.rect.Rect}{Rect} (or some over visual primitive or even an image) for each cell and draw them one-by-one in a loop. However, that will be extremely inefficient and slow. Second, you can do effectively the same one-primitive-per-cell but via an efficiently implemented \href{https://psychopy.org/api/visual/elementarraystim.html\#psychopy.visual.ElementArrayStim}{ElementArrayStim} class. Finally, you can use a cool feature of \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim} class. So far, we only used names of external files as its \texttt{image} input but it can also take a 2D NumPy array and display it as an image. We will use the latter approach, as it is the simplest.

Let us start by 1) creating a 2D grid, 2) converting it to a 3D image (for an RGB color space, PsychoPy expects one 2D grid of values per channel), and 3) displaying it via \href{https://psychopy.org/api/visual/imagestim.html\#psychopy.visual.ImageStim}{ImageStim}.

\hypertarget{a-random-matrix}{%
\section{A random matrix}\label{a-random-matrix}}

There are different ways to create a matrices (2D arrays) in NumPy, see \href{https://numpy.org/doc/stable/user/absolute_beginners.html\#creating-matrices}{Creating matrices}. Here, we will generate a matrix via NumPy \href{https://numpy.org/doc/stable/reference/random/generator.html}{random generator} but you could also experiment with generating an empty grid via \href{https://numpy.org/doc/stable/reference/generated/numpy.zeros.html}{numpy.zeros()} or a fully crowded one via \href{https://numpy.org/doc/stable/reference/generated/numpy.ones.html?highlight=ones}{numpy.ones()}.

Consult \href{https://numpy.org/doc/stable/reference/random/generator.html}{documentation} and figure out how to generate a grid of integers that range between \(0\) and \(1\) (hint, take a look at the second example that covers generating integer values) creating a matrix of the given size (hint, take a look at the third example). I suggest playing with the code in a Jupyter notebook starting with a small size of the grid (so you could easily see it in the output, as for a 3×4 grid below).

\begin{verbatim}
#> Grid shape:  (3, 4)
#> [[0 1 1 0]
#>  [1 0 0 1]
#>  [1 0 1 0]]
\end{verbatim}

\hypertarget{from-2d-to-3d}{%
\section{From 2D to 3D}\label{from-2d-to-3d}}

State of our cells is represented by a 2D NumPy array of size \texttt{{[}width,\ height{]}} but \href{https://psychopy.org/api/visual/imagestim.html}{ImageStim} expects a 3D array of size \texttt{{[}width,\ height,\ 3{]}} that defines the image in the \href{https://psychopy.org/general/colours.html\#rgb-color-space}{RGB} or some other \href{https://psychopy.org/general/colours.html}{color space}. The simplest way to do this for our game is to \href{https://numpy.org/doc/stable/reference/generated/numpy.stack.html?highlight=numpy\%20stack\#numpy-stack}{stack} the same 2D array three times. Zeros at all channels will give us black (empty space), whereas ones for all channels (a mixture of maximal red, green, and blue) will add to white. Again, experiment in a Jupyter notebook making sure that output and the \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html}{shape} of the 3D array are correct.

\begin{verbatim}
#> 3D grid shape:  (3, 3, 4)
#> [[[0 1 1 0]
#>   [1 0 0 1]
#>   [1 0 1 0]]
#> 
#>  [[0 1 1 0]
#>   [1 0 0 1]
#>   [1 0 1 0]]
#> 
#>  [[0 1 1 0]
#>   [1 0 0 1]
#>   [1 0 1 0]]]
\end{verbatim}

\hypertarget{correct-values-range}{%
\section{Correct values range}\label{correct-values-range}}

We are almost ready to use the 3D array as an image but our values go from \(0\) to \(1\), whereas the default RGB color space in PsychoPy expects values to go from \(-1\) (black) to \(1\) (white). Thus, we need to rescale the entire array via basic algebra. The good news is that NumPy is build on the idea of vectorization of operations, i.e., you do not need to apply the same operation to one element at a time (as you would do with Python list) but to the entire array at once.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\NormalTok{a }\OperatorTok{+} \DecValTok{10}
\CommentTok{\#\textgreater{} array([11, 12, 13, 14])}
\NormalTok{a }\OperatorTok{*} \DecValTok{10}
\CommentTok{\#\textgreater{} array([10, 20, 30, 40])}
\end{Highlighting}
\end{Shaded}

As per usual, experiment in a notebook and check that values turn out as expected:

\begin{verbatim}
#> [[[-1  1  1 -1]
#>   [ 1 -1 -1  1]
#>   [ 1 -1  1 -1]]
#> 
#>  [[-1  1  1 -1]
#>   [ 1 -1 -1  1]
#>   [ 1 -1  1 -1]]
#> 
#>  [[-1  1  1 -1]
#>   [ 1 -1 -1  1]
#>   [ 1 -1  1 -1]]]
\end{verbatim}

\hypertarget{showing-an-image}{%
\section{Showing an image}\label{showing-an-image}}

Finally, we are ready to create and show the image! Use the code from a Jupiter notebook to generate a random grid of size \texttt{{[}grid\ width,\ grid\ height{]}} (from the settings), stack it, and rescale it. Then, simply create an \href{https://psychopy.org/api/visual/imagestim.html}{ImageStim} passing the array as \texttt{image} and make sure that the image spans the entire window (what should it size be, given \texttt{"normal"} units?) and draw it in the main loop. Put a break point and use a debug console or watch tab to check whether image on the screen correspond to the original 2D grid.

Create a random grid and show it in \emph{code02.py}.

\hypertarget{slicing-a-border-problem}{%
\section{Slicing a border problem}\label{slicing-a-border-problem}}

We have a grid-to-image conversion but we are not out of the woods yet. The problem is the cells that live next to the border. They are of no trouble now but will become one, once we start counting their neighbors. Again, recall that we need to count all the neighbors \emph{around} each cell and for cells at the border that means trouble with indexes.

\begin{center}\includegraphics[width=0.36\linewidth]{images/game-of-life-border} \end{center}

We could be extra careful when indexing them, but there is a simpler solution: padding the grid with zeros. This way, we can use same rules for all \emph{inner} cells and never check or modify the empty padding.

\begin{center}\includegraphics[width=0.5\linewidth]{images/game-of-life-padding} \end{center}

This solution still requires extra work. Namely, we need to generate an empty 2D grid that is 2 elements wide and taller than we need, fill the inner part with random \(0\) and \(1\), and then use only that inner part when stacking a 3D array for an image. When using Python lists, we would need to use nested loops but NumPy's \href{https://numpy.org/doc/stable/user/absolute_beginners.html\#indexing-and-slicing}{indexing and slicing} makes it very easy.

Here is how it works for a 3×3 array.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.array([[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{], [}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{], [}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{9}\NormalTok{]])}
\NormalTok{a}
\CommentTok{\#\textgreater{} array([[1, 2, 3],}
\CommentTok{\#\textgreater{}        [4, 5, 6],}
\CommentTok{\#\textgreater{}        [7, 8, 9]])}
\end{Highlighting}
\end{Shaded}

The first index (called \href{https://numpy.org/doc/stable/glossary.html\#term-axis}{axis} in NumPy) is for row and the second is for columns. You can get the second row by specifying its index alone (if no other indexes are given, NumPy assumes you want all elements along other axes).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[}\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} array([4, 5, 6])}
\end{Highlighting}
\end{Shaded}

Or, you can be more explicit via \texttt{:}, as \texttt{:} alone means ``all elements along this axis''

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[}\DecValTok{1}\NormalTok{, :]}
\CommentTok{\#\textgreater{} array([4, 5, 6])}
\end{Highlighting}
\end{Shaded}

Similarly, you can extract the entire \emph{last} column (negative indexes work the same way as for Python lists) but notice that you need to explicitly mention the row axis in this case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[:, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{]}
\CommentTok{\#\textgreater{} array([3, 6, 9])}
\end{Highlighting}
\end{Shaded}

Even better, you can easily extract a rectangular part of a 2D matrix by specifying both rows and columns. Note that omitting either a start or stop value means, respectively, from the first or till the last element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[:}\DecValTok{2}\NormalTok{, }\OperatorTok{{-}}\DecValTok{2}\NormalTok{:]}
\CommentTok{\#\textgreater{} array([[2, 3],}
\CommentTok{\#\textgreater{}        [5, 6]])}
\end{Highlighting}
\end{Shaded}

Finally, this can be used not only to extract values from an array but also to modify them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a[}\OperatorTok{{-}}\DecValTok{2}\NormalTok{:, }\DecValTok{1}\NormalTok{:] }\OperatorTok{=}\NormalTok{ np.zeros((}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\NormalTok{a}
\CommentTok{\#\textgreater{} array([[1, 2, 3],}
\CommentTok{\#\textgreater{}        [4, 0, 0],}
\CommentTok{\#\textgreater{}        [7, 0, 0]])}
\end{Highlighting}
\end{Shaded}

The information above is enough to get you going but NumPy's documentation on \href{https://numpy.org/doc/stable/user/basics.indexing.html}{indexing} is definitely worth the read, if you need to use it frequently.

\hypertarget{padding-with-zeros}{%
\section{Padding with zeros}\label{padding-with-zeros}}

Now that you know how to slice a 2D array, let us redo the sequence:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  generate grid full of \href{https://numpy.org/doc/stable/reference/generated/numpy.zeros.html?highlight=zeros\#numpy.zeros}{zeros} that is two elements wide and taller than we need.
\item
  Fill the inner part (excluding that extra padding) with random \(0\) and \(1\).
\item
  Stack and rescale only the inner part for a 3D RGB array we need to an PsychoPy image.
\item
  Create and display the image.
\end{enumerate}

Generate a zero-padded random grid and show it in \emph{code03.py}.

\hypertarget{cell-culture}{%
\section{Cell culture}\label{cell-culture}}

Now that you have all the required pieces, wrap it up nicely in a \texttt{CellCulture} class. As we are displaying cells as an image, it makes sense to make it a descendant of the \href{https://psychopy.org/api/visual/imagestim.html}{ImageStim}. In the constructor, you only need the PsychoPy window and a dictionary with settings (so you know the grid size). You could more or less copy-paste code from the \emph{code03.py} into the constructor and use a parent constructor to initialize it once you generated a random grid. However, we need to perform \emph{1) extract inner part, 2) stack to 3D, 3) assign to image} on every iteration (after we updated the cell culture), so it makes sense to spin it off as a separate method (e.g., \texttt{set\_image\_from\_array()}). Thus, you can generate the zero-padded grid, initialize parent \emph{without} an image argument (PsychoPy allows for that) but only with window and size, and then call \texttt{set\_image\_from\_array()}).

Replace your code in the main script with a new class. It should work as before.

Create \texttt{CellCulture} class
Use it in \emph{code04.py}.

\hypertarget{counting-neigbors-single-cell-nested-loops-edition}{%
\section{Counting neigbors, single cell nested-loops edition}\label{counting-neigbors-single-cell-nested-loops-edition}}

Recall the rules, we need to count live neighbors for each cell and this is how we decide on whether it lives (or gets born) or dies (or the location remains empty). Let us implement this for a single cell first via nested loops and then via slicing. I suggest that you experiment and debug in a Jupiter notebook and we will transfer the code into the \texttt{CellCulture} class once it is ready. I will illustrate this using a zero-padded 5×5 grid.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rng }\OperatorTok{=}\NormalTok{ np.random.default\_rng(}\DecValTok{1423}\NormalTok{)}
\NormalTok{grid }\OperatorTok{=}\NormalTok{ np.zeros((}\DecValTok{7}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\NormalTok{grid[}\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{:}\OperatorTok{{-}}\DecValTok{1}\NormalTok{] }\OperatorTok{=}\NormalTok{ rng.integers(low}\OperatorTok{=}\DecValTok{0}\NormalTok{, high}\OperatorTok{=}\DecValTok{2}\NormalTok{, size}\OperatorTok{=}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{grid.astype(}\BuiltInTok{int}\NormalTok{)}
\CommentTok{\#\textgreater{} array([[0, 0, 0, 0, 0, 0, 0],}
\CommentTok{\#\textgreater{}        [0, 0, 1, 1, 0, 1, 0],}
\CommentTok{\#\textgreater{}        [0, 0, 0, 1, 1, 0, 0],}
\CommentTok{\#\textgreater{}        [0, 1, 0, 0, 1, 1, 0],}
\CommentTok{\#\textgreater{}        [0, 1, 1, 1, 0, 0, 0],}
\CommentTok{\#\textgreater{}        [0, 1, 0, 0, 1, 1, 0],}
\CommentTok{\#\textgreater{}        [0, 0, 0, 0, 0, 0, 0]])}
\end{Highlighting}
\end{Shaded}

Let us count the neighbors for a cell at location \((2, 2)\) (so, \emph{third} row and \emph{third} column). For the example grid that I generated using \(1423\) as a seed for the random generator, that should be \(4\).

\begin{center}\includegraphics[width=0.5\linewidth]{images/game-of-life-neighbors} \end{center}

Assume that the cell is identified via \texttt{icell\_row} and \texttt{icell\_col} and use nested loops to count the neighbors (think about the values \emph{relative} indexes you need to loop through). Note that the cell itself \emph{does not count}. You can either use an \texttt{if-else} for this but an alternative solution would be to count everybody and \emph{then} subtract the value of the cell itself. Implement the code and try it out with different \texttt{icell\_row} and \texttt{icell\_col}. Specifically test it for live cells, e.g., for \((2, 3)\) you should get four neighbors not five.

\hypertarget{slicing-neigbors-of-a-single-cell}{%
\section{Slicing neigbors of a single cell}\label{slicing-neigbors-of-a-single-cell}}

Nested loops are fun but slicing powers of NumPy make everything even easier. To count the neighbors, we need to extract a rectangular part of the matrix, very much the same way that we did when we dropped zero-padding. The only difference is that the rectangular part is defined relative to each cell. One the one hand, you can easily generate slicing on the fly relative to \texttt{icell\_row} and \texttt{icell\_col}: \texttt{grid{[}(compute\ start\ row):(compute\ end\ row),\ (compute\ start\ col):(compute\ end\ col){]}}. Just start with cells in the row and column \emph{before} the current one and end with one \emph{after} the current one. Make sure that you put brackets around expression for start and stop values, this is not necessary in Python\footnote{But \emph{is} necessary in R, which is a common source of errors where.} but it will make is easier to read them. Also, remember that start index is inclusive but stop index is exclusive (just as in the rest of Python). Here is a nice array that I have extracted:

\begin{verbatim}
#> [[0 1 1]
#>  [0 0 1]
#>  [1 0 0]]
\end{verbatim}

For didactic purposes, let us learn a different way to build relative index via \href{https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html?highlight=meshgrid}{numpy.meshgrid()}. It allows you to create two matrices so that corresponding cell cover all possible combinations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a, b }\OperatorTok{=}\NormalTok{ np.meshgrid([}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{], [}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{])}
\BuiltInTok{print}\NormalTok{(}\StringTok{"a}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a)}
\CommentTok{\#\textgreater{} a}
\CommentTok{\#\textgreater{}  [[1 2]}
\CommentTok{\#\textgreater{}  [1 2]]}
\BuiltInTok{print}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{b}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, b)}
\CommentTok{\#\textgreater{} }
\CommentTok{\#\textgreater{} b}
\CommentTok{\#\textgreater{}  [[3 3]}
\CommentTok{\#\textgreater{}  [4 4]]}
\end{Highlighting}
\end{Shaded}

Use this function to create 3×3 grids of \emph{relative} indexes for rows and columns (I called it \texttt{irel\_rows} and \texttt{irel\_cols}). You can hard code relative indexes or (better) use \href{https://numpy.org/doc/stable/reference/generated/numpy.arange.html?highlight=arange}{numpy.arange()} to generate the sequence.
and then compute \emph{absolute} index using \texttt{icell\_row} and \texttt{icell\_col}.

\begin{verbatim}
#> [[0 0 1]
#>  [1 0 0]
#>  [1 1 0]]
\end{verbatim}

We sliced the neighbors out but now we need to \emph{count} them via a \href{https://numpy.org/doc/stable/reference/generated/numpy.sum.html}{numpy.sum()} or, equivalently via a \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.sum.html}{sum()} method of an array. I tend to use the function but this is purely a matter of taste (or, more likely, habit), so pick the one you like.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(np.}\BuiltInTok{sum}\NormalTok{(grid))}
\CommentTok{\#\textgreater{} 14.0}
\BuiltInTok{print}\NormalTok{(grid.}\BuiltInTok{sum}\NormalTok{())}
\CommentTok{\#\textgreater{} 14.0}
\end{Highlighting}
\end{Shaded}

For our example subset, we get

\begin{verbatim}
#> Neighbor count for the example cell:  4.0
\end{verbatim}

\hypertarget{live-and-let-die}{%
\section{Live and let die}\label{live-and-let-die}}

Now that you have the code to count the neighbors, let us count them for all the \emph{inner} cells. Create a \emph{new} zeros matrix that will hold neighbor counts (same size as the grid itself) and loop through every inner cell, computing its number of neighbors and storing it in the new matrix. Here is the answer for the random grid above. Use my code above to generate it, so you can check whether you get the same answer but it is also a good idea to just count it yourself for a few cells to check that the answer is indeed correct.

\begin{verbatim}
#> [[0 0 0 0 0 0 0]
#>  [0 1 2 3 4 1 0]
#>  [0 2 4 4 5 4 0]
#>  [0 2 5 5 4 2 0]
#>  [0 3 4 3 5 4 0]
#>  [0 2 4 3 2 1 0]
#>  [0 0 0 0 0 0 0]]
\end{verbatim}

We have information about whether a cell is alive or dead in our \texttt{grid} matrix and information about its neighbor count is \texttt{neighbors}. Now we can use comparison and logical operation to implement the rules. Comparisons are easy, they work the same way but are applied to the entire array:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(a)}
\CommentTok{\#\textgreater{} [{-}3 {-}2 {-}1  0  1  2  3]}
\BuiltInTok{print}\NormalTok{(a }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} [ True  True  True False False False False]}
\end{Highlighting}
\end{Shaded}

The logical \texttt{and} and \texttt{or} are replaced with \href{https://numpy.org/doc/stable/reference/generated/numpy.logical_and.html}{\&} and \href{https://numpy.org/doc/stable/reference/generated/numpy.logical_or.html}{\textbar{}} but work the same way. The only thing to keep in mind is that comparisons must be wrapped in brackets (otherwise you will get an error)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ np.arange(}\OperatorTok{{-}}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{b }\OperatorTok{=}\NormalTok{ np.array([}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{])}

\BuiltInTok{print}\NormalTok{((a }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{ ) }\OperatorTok{\&}\NormalTok{ (b }\OperatorTok{==} \DecValTok{1}\NormalTok{))}
\CommentTok{\#\textgreater{} [ True False  True False False False False]}
\BuiltInTok{print}\NormalTok{((a }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{ ) }\OperatorTok{|}\NormalTok{ (b }\OperatorTok{==} \DecValTok{1}\NormalTok{))}
\CommentTok{\#\textgreater{} [ True  True  True False  True False  True]}
\end{Highlighting}
\end{Shaded}

We want ones and zeros, so integers rather than logical values. We can easily convert the entire array via \href{https://numpy.org/doc/stable/reference/generated/numpy.ndarray.astype.html?highlight=astype}{.astype()} method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{)}
\CommentTok{\#\textgreater{} array([ True,  True,  True, False, False, False, False])}
\NormalTok{(a }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{).astype(}\BuiltInTok{int}\NormalTok{)}
\CommentTok{\#\textgreater{} array([1, 1, 1, 0, 0, 0, 0])}
\end{Highlighting}
\end{Shaded}

Now you have everything you need to implement the first rule: cell must be alive \emph{and} have \(2\) \emph{or} \(3\) neighbors. Here is the output matrix:

\begin{verbatim}
#> [[0 0 0 0 0 0 0]
#>  [0 0 1 1 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 1 0 0 0 1 0]
#>  [0 1 0 1 0 0 0]
#>  [0 1 0 0 1 0 0]
#>  [0 0 0 0 0 0 0]]
\end{verbatim}

Rule number two: cell must be dead \emph{and} have \(3\) neighbors.

\begin{verbatim}
#> [[0 0 0 0 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 0 0 1 0 0 0]
#>  [0 0 0 0 0 0 0]]
\end{verbatim}

Finally, cell get to live because either rule \#1 \emph{or} rule \#2 worked for them:

\begin{verbatim}
#> [[0 0 0 0 0 0 0]
#>  [0 0 1 1 0 0 0]
#>  [0 0 0 0 0 0 0]
#>  [0 1 0 0 0 1 0]
#>  [0 1 0 1 0 0 0]
#>  [0 1 0 1 1 0 0]
#>  [0 0 0 0 0 0 0]]
\end{verbatim}

This final output is the new cell culture that you can assign back to the grid. Implement all the steps carefully and double\footnote{triple!} check that all numbers match. Try different random grids and go through them by hand to make sure everything is correct (this is the boring but vital part of programming, I am afraid).

\hypertarget{update-cell-culture}{%
\section{Update cell culture}\label{update-cell-culture}}

We have covered a lot of ground but now you have \emph{everything} to implement an \texttt{update()} method of \texttt{CellCulture} method:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Count the neighbors.
\item
  Apply rules to generate new culture.
\item
  Put the new culture into the \texttt{grid} attribute (or however you called it).
\item
  Transfer the grid to the image (you have a method for this).
\end{enumerate}

In the main code, call update method on every frame and see the cells evolve!

Add \texttt{update} method to \texttt{CellCulture} class
Use it in \emph{code05.py}.

\hypertarget{pause}{%
\section{Pause}\label{pause}}

In the main loop, you hopefully check for an \emph{escape} key press to end the game (if not, you should!) Let's also add a check for a press of \emph{space} button that will ``pause'' or ``continue'' the simulation. I.e., space should toggle (invert) a state of a logical variable (you name it) that determines whether the \texttt{update()} method is called.

Implement pause/continue via \emph{space} in \emph{code06.py}.

\hypertarget{unleash-your-creativity}{%
\section{Unleash your creativity}\label{unleash-your-creativity}}

Random cultures are fun but, perhaps, you have an idea to try out (e.g., see a \href{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}{Wikipedia article} on example patterns such as blinkers and gliders). Let us draw with the \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{mouse} (this is why I insisted on having it as an attribute of the context), with the left button \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse}{click} (index \(0\)) adding a living cell and the right button click (index \(2\)) erasing it.

For this, create a new \texttt{CellCulture} method (I called it \texttt{change()}) that takes a new value (\(0\) or \(1\), depending on the button) and \href{https://psychopy.org/api/event.html\#psychopy.event.Mouse.getPos}{mouse position} within the window. In the method, compute the row and column index of the cell keeping in mind that 1) the image spans the entire image, 2) only the inner cells are shown and can be clicked on. Once you have both indexes, assign new value to the grid. For testing, pause the game, draw a few patterns, restart and see them go!

Add \texttt{change()} method to \texttt{CellCulture}
Use mouse inputs and \texttt{change()} in \emph{code07.py}.

\hypertarget{done-for-today}{%
\section{Done for today}\label{done-for-today}}

You have learned quite a few things about \href{https://numpy.org/}{NumPy} and implemented a cool simulation. Next time, we will learn more about Numpy while combining it with a useful \href{https://psychopy.org/api/visual/elementarraystim.html\#psychopy.visual.ElementArrayStim}{ElementArrayStim} I have teased about.

  \bibliography{book.bib}

\end{document}
