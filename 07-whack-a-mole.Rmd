# Whack a Mole{#whack-a-mole}

Today you will create your first _video_ game Whack-a-Mole. The game itself is very much a reaction time experiment: moles/targets appear after a random delay at one of the predefined locations, the player's task is to whack (press a corresponding button) the mole/target before it disappears. Your final game should look approximately like this:

::: {.rmdnote .practice}
**MISSING VIDEO!**
:::

In this game, we will need to handle many targets and many keys, so you need to learn about lists first.

## Lists {#lists}
So far, we were using variables to store single values: computer's pick, player's guess, number of attempts, PsychoPy window object, etc. But sometimes we need to handle more than one value. We already had this problem in the [computer-based Guess-the-Number](#guess-the-number-ai) game when we needed to store the remaining number range. We got away by using two variables, one for the lower and one for the upper limit. However, this approach clearly does not scale well and, sometimes, we might not even know how many values we will need to store. Python's [lists](https://docs.python.org/3/library/stdtypes.html#lists) are the solution to the problem.

A list is a mutable^[More on that and tuples (list's immutable cousins) later.] sequence of items where individual elements can be accessed via their zero-based index. Extending the idea of [variable-as-a-box](#variables), you can think about lists as a box with numbered slots. To store and retrieve a particular piece you will need to know both the _variable name_ and the _index of the item_ you are interested in within that box. Then, you work with a variable-plus-index in exactly the same way you work with a normal variable, accessing or changing its value via the same syntax as before.

A list is defined via square brackets `<variable> = [<value1>, <value2>, ... <valueN>]`. An individual slot within a list is also accessed via square brackets `<variable>[<index>]` where index is, again, **zero-based**^[This is typical for "classic" programming languages but less so for ones that are linear algebra / data science oriented. Both Matlab and R use one-based indexing, so you need to be careful and double-check whether you are using correct indexes.]. This means that the _first_ items is `variable[0]` and, if there are _N_ items in the list, the last one is `variable[N-1]`. You can figure out the total number of items in a list by getting its length via a special [len()](https://docs.python.org/3/library/functions.html#len) function. Thus, you can access the last item via `variable[len(variable)-1]`^[There is a simpler way to do this, which you will learn in a little while.]. Note the `-1`: If you list has 3 items, the index of the last one is 2, if it has 100, then 99, etc. I am spending so much time on this because it is a fairly common source of confusion.

::: {.rmdnote .practice}
Do exercise #1 see how lists are defined and indexed.
:::

Lists also allow you access more than one slot/index at a time via _slicing_. You can specify index of elements via `<start>:<stop>` notation. For example, `x[1:3]` will give you access to two items with indexes 1 and 2. Yes, _two_ items: Slicing index goes from the `start` up to **but not including** the `stop`. Thus, if you want to get _all_ the items of a list, you will need to write `x[0:length(x)]` and, yet, to get the last item alone you still write `x[len(x)-1]`. Confusing? I think so. I understand the logic but I find this stop-is-not-included to be counterintuitive and I still have to consciously remind myself about this. Unfortunately, this is a standard way to define sequences of numbers in Python, so you need to memorize this.

::: {.rmdnote .practice}
Do exercise #2 to build the intuition.
:::

When slicing, you can omit either `start` or `stop`. In this case, Python will assume that a missing `start` means `0` (the index of the first element) and missing `stop` means `len(<list>)` (so, last item is included). If you omit _both_, e.g., `my_pretty_numbers[:]` it will return all values, as this is equivalent to `my_pretty_numbers[0:len(my_pretty_numbers)]`.^[Note, that this is almost but not quite the same thing as just writing `my_pretty_numbers`, the difference is subtle but important. We will return to it later when talking about mutable versus immutable types.]

::: {.rmdnote .practice}
Do exercise #3.
:::

You can also use _negative_ indexes that are computed relative to length of the list. For example, if you want to get the _last_ element of the list, you can say `my_pretty_numbers[len(my_pretty_numbers)-1]` or just `my_pretty_numbers[-1]`. The last-but-one element would be `my_pretty_numbers[-2]`, etc. You can use negative indexes for slicing but keep in mind the _including the start but excluding the stop_ catch: `my_pretty_numbers[:-1]` will return all but last element of the list not the entire list!

::: {.rmdnote .practice}
Do exercise #4.
:::

Slicing can be extended by specifying a `step` via `stop:start:step` notation. `step` can be negative, allowing you to build indexes in the reverse order:
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers[4:0:-1]
```

However, you must pay attention to the sign of the step. If it goes in the wrong direction then  `stop` cannot be reached, Python will return an empty list.
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers[4:0:1]
```
Steps can be combined with omitted and negative indexes. To get every _odd_ element of the list, you write `my_pretty_numbers[::2]`:  
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers[::2]
```

::: {.rmdnote .practice}
Do exercise #5.
:::

If you try to to access indexes _outside_ of a valid range, Python will raise an [IndexError](https://docs.python.org/3/library/exceptions.html#IndexError)^[If you are familiar with R and its liberal attitude towards indexes, you will find this very satisfying.]. Thus, trying to get 6^th^ element (index 5) of a five-element-long list will generate a simple and straightforward error. However, if your _slice_ is larger than the range, it will be truncated without an extra warning or an error. So, for a five-element list `my_pretty_numbers[:6]` or `my_pretty_numbers[:600]` will both return all numbers (effectively, this is equivalent to `my_pretty_numbers[:]`). Moreover, if the slice is empty (`2:2`, cannot include 2 because it is a stop value, even though it starts from 2 as well) or the entire slice is outside of the range, Python will return an empty list, again, neither warning or error is generated.

::: {.rmdnote .practice}
Do exercise #6.
:::

In Python lists are dynamic, so you can always add or remove elements to it, see [the list of methods ]](https://docs.python.org/3/tutorial/datastructures.html#more-on-lists). You can add a new item to the of the end of the list via `append(<new_value>)` method
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers.append(10)
my_pretty_numbers
```

Or, you can `insert(<index>, <new_value>)` _before_ an element with that index. Unfortunately, this means that you can use an arbitrary large index and it will insert a new value as a _last_ element without generating an error.
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers.insert(2, 10)
my_pretty_numbers.insert(500, 20)
my_pretty_numbers
```
You can remove an item using its index via `pop(<index>)`, note that the item is _returned_ as well. If you omit the index, `pop()` removes the _last_ element of the list. Here, you can only use valid indexes.
```{python}
my_pretty_numbers = [1, 2, 3, 4, 5, 6, 7]
my_pretty_numbers.pop(-1)
my_pretty_numbers.pop(3)
my_pretty_numbers
```

::: {.rmdnote .practice}
Do exercise #7.
:::

## Basic game loop
Phew that was _a lot_ about lists (and we barely scratched the surface). However, [all work and no play makes Jack a dull boy](https://en.wikipedia.org/wiki/All_work_and_no_play_makes_Jack_a_dull_boy)! So let us start with a basic PsychoPy game loop that we used the last time
```python
import libraries from [psychopy]
create the PsychoPy window ([visual.Window()]())
create a variable that indicates that the game is not over yet
while not gameover:
  flip the window (.flip())
  game over, if a player pressed the escape button (event.getKeys())
close the window (.close())
```

Try doing it from scratch. I have left hints to help you with this and you can always consult the [online documentation](https://psychopy.org/api/index.html). Do not forget to document the file and to split your code into meaningful chunks with comments (if needed).

::: {.rmdnote .program}
Put your code into _code01.py_.
:::

## Three moles
Let us create three moles that will be represented by [circles](https://psychopy.org/api/visual/circle.html#psychopy.visual.circle.Circle). Create a new list variable `moles` before the loop and put three circles into it. One should go to the left, one dead center, and one to the right (watch a video above to see what I mean, you can also use different colors for them, as I did). You can either create an empty list and then `append()` circles one at a time. Or you can use brackets to put all three of them into the list in one go. Then. [draw()](https://psychopy.org/api/visual/circle.html#psychopy.visual.circle.Circle.draw) circles inside the main loop. Note that you have to draw them one at a time. Therefore, you will need to add three lines for this but the next section will show you an easier way.

::: {.rmdnote .program}
Put your code into _code02.py_.
:::


